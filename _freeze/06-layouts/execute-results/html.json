{
  "hash": "b3ef272011b07bfffff46dbaf1342559",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n  cache: true\n---\n\n# Layouts, themes, HTML {#sec-chap06}\n\n\n\n## Introduction\n\n:::::: {#obj-chap06}\n::::: my-objectives\n::: my-objectives-header\nChapter section list\n:::\n\n::: my-objectives-container\n:::\n:::::\n::::::\n\n## Single page layouts {#sec-06-single-page-layouts}\n\nLayout functions provide the high-level visual structure of an app.\nLayouts are created by a hierarchy of function calls, where the\nhierarchy in R matches the hierarchy in the generated HTML. This helps\nyou understand layout code.\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-06-single-page-layout}\n: Single page layout\n:::\n::::\n\n::: my-r-code-container\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n#| components: [editor, viewer]\n\nui <- fluidPage(\n  titlePanel(\"Hello Shiny!\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"obs\", \"Observations:\", min = 0, max = 1000, value = 500)\n    ),\n    mainPanel(\n      plotOutput(\"distPlot\")\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n::::::\n\n### Page functions\n\nThe most important, but least interesting, layout function is\n`fluidPage()`, which you’ve seen in pretty much every example so far.\nBut what’s it doing and what happens if you use it by itself? Figure 6.1\nshows the results: it looks like a very boring app but there’s a lot\ngoing behind the scenes, because `fluidPage()` sets up all the HTML,\nCSS, and JavaScript that Shiny needs.\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-06-fluid-page}\n: An UI consisting just of `fluidPage()`\n:::\n::::\n\n::: my-r-code-container\n```{shinylive-r}\n#| standalone: true\n#| components: [editor, viewer]\n\n\nui <- fluidPage()\n\nserver <- function(input, output, session) {}\n\nshinyApp(ui, server)\n```\n:::\n::::::\n\nIn addition to `fluidPage()`, Shiny provides a couple of other page\nfunctions that can come in handy in more specialized situations:\n`fixedPage()` and `fillPage()`.\n\n-   `fixedPage()` works like `fluidPage()` but has a fixed maximum\n    width, which stops your apps from becoming unreasonably wide on\n    bigger screens.\n-   `fillPage()` fills the full height of the browser and is useful if\n    you want to make a plot that occupies the whole screen.\n\n:::::: my-resource\n:::: my-resource-header\n::: {#lem-06-fluid-page}\n: Page functions\n:::\n::::\n\n::: my-resource-container\n-   [fluidPage()](https://shiny.posit.co/r/reference/shiny/latest/fluidpage.html):\n    Create a page with fluid layout.\n-   [fixedPage()](https://shiny.posit.co/r/reference/shiny/latest/fixedpage.html):\n    Create a page with a fixed layout.\n-   [fillPage()](https://shiny.posit.co/r/reference/shiny/latest/fillpage.html):\n    Create a page that fills the window.\n:::\n::::::\n\n### Page with sidebar\n\nTo make more complex layouts, you’ll need call layout functions inside\nof `fluidPage()`. For example, to make a two-column layout with inputs\non the left and outputs on the right you can use `sidebarLayout()`\n(along with its friends `titlePanel()`, `sidebarPanel()`, and\n`mainPanel()`).\n\n:::::: my-resource\n:::: my-resource-header\n::: {#lem-06-page-with-sidebar}\n: Sidebar functions\n:::\n::::\n\n::: my-resource-container\n-   [sidebarLayout()](https://shiny.posit.co/r/reference/shiny/latest/sidebarlayout.html):\n    Layout a sidebar and main area. Create a layout (`sidebarLayout()`)\n    with a sidebar (`sidebarPanel()`) and main area (`mainPanel()`)\n-   [titlePanel()](https://shiny.posit.co/r/reference/shiny/latest/titlepanel.html):\n    Create a panel containing an application title.\n:::\n::::::\n\n![Structure of a page with\nsidebar](https://mastering-shiny.org/diagrams/action-layout/sidebar.png){#fig-06-01\nfig-alt=\"alt-text\" fig-align=\"center\" width=\"70%\"}\n\n::::::::::::::::: column-body-outset\n:::::::::::::::: my-code-collection\n::::: my-code-collection-header\n::: my-code-collection-icon\n:::\n\n::: {#exm-06-page-sidebar}\n: Page with sidebar layout\n:::\n:::::\n\n:::::::::::: my-code-collection-container\n::::::::::: panel-tabset\n###### Empty Layout\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-06-page-sidebar-empty}\n: Page with sidebar\n:::\n::::\n\n::: my-r-code-container\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 200\n#| components: [editor, viewer]\n#| layout: vertical\n\n# Define UI\nui <- fluidPage(\n\n    titlePanel(\"Hello Shiny!\"),\n\n    sidebarLayout(\n        sidebarPanel(\"sidebarPanel\"),\n        mainPanel(\"mainPanel\")\n    )\n)\n\n# Server logic\nserver <- function(input, output) {}\n\n# Complete app with UI and server components\nshinyApp(ui, server)\n\n```\n\n------------------------------------------------------------------------\n\nI had to choose a slightly wider page width. Otherwise Shiny would have\nstacked the two panels.\n:::\n::::::\n\n###### Example\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-06-page-sidebar-example}\n: Layout example: Page with sidebar\n:::\n::::\n\n::: my-r-code-container\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 500\n#| components: [editor, viewer]\n#| layout: vertical\n\n\nui <- fluidPage(\n  titlePanel(\"Central limit theorem\"),\n  sidebarLayout(\n    sidebarPanel(\n      numericInput(\"m\", \"Number of samples: (1-100)\", 2, min = 1, max = 100),\n      \"Increase the number of samples to see the distribution become more normal.\"\n    ),\n    mainPanel(\n      plotOutput(\"hist\")\n    )\n  )\n)\nserver <- function(input, output, session) {\n  output$hist <- renderPlot({\n    req(\"m\")\n    means <- replicate(1e4, mean(runif(input$m)))\n    hist(means, breaks = 20)\n  }, res = 96)\n}\n\nshinyApp(ui, server)\n```\n\n------------------------------------------------------------------------\n\nRendering the app (or reloading the web page) results for a moment with\nthe error message \"figure margins too large\". I do not know why this\nhappens and how to prevent it.\n:::\n::::::\n:::::::::::\n::::::::::::\n::::::::::::::::\n:::::::::::::::::\n\n### Multi-row\n\nUnder the hood, `sidebarLayout()` is built on top of a flexible\nmulti-row layout, which you can use directly to create more visually\ncomplex apps. As usual, you start with `fluidPage()`. Then you create\nrows with `fluidRow()`, and columns with `column()`.\n\n:::::: my-resource\n:::: my-resource-header\n::: {#lem-06-multi-row-layout}\n: Multi-row functions\n:::\n::::\n\n::: my-resource-container\nA fluid page layout consists of rows which in turn include columns.\n\n-   [fluidRow()](https://shiny.posit.co/r/reference/shiny/latest/fluidpage.html):\n    Rows exist for the purpose of making sure their elements appear on\n    the same line (if the browser has adequate width).\n-   [column()](https://shiny.posit.co/r/reference/shiny/latest/column.html):\n    Columns exist for the purpose of defining how much horizontal space\n    within a 12-unit wide grid it's elements should occupy.\n:::\n::::::\n\nEach row is made up of 12 columns and the first argument to `column()`\ngives how many of those columns to occupy. A 12 column layout gives you\nsubstantial flexibility because you can easily create 2-, 3-, or\n4-column layouts, or use narrow columns to create spacers. You can see\nan example of this layout in @sec-04-prototype.\n\nIf you’d like to learn more about designing using a grid system, I\nhighly recommend the classic text on the subject: “Grid systems in\ngraphic design” by Josef Müller-Brockman [-@mueller-brockmann-1998].\n\n![The structure underlying a simple multi-row\napp](https://mastering-shiny.org/diagrams/action-layout/multirow.png){#fig-06-02\nfig-alt=\"alt-text\" fig-align=\"center\" width=\"70%\"}\n\n### Exercises\n\n#### `sidebarLayout()`\n\nRead the documentation of `sidebarLayout()` to determine the width (in\ncolumns) of the sidebar and the main panel. Can you recreate its\nappearance using `fluidRow()` and `column()`? What are you missing?\n\n::::::::::::::: column-body-outset\n:::::: my-exercise\n:::: my-exercise-header\n::: {#exr-06-ex-01-sidebarlayout}\n: `sidebarLayout()`\n:::\n::::\n\n::: my-exercise-container\nThe `sidbarbarPanel()` has a width of 4 columns and the `mainPanel()` is\neight columns wide. The 12 column grid of the standard page is divided\n1/3 (controls) : 2/3 (output).\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 100\n#| components: [editor, viewer]\n#| layout: vertical\n\nui <- fluidPage(\n  fluidRow(\n    column(\n      width = 4, \n      \"place for the controls: 4 columns\"\n      ),\n    column(\n      width = 8, \n      \"place for the output: 8 columns\"\n    )\n  )\n\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n\n------------------------------------------------------------------------\n\nMissing is the `titlePanel()`.\n:::\n::::::\n\n#### Change panel positions\n\nModify the Central Limit Theorem app from @exm-06-page-sidebar to put\nthe sidebar on the right instead of the left.\n\n:::::: my-exercise\n:::: my-exercise-header\n::: {#exr-sidebar-right}\n: Central Limit Theorem with the sidebar on the right\n:::\n::::\n\n::: my-exercise-container\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 500\n#| components: [editor, viewer]\n#| layout: vertical\n\nui <- fluidPage(\n  titlePanel(\"Central limit theorem\"),\n  sidebarLayout(\n    sidebarPanel(\n      numericInput(\"m\", \"Number of samples: (1-100)\", 2, min = 1, max = 100),\n      \"Increase the number of samples to see the distribution become more normal.\"\n    ),\n    mainPanel(\n      plotOutput(\"hist\")\n    ),\n    position = \"right\"\n  )\n)\nserver <- function(input, output, session) {\n  output$hist <- renderPlot({\n    req(\"m\")\n    means <- replicate(1e4, mean(runif(input$m)))\n    hist(means, breaks = 20)\n  }, res = 96)\n}\n\nshinyApp(ui, server)\n```\n:::\n::::::\n\n#### Stacked `sidebarLayout()`\n\n:::::: my-exercise\n:::: my-exercise-header\n::: {#exr-06-ex-03}\n: Main panel divided 50:50 with sidebar below\n:::\n::::\n\n::: my-exercise-container\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 500\n#| components: [editor, viewer]\n#| layout: vertical\n\nui <- fluidPage(\n  title = \"Central limit theorem\",\n  fluidRow(\n    column(width = 6, \n           plotOutput(\"hist1\")\n           ),\n    column(width = 6,\n           plotOutput(\"hist2\")\n           ),\n  ),\n  fluidRow(\n    column(width = 6,\n           numericInput(\"m1\", \"Number of samples: (1-100)\", 2, min = 1, max = 100)\n           ),\n    column(width = 6,\n           numericInput(\"m2\", \"Number of samples: (1-100)\", 2, min = 1, max = 100)\n           )\n  )\n)\n\n\nserver <- function(input, output, session) {\n  output$hist1 <- renderPlot({\n    means <- replicate(1e4, mean(runif(input$m1)))\n    hist(means, breaks = 20)\n  }, res = 96)\n  \n  output$hist2 <- renderPlot({\n    means <- replicate(1e4, mean(runif(input$m2)))\n    hist(means, breaks = 20)\n  }, res = 96)\n}\n\nshinyApp(ui, server)\n```\n:::\n::::::\n:::::::::::::::\n\n## Multi-page layout\n\nAs your app grows in complexity, it might become impossible to fit\neverything on a single page. In this section you’ll learn various uses\nof `tabPanel()` that create the illusion of multiple pages. This is an\nillusion because you’ll still have a single app with a single underlying\nHTML file, but it’s now broken into pieces and only one piece is visible\nat a time.\n\nMulti-page apps pair particularly well with modules, which you’ll learn\nabout in @XXX_19. Shiny modules allow you to partition up the server\nfunction in the same way you partition up the user interface, creating\nindependent components that only interact through well defined\nconnections.\n\n### Tabsets\n\nThe simple way to break up a page into pieces is to use `tabsetPanel()`\nand its close friend `tabPanel()`. As you can see in the code below,\n`tabsetPanel()` creates a container for any number of `tabPanels()`,\nwhich can in turn contain any other HTML components.\n\n`tabsetPanel()` can be used anywhere in your app; it’s totally fine to\nnest tabsets inside of other components (including tabsets!) if needed.\n\n:::::::::::::::: my-code-collection\n::::: my-code-collection-header\n::: my-code-collection-icon\n:::\n\n::: {#exm-06-tabsets}\n: Using tabsets: `tabsetPanel()` and `tabPanels()`\n:::\n:::::\n\n:::::::::::: my-code-collection-container\n::::::::::: panel-tabset\n###### Simple example\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-tabset-simple-example}\n: A simple tabset example\n:::\n::::\n\n::: my-r-code-container\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n#| components: [editor, viewer]\n#| layout: vertical\n\nui <- fluidPage(\n  tabsetPanel(\n    tabPanel(\"Data\", \n      fileInput(\"file\", \"Data\", buttonLabel = \"Upload...\"),\n      textInput(\"delim\", \"Delimiter (leave blank to guess)\", \"\"),\n      numericInput(\"skip\", \"Rows to skip\", 0, min = 0),\n      numericInput(\"rows\", \"Rows to preview\", 10, min = 1)\n    ),\n    tabPanel(\"Parameters\"),\n    tabPanel(\"Results\")\n  )\n)\n\nserver <- function(input, output, session) {}\n\nshinyApp(ui, server)\n```\n:::\n::::::\n\n###### With ID\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-06-tabset-with-id}\n: Tabset with location detection (via ID)\n:::\n::::\n\n::: my-r-code-container\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 200\n#| components: [editor, viewer]\n#| layout: vertical\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      textOutput(\"panel\")\n    ),\n    mainPanel(\n      tabsetPanel(\n        id = \"tabset\",\n        tabPanel(\"panel 1\", \"one\"),\n        tabPanel(\"panel 2\", \"two\"),\n        tabPanel(\"panel 3\", \"three\")\n      )\n    )\n  )\n)\n\n\nserver <- function(input, output, session) {\n  output$panel <- renderText({\n    paste(\"Current panel: \", input$tabset)\n  })\n}\n\n\nshinyApp(ui, server)\n```\n:::\n::::::\n:::::::::::\n::::::::::::\n::::::::::::::::\n\n### Navlist and navbars\n\nBecause tabs are displayed horizontally, there’s a fundamental limit to\nhow many tabs you can use, particularly if they have long titles.\n`navbarPage()` and `navbarMenu()` provide two alternative layouts that\nlet you use more tabs with longer titles.\n\n`navlistPanel()` is similar to `tabsetPanel()` but instead of running\nthe tab titles horizontally, it shows them vertically in a sidebar. It\nalso allows you to add headings with plain strings, as shown in the code\nbelow.\n\nAnother approach is the use of `navbarPage()`: it still runs the tab\ntitles horizontally, but you can use `navbarMenu()` to add drop-down\nmenus for an additional level of hierarchy.\n\n:::::::::::::::: my-code-collection\n::::: my-code-collection-header\n::: my-code-collection-icon\n:::\n\n::: {#exm-06-navbar}\n: Navlist and navbars\n:::\n:::::\n\n:::::::::::: my-code-collection-container\n::::::::::: panel-tabset\n###### `navlistPanel()`\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-06-navlist-panel}\n: `navlistPanel()`: Tabs horizontally\n:::\n::::\n\n::: my-r-code-container\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\nui <- fluidPage(\n  navlistPanel(\n    id = \"tabset\",\n    \"Heading 1\",\n    tabPanel(\"panel 1\", \"Panel one contents\"),\n    \"Heading 2\",\n    tabPanel(\"panel 2\", \"Panel two contents\"),\n    tabPanel(\"panel 3\", \"Panel three contents\")\n  )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n::::::\n\n###### navbarPage()\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-06-navbar-page}\n: `navbarPage()` with `navbarMenu()` for submenues\n:::\n::::\n\n::: my-r-code-container\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\nui <- navbarPage(\n  \"Page title\",   \n  tabPanel(\"panel 1\", \"one\"),\n  tabPanel(\"panel 2\", \"two\"),\n  tabPanel(\"panel 3\", \"three\"),\n  navbarMenu(\"subpanels\", \n    tabPanel(\"panel 4a\", \"four-a\"),\n    tabPanel(\"panel 4b\", \"four-b\"),\n    tabPanel(\"panel 4c\", \"four-c\")\n  )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n::::::\n:::::::::::\n::::::::::::\n::::::::::::::::\n\n## Bootstrap\n\n<a class='glossary' title='Bootstrap is a free and open-source CSS framework designed for responsive, mobile-first front-end web development. The framework provides HTML, CSS, and JavaScript-based design templates for various interface components such as typography, forms, buttons, navigation, and more. It aims to simplify the process of creating responsive and mobile-friendly websites by offering pre-styled components and a grid system.'>Bootstrap</a> is a collection of HTML conventions, CSS\nstyles, and JS snippets bundled up into a convenient form.\n\nIt’s good to know that Bootstrap exists because then:\n\n-   You can use `bslib::bs_theme()` to customize the visual appearance\n    of your code, @sec-06-themes.\n-   You can use the `class` argument to customize some layouts, inputs,\n    and outputs using Bootstrap class names, as you saw in\n    @sec-action-buttons.\n-   You can make your own functions to generate Bootstrap components\n    that Shiny doesn’t provide, as explained in “[Utility\n    classes](https://rstudio.github.io/bslib/articles/utility-classes/index.html)”.\n\n:::::: my-resource\n:::: my-resource-header\n::: {#lem-shiny-css-frameworks}\n: Shiny CSS frameworks\n:::\n::::\n\n::: my-resource-container\n-   [{**bslib**}](https://rstudio.github.io/bslib/index.html) by\n    <a class='glossary' title='Posit is an open-source data science software company that was formerly known as RStudio Inc. Posit’s rebranding was aimed at expanding its offerings beyond R to include support for other languages, reflecting a shift towards a more language-agnostic approach to data science tools. The RStudio IDE, which is now part of Posit, remains a popular tool for data scientists who develop in R and Python. There are many other important software products developed and maintained by Posit such as, Quarto, Shiny, tidymodels, tidyverse, and many other popular packages. https://posit.co/'>Posit</a> based on\n    [Bootstrap](https://getbootstrap.com/) [@bslib].\n-   [{**shiny.semantics**}](https://appsilon.github.io/shiny.semantic/)\n    by <a class='glossary' title='Appsilon is a company that specializes in data science and visualization services. They offer R Shiny application development, enterprise dashboard solutions, and machine learning implementations. Additionally, they provide services such as UI/UX design, full-stack engineering support, DevOps for Posit products, and the creation of custom R packages for Shiny applications. https://www.appsilon.com/'>Appsilon</a>, builds on top of [Fomantic\n    UI](https://fomantic-ui.com/) [@shiny.semantic]. Appsilon also\n    developed\n    [{**rhino**}](https://appsilon.github.io/rhino/index.html), an R\n    package designed for professional developers to help building high\n    quality, enterprise-grade Shiny applications at speed [@rhino].\n-   [{**shinyMobile**}](https://shinymobile.rinterface.com/) by\n    <a class='glossary' title='RinteRface aims at bringing the most famous open source HTML templates to R. https://rinterface.com/'>RInteRface</a>, builds on top of [framework\n    7](https://framework7.io/), and is specifically designed for mobile\n    apps [@shinyMobile].\n-   [{**shinymaterial**}](https://ericrayanderson.github.io/shinymaterial/)\n    by [Eric Anderson,](https://github.com/ericrayanderson) is built on\n    top of [Google’s Material design\n    framework](https://m3.material.io/).\n-   [{**shinydashboard**}](https://rstudio.github.io/shinydashboard/)\n    also by Posit, provides a layout system designed to create\n    dashboards.\n\nYou can find a fuller, and actively maintained, list at [Awesome Shiny\nExtension](https://github.com/nanxstats/awesome-shiny-extensions).\n:::\n::::::\n\n## Themes {#sec-06-themes}\n\nBootstrap is so ubiquitous within the R community that it’s easy to get\nstyle fatigue: after a while every Shiny app and Rmd start to look the\nsame. The solution is theming with the {**bslib**} package.\n{**bslib**}[^06-layouts-1] is a relatively new package that allows you\nto override many Bootstrap defaults in order to create an appearance\nthat is uniquely yours.\n\n[^06-layouts-1]: Therefore the name: `bslib` is an acronym for\n    **b**oot**s**trap **lib**rary.\n\n{**bslib**} has several advantages:\n\n-   It is designed not only to work for Shiny but also for other\n    contexts, like R Markdown.\n-   It provides [custom\n    theming](https://rstudio.github.io/bslib/articles/theming/index.html),\n    even interactively in real-time.\n-   It uses newer versions of <a class='glossary' title='Bootstrap is a free and open-source CSS framework designed for responsive, mobile-first front-end web development. The framework provides HTML, CSS, and JavaScript-based design templates for various interface components such as typography, forms, buttons, navigation, and more. It aims to simplify the process of creating responsive and mobile-friendly websites by offering pre-styled components and a grid system.'>Bootstrap</a> and\n    <a class='glossary' title='Bootswatch is a collection of themes for Bootstrap. It provides pre-built themes that can be easily applied to a Bootstrap project, simplifying the process of achieving a polished and professional look.'>Bootswatch</a>, whereas Shiny and\n    <a class='glossary' title='R Markdown is a file format for creating dynamic documents that combine text written in markdown with chunks of embedded R code. This allows users to weave together narrative text and code to produce elegantly formatted output, such as HTML, PDF, or Microsoft Word documents, among others.'>R Markdown</a> currently default to Bootstrap 3 and may\n    continue to do so to maintain backwards compatibility.\n\n:::::: my-resource\n:::: my-resource-header\n::: {#lem-06-bslib-layout-design}\n: {bslib} layout design\n:::\n::::\n\n::: my-resource-container\n-   {**bslib**} [package\n    documentation](https://rstudio.github.io/bslib/index.html) for\n    custom bootstrap <a class='glossary' title='SASS (Syntactically Awesome Style Sheets) is a CSS preprocessor that extends CSS with additional features to make styling easier and more efficient. Some key extensions include variables, nesting, and mixins. Variables allow you to store values like colors and fonts, making it easier to update styles across your stylesheet. Nesting enables you to write CSS selectors in a hierarchical manner, similar to HTML structure, reducing redundancy. Mixins let you define reusable blocks of CSS properties. Additionally, SASS supports functions and modules, which help organize and manage complex stylesheets more effectively. SCSS, short for Sassy CSS, is the main syntax used in SASS and is a superset of CSS, meaning all valid CSS is also valid SCSS. It uses the .scss file extension and includes all the features mentioned above.'>SASS</a> themes for Shiny and R\n    Markdown\n-   New Shiny [application layout\n    guide](https://shiny.posit.co/r/articles/build/layout-guide/) based\n    on {**bslib**}\n-   [Bootstrap](https://getbootstrap.com/) is a free and open-source CSS\n    framework designed for responsive, mobile-first front-end web\n    development.\n-   [Bootswatch](https://bootswatch.com/) is a collection of pre-built\n    themes that can be easily applied to a Bootstrap project,\n    simplifying the process of achieving a polished and professional\n    look.\n:::\n::::::\n\n### Getting started\n\nCreate a theme with `bslib::bs_theme()` then apply it to an app with the\ntheme argument of the page layout function:\n\n``` markdown\nfluidPage(\n  theme = bslib::bs_theme(...)\n)\n```\n\nIf not specified, Shiny will use the classic Bootstrap v3 theme that it\nhas used basically since it was created. By default,\n`bslib::bs_theme()`, will use Bootstrap v5. Using Bootstrap v5 instead\nof v3 will not cause problems if you only use built-in components. There\nis a possibility that it might cause problems if you’ve used custom\nHTML, so you can force it to stay with v3 with `version = 3`.\n\n### Shiny themes\n\nThe easiest way to change the overall look of your app is to pick a\npremade “bootswatch” theme using the bootswatch argument to\n`bslib::bs_theme()`.\n\n::::::::::::::::::: my-code-collection\n::::: my-code-collection-header\n::: my-code-collection-icon\n:::\n\n::: {#exm-06-shiny-themes}\n: Title for code collection\n:::\n:::::\n\n::::::::::::::: my-code-collection-container\n:::::::::::::: panel-tabset\n###### predefined theme\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-06-bslib-predefined-theme}\n: Shiny with a `bslib` predefined theme\n:::\n::::\n\n::: my-r-code-container\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 450\n#| components: [editor, viewer]\n\n\nui <- fluidPage(\n  theme = bslib::bs_theme(bootswatch = \"darkly\"),\n  sidebarLayout(\n    sidebarPanel(\n      textInput(\"txt\", \"Text input:\", \"text here\"),\n      sliderInput(\"slider\", \"Slider input:\", 1, 100, 30)\n    ),\n    mainPanel(\n      h1(paste0(\"Theme: darkly\")),\n      h2(\"Header 2\"),\n      p(\"Some text\")\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n::::::\n\n###### custom changes\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-bslib-with-custom-appearance}\n: Shiny with custom theme changes\n:::\n::::\n\n::: my-r-code-container\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 450\n#| components: [editor, viewer]\n#| error: true\n\nui <- fluidPage(\n  theme = bslib::bs_theme(\n  bg = \"#0b3d91\", \n  fg = \"white\", \n  base_font = \"Source Sans Pro\"\n  ),\n  sidebarLayout(\n    sidebarPanel(\n      textInput(\"txt\", \"Text input:\", \"text here\"),\n      sliderInput(\"slider\", \"Slider input:\", 1, 100, 30)\n    ),\n    mainPanel(\n      h1(paste0(\"Theme: darkly\")),\n      h2(\"Header 2\"),\n      p(\"Some text\")\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n::::::\n\nIn my first trials I got always the error message \"Text to be written\nmust be a length-one character vector\". After googling the error message\nI found out that the error message comes from {**htmltools**}:\n\n> This error occurs in htmltools::WSTextWriter (see\n> [here](https://rdrr.io/cran/htmltools/src/R/utils.R) and CTRL+F to\n> look for \"writeImpl\"). This function is in charge of properly writing\n> text to your display when you display a raw text in any UI function.\n> It raises the mentioned error when the `writeImpl()` function receives\n> more than one character string (aka element of a `character()`\n> vector). To correct this, make sure you never provide two character\n> strings to a Shiny UI function asking for only one character argument.\n> (From Eli Ker Ano, the first comment under the StackOverflow question\n> [Text to be written must be a length-one character\n> vector](https://stackoverflow.com/questions/58608109/text-to-be-written-must-be-a-length-one-character-vector)).\n\nI tried to follow this advice but to no avail. Even if I deleted all\nlines between `sidebarPanel()` and `mainPanel()` the error persisted.\nCould it be that {**bslib**} has changed in the meanwhile and requires\nother layout commands? This means that it would not be fully compatible\nwith Shiny anymore. That seems unlikely.\n\n::::: my-important\n::: my-important-header\n`=`instead of `<-` required for `theme = bslib::bs_theme()`\n:::\n\n::: my-important-container\nAfter several hours I finally found the problem. The `<-` operator works\nfine without additional parameters (allowed is only\n`bootswatch = \"<theme name>\"`) but with (additional) other arguments you\nhave to use the `=` operator.\n\nI copied the code snippet from the book and that was wrong! In the code\nchunk of `6.5.1 Shiny Themes` is the correct `=` operator used, but in\nthe code snippet below not.\n\nWith `shinylive` in the Quarto document it works with the `<-` operator\nas well!\n:::\n:::::\n::::::::::::::\n:::::::::::::::\n:::::::::::::::::::\n\n### Plot themes\n\nIf you’ve heavily customized the style of your app, you may want to also\ncustomize your plots to match. Luckily, this is really easy thanks to\nthe {**thematic**} package which automatically themes {**ggplot2**},\n{**lattice**}, and base plots. Just call `thematic::thematic_shiny()` in\nyour server function. This will automatically determine all of the\nsettings from your app theme.\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-ID-text}\n: Numbered R Code Title\n:::\n::::\n\n::: my-r-code-container\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n#| components: [editor, viewer]\n#| layout: vertical\n\nlibrary(shiny)\nlibrary(ggplot2)\n\nui <- fluidPage(\n  theme = bslib::bs_theme(bootswatch = \"darkly\"),\n  titlePanel(\"A themed plot\"),\n  plotOutput(\"plot\"),\n)\n\nserver <- function(input, output, session) {\n  thematic::thematic_shiny()\n  \n  output$plot <- renderPlot({\n    ggplot(mtcars, aes(wt, mpg)) +\n      geom_point() +\n      geom_smooth()\n  }, res = 96)\n}\n\nshinyApp(ui, server)\n```\n:::\n::::::\n\n### Exercises {#sec-chap06-5_4_exercises}\n\n## Under the hood\n\nThere’s no magic behind all the input, output, and layout functions:\nthey just generate HTML. (The magic is done by JavaScript, which is\noutside the scope of the book.)\n\nYou can see that HTML by executing UI functions directly in the console:\n\n``` markdown\nshiny::fluidPage(\n  shiny::textInput(\"name\", \"What's your name?\")\n)\n\n<div class=\"container-fluid\">\n  <div class=\"form-group shiny-input-container\">\n    <label for=\"name\">What's your name?</label>\n    <input id=\"name\" type=\"text\" class=\"form-control\" value=\"\"/>\n  </div>\n</div>\n```\n\nNote that this is the contents of the `<body>` tag; other parts of Shiny\ntake care of generating the `<head>`. If you want to include additional\nCSS or JS dependencies you’ll need to learn\n`htmltools::htmlDependency()`. Two good places to start are\nhttps://blog.r-hub.io/2020/08/25/js-r/#web-dependency-management and\nhttps://unleash-shiny.rinterface.com/htmltools-dependencies.html.\n\nIt’s possible to add your own HTML to the ui. There are two different\nways:\n\n-   One way to do so is by including literal HTML with the\n    `htmltools::HTML()` function. In the example below, the “[raw\n    character\n    constant](https://josiahparry.com/posts/2023-01-19-raw-strings-in-r.html)”,\n    `r\"()\"` is used, to make it easier to include quotes in the string.\n    You can even skip `fluidPage()` altogether and supply raw HTML for\n    the whole UI. See [Build your entire UI with\n    HTML](https://shiny.posit.co/r/articles/build/html-ui/) for more\n    details.\n-   Alternatively, you can make use of the HTML helper that Shiny\n    provides via import of {**htmltools**} functions. There are regular\n    functions for the most important elements like `h1()` and `p()`, and\n    all others can be accessed via the other `tags`\n    helper[^06-layouts-2]. Named arguments become attributes and unnamed\n    arguments become children, so we can recreate the above HTML with these regular functions.\n\n[^06-layouts-2]: Because Shiny imports {**htmltools**} **it** is\n    therefore not necessary to write `htmltools::h1()`,\n    `htmltools::p()` etc. When `library(shiny)` is loaded just\n    `h1() or`, `p()` is enough.\n\n:::::::::::::::: my-code-collection\n::::: my-code-collection-header\n::: my-code-collection-icon\n:::\n\n::: {#exm-06-html-ui}\n: Raw HTML for the UI\n:::\n:::::\n\n:::::::::::: my-code-collection-container\n::::::::::: panel-tabset\n###### Raw HTML for UI\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-06-html-ui-raw}\n: Add HTML raw code snippets to the Shiny UI\n:::\n::::\n\n::: my-r-code-container\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n#| components: [editor, viewer]\n\n\nui <- shiny::fluidPage(\n  htmltools::HTML(r\"(\n    <h1>This is a heading</h1>\n    <p class=\"my-class\">This is some text!</p>\n    <ul>\n      <li>First bullet</li>\n      <li>Second bullet</li>\n    </ul>\n  )\")\n)\n\nserver <- function(input, output, session) {}\n\nshinyApp(ui, server)\n```\n:::\n::::::\n\n###### HTML with functions\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-06-using-html-ui-helper}\n: Numbered R Code Title (Tidyverse)\n:::\n::::\n\n::: my-r-code-container\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n#| components: [editor, viewer]\n\nui <- fluidPage(\n  h1(\"This is a heading\"),\n  p(\"This is some text\", class = \"my-class\"),\n  tags$ul(\n    tags$li(\"First bullet\"), \n    tags$li(\"Second bullet\")\n  )\n)\n\nserver <- function(input, output, session) {}\n\nshinyApp(ui, server)\n```\n:::\n::::::\n:::::::::::\n::::::::::::\n::::::::::::::::\n\nOne advantage of generating HTML with code is that you can interweave existing Shiny components into a custom structure. For example, the code below makes a paragraph of text containing two outputs, one which is bold:\n\n```markdown\ntags$p(\n  \"You made \", \n  tags$b(\"$\", textOutput(\"amount\", inline = TRUE)),\n  \" in the last \", \n  textOutput(\"days\", inline = TRUE),\n  \" days \" \n)\n```\nNote the use of `inline = TRUE`; the `textOutput()` default is to produce a complete paragraph.\n\nTo learn more about using HTML, CSS, and JavaScript to make compelling user interfaces, I highly recommend David Granjon’s Outstanding User Interfaces with Shiny.\n\n:::::: my-resource\n:::: my-resource-header\n::: {#lem-06-html-css-js-for-shiny-ui}\n: HTML, CSS, and JavaScript to make compelling user interfaces\n:::\n::::\n\n::: my-resource-container\n-   [Handle HTML dependencies with\n    {**htmltools**}](https://unleash-shiny.rinterface.com/htmltools-dependencies.html)\n-   [Web dependency\n    management](https://blog.r-hub.io/2020/08/25/js-r/#web-dependency-management)\n-   [Build your entire UI with\n    HTML](https://shiny.posit.co/r/articles/build/html-ui/)\n-   [JavaScript for R](https://book.javascript-for-r.com/)\n:::\n::::::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}