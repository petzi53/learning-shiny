{
  "hash": "af0edc7026a4f1236765c43147e0162f",
  "result": {
    "engine": "knitr",
    "markdown": "# Uploads and donwloads {#sec-chap09}\n\n\n\n\n## Table of content for chapter 04 {.unnumbered}\n\n::::: {#obj-chap03}\n:::: {.my-objectives}\n::: {.my-objectives-header}\nChapter section list\n:::\n\n::: {.my-objectives-container}\n\n\n:::\n::::\n:::::\n\n## File upload\n\n### UI\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-file-upload-ui}\n: File upload UI\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n#| components: [editor, viewer]\n\n\nui <- fluidPage(\n  fileInput(\"upload\", \"Upload a file\")\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n\n***\n\nTry in interactive mode adding / changing the arguments `label`, `width`, `buttonLabel` and `placeholder` to see how it affects the UI appearance.\n::::\n:::::\n\nThe UI needed to support file uploads is simple: just add `shiny::fileInput()` to your UI.\n\nLike most other UI components, there are only two required arguments: `id` and `label`. The `width`, `buttonLabel` and `placeholder` arguments allow you to tweak the appearance in other ways. I won’t discuss them here, but you can read more about them in [File Upload Control — fileInput](https://shiny.posit.co/r/reference/shiny/1.6.0/fileinput.html).\n\n### Server\n\nHandling `fileInput()` on the server is a little more complicated than other inputs. Most inputs return simple vectors, but `fileInput()` returns a data frame with four columns:\n\n- **name**: the original file name on the user’s computer.\n- **size**: the file size, in bytes. By default, the user can only upload files up to 5 MB. You can increase this limit by setting the shiny.maxRequestSize option prior to starting Shiny. For example, to allow up to 10 MB run options(shiny.maxRequestSize = 10 * 1024^2).\n- **type**: the <a class='glossary' title='A MIME type, short for Multipurpose Internet Mail Extensions, specifies the nature and format of a document, file, or collection of bytes. It helps identify the type of data being transmitted over the internet, such as text, images, videos, or applications. MIME types consist of two parts separated by a slash: the media type and the subtype. For example, ‘image/jpeg’ indicates a JPEG image file.'>MIME type</a> of the file. This is a formal specification of the file type that is usually derived from the extension and is rarely needed in Shiny apps.\n- **datapath**: the path to where the data has been uploaded on the server. Treat this path as ephemeral: if the user uploads more files, this file may be deleted. The data is always saved to a temporary directory and given a temporary name.\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-file-upload-server}\n: File upload server \n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n#| components: [editor, viewer]\n#| layout: vertical\n\nui <- fluidPage(\n  fileInput(\"upload\", NULL, buttonLabel = \"Upload...\", multiple = TRUE),\n  tableOutput(\"files\")\n)\nserver <- function(input, output, session) {\n  output$files <- renderTable(input$upload)\n}\n\nshinyApp(ui, server)\n```\n\n::: {.callout-warning #wrn-09-file-upload-server}\n\n`fileInput()` does not show multiple uploaded files. One can see only the last one. \n\nThis issue was on May 2, 2021 [opened at GitHub](https://github.com/hadley/mastering-shiny/issues/468), but it is still not closed. I do not know with my rudimentary knowledge at the moment (2025-06-08) how to solve this problem.\n\n\n:::\n\n\n::::\n:::::\n\n\n### Uploading data\n\nIf the user is uploading a dataset, there are two details that you need to be aware of:\n\n- `input$upload` is initialized to `NULL` on page load, so you’ll need `req(input$upload)` to make sure your code waits until the first file is uploaded.\n\nThe `accept` argument allows you to limit the possible inputs. The easiest way is to supply a character vector of file extensions, like `accept = \".csv\"`. But the accept argument is only a suggestion to the browser, and is not always enforced, so it’s good practice to also validate it (e.g. @XXX_8.1) yourself. The easiest way to get the file extension in R is `tools::file_ext()`, just be aware it removes the leading `.` from the extension.\n\nPutting all these ideas together gives us the following app where you can upload a `.csv` or `.tsv` file and see the first `n` rows. See it in action in <https://hadley.shinyapps.io/ms-upload-validate>.\n",
    "supporting": [
      "09-uploads-downloads_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}