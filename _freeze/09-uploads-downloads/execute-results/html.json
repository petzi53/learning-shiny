{
  "hash": "7ed2c748ea02833f01cdcdc62f12c782",
  "result": {
    "engine": "knitr",
    "markdown": "# Uploads and downloads {#sec-chap09}\n\n\n\n\n## Table of content for chapter 09 {.unnumbered}\n\n::::: {#obj-chap03}\n:::: {.my-objectives}\n::: {.my-objectives-header}\nChapter section list\n:::\n\n::: {.my-objectives-container}\n\n\n:::\n::::\n:::::\n\n## File upload {#sec-09-file-upload}\n\n### UI\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-file-upload-ui}\n: File upload UI\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n#| components: [editor, viewer]\n\n\nui <- fluidPage(\n  fileInput(\"upload\", \"Upload a file\")\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n\n***\n\nTry in interactive mode adding / changing the arguments `label`, `width`, `buttonLabel` and `placeholder` to see how it affects the UI appearance.\n::::\n:::::\n\nThe UI needed to support file uploads is simple: just add `shiny::fileInput()` to your UI.\n\nLike most other UI components, there are only two required arguments: `id` and `label`. The `width`, `buttonLabel` and `placeholder` arguments allow you to tweak the appearance in other ways. I won’t discuss them here, but you can read more about them in [File Upload Control — fileInput](https://shiny.posit.co/r/reference/shiny/1.6.0/fileinput.html).\n\n### Server\n\nHandling `fileInput()` on the server is a little more complicated than other inputs. Most inputs return simple vectors, but `fileInput()` returns a data frame with four columns:\n\n- **name**: the original file name on the user’s computer.\n- **size**: the file size, in bytes. By default, the user can only upload files up to 5 MB. You can increase this limit by setting the `shiny.maxRequestSize` option prior to starting Shiny. For example, to allow up to 10 MB run options(`shiny.maxRequestSize = 10 * 1024^2`).\n- **type**: the <a class='glossary' title='A MIME type, short for Multipurpose Internet Mail Extensions, specifies the nature and format of a document, file, or collection of bytes. It helps identify the type of data being transmitted over the internet, such as text, images, videos, or applications. MIME types consist of two parts separated by a slash: the media type and the subtype. For example, ‘image/jpeg’ indicates a JPEG image file.'>MIME type</a> of the file. This is a formal specification of the file type that is usually derived from the extension and is rarely needed in Shiny apps.\n- **datapath**: the path to where the data has been uploaded on the server. Treat this path as ephemeral: if the user uploads more files, this file may be deleted. The data is always saved to a temporary directory and given a temporary name.\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-file-upload-server}\n: File upload server \n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n#| components: [editor, viewer]\n#| layout: vertical\n\nui <- fluidPage(\n  fileInput(\"upload\", NULL, buttonLabel = \"Upload...\", multiple = TRUE),\n  tableOutput(\"files\")\n)\nserver <- function(input, output, session) {\n  output$files <- renderTable(input$upload)\n}\n\nshinyApp(ui, server)\n```\n\n::: {.callout-warning #wrn-09-file-upload-server}\n\n`fileInput()` does not show multiple uploaded files. One can see only the last one. \n\nThis issue was on May 2, 2021 [opened at GitHub](https://github.com/hadley/mastering-shiny/issues/468), but it is still not closed. I do not know with my rudimentary knowledge at the moment (2025-06-08) how to solve this problem.\n\n\n:::\n\n\n::::\n:::::\n\n\n### Uploading data\n\nIf the user is uploading a dataset, there are two details that you need to be aware of:\n\n- `input$upload` is initialized to `NULL` on page load, so you’ll need `req(input$upload)` to make sure your code waits until the first file is uploaded.\n- The `accept` argument allows you to limit the possible inputs. The easiest way is to supply a character vector of file extensions, like `accept = \".csv\"`. But the accept argument is only a suggestion to the browser, and is not always enforced, so it’s good practice to also validate it (e.g. @sec-08-validating-input) yourself. The easiest way to get the file extension in R is `tools::file_ext()`, just be aware it removes the leading `.` from the extension.\n\nPutting all these ideas together gives us the following app where you can upload a `.csv` or `.tsv` file and see the first `n` rows. See it in action in <https://hadley.shinyapps.io/ms-upload-validate>.\n\n\n::: {.column-page-inset}\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-uploading-data}\n: Uploading data\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 550\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\nui <- fluidPage(\n  fileInput(\"upload\", NULL, accept = c(\".csv\", \".tsv\")),\n  numericInput(\"n\", \"Rows\", value = 5, min = 1, step = 1),\n  tableOutput(\"head\")\n)\n\nserver <- function(input, output, session) {\n  data <- reactive({\n    req(input$upload)\n\n    ext <- tools::file_ext(input$upload$name)\n    switch(ext,\n      csv = vroom::vroom(input$upload$datapath, delim = \",\"),\n      tsv = vroom::vroom(input$upload$datapath, delim = \"\\t\"),\n      validate(\"Invalid file; Please upload a .csv or .tsv file\")\n    )\n  })\n\n  output$head <- renderTable({\n    head(data(), input$n)\n  })\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\n:::\n\n::: {.callout-note #nte-09-upload-data}\nNote that since `multiple = FALSE` (the default), `input$file` will be a single row data frame, and `input$file$name` and `input$file$datapath` will be a length-1 character vector.\n:::\n\n## Downloads\n\n### Basics\n\n- Again, the UI is straightforward: use either `downloadButton(id)` or `downloadLink(id)` to give the user something to click to download a file. You can customize their appearance using the same class and icon arguments as for `actionButtons()`, as described in @sec-02-action-buttons.\n- Unlike other outputs, `downloadButton()` is not paired with a render function. Instead, you use `downloadHandler()`.\n\n`downloadHandler()` has two arguments, both functions:\n\n- `filename` should be a function with no arguments that returns a file name (as a string). The job of this function is to create the name that will be shown to the user in the download dialog box.\n- `content` should be a function with one argument, `file`, which is the path to save the file. The job of this function is to save the file in a place that Shiny knows about, so it can then send it to the user. This is an unusual interface, but it allows Shiny to control where the file should be saved (so it can be placed in a secure location) while you still control the contents of that file.\n\nNext we’ll put these pieces together to show how to transfer data files or reports to the user.\n\n### Downloading data\n\nThe following app shows off the basics of data download by allowing you to download any dataset in the datasets package as a tab separated file. \n\n::: {.callout-tip #tip-09-use-tsv-instead-of-csv}\n###### Use `.tsv` instead of `csv`\n\nI recommend using `.tsv` (tab separated value) instead of `.csv` (comma separated values) because many European countries use commas to separate the whole and fractional parts of a number (e.g. 1,23 vs 1.23). This means they can’t use commas to separate fields and instead use semi-colons in so-called “c”sv files! You can avoid this complexity by using tab separated files, which work the same way everywhere.\n:::\n\n\n::: {.column-page-inset}\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-downloading-data}\n: Downloading data\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 650\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\n# Workaround for Chromium Issue 468227 ######\n# Need this to properly download the csv file\n# this bug and workaround is only for shinylive, \n#you do not need it in your regular app\ndownloadButton <- function(...) {\n  tag <- shiny::downloadButton(...)\n  tag$attribs$download <- NULL\n  tag\n}\n### End of workaround ####\n\nui <- fluidPage(\n  selectInput(\"dataset\", \"Pick a dataset\", ls(\"package:datasets\")),\n  tableOutput(\"preview\"),\n  downloadButton(\"download\", \"Download .tsv\")\n)\n\nserver <- function(input, output, session) {\n  data <- reactive({\n    out <- get(input$dataset, \"package:datasets\")\n    if (!is.data.frame(out)) {\n      validate(paste0(\"'\", input$dataset, \"' is not a data frame\"))\n    }\n    out\n  })\n\n  output$preview <- renderTable({\n    head(data())\n  })\n\n  output$download <- downloadHandler(\n    filename = function() {\n      paste0(input$dataset, \".tsv\")\n    },\n    content = function(file) {\n      vroom::vroom_write(data(), file)\n    }\n  )\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\n::: \n\n::: {.callout-warning #wrn-09-downloading-data}\n###### Workaround for Chromium Issue\n\nTo properly download the file in `shinylive` you need a workaround. Put the following function outside `server()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndownloadButton <- function(...) {\n  tag <- shiny::downloadButton(...)\n  tag$attribs$download <- NULL\n  tag\n}\n```\n:::\n\n\nThis workaround is not necessary in an `app.R` file.\n\n:::\n\nNote the use of `validate()` to only allow the user to download datasets that are data frames. A better approach would be to pre-filter the list, but this lets you see another application of `validate()`.\n\n### Downloading reports {#sec-09-downloading-reports}\n\n#### Standard {#sec-09downloading-reports-standard}\n\nAs well as downloading data, you may want the users of your app to download a report that summarizes the result of interactive exploration in the Shiny app. This is quite a lot of work, because you also need to display the same information in a different format, but it is very useful for high-stakes apps.\n\nOne powerful way to generate such a report is with a [parameterised RMarkdown document](https://bookdown.org/yihui/rmarkdown/parameterized-reports.html). A parameterised <a class='glossary' title='RMarkdown is a file format for creating dynamic documents that combine text written in markdown with chunks of embedded R code. This allows users to weave together narrative text and code to produce elegantly formatted output, such as HTML, PDF, or Microsoft Word documents, among others.'>RMarkdown</a> file has a params field in the <a class='glossary' title='YAML stands for “YAML Ain’t Markup Language”, some people reverse it humorously to “Yet Another Markup Language.”) It is a human-readable data serialization language commonly used for configuration files and data transmission. YAML is designed with simplicity and readability in mind, using indentation and minimal punctuation to represent data structures, making it intuitive to read. There is a YAML package in R that provides methods to convert R data to YAML and back. https://yaml.org/ is the official website.'>YAML</a> metadata:\n\n````markdown\n\ntitle: My Document\noutput: html_document\nparams:\n  year: 2018\n  region: Europe\n  printcode: TRUE\n  data: file.csv\n\n````\n\nInside the document, you can refer to these values using `params$year`, `params$region` etc. The values in the YAML metadata are defaults; you’ll generally override them by providing the params argument in a call to `rmarkdown::render()`. This makes it easy to generate many different reports from the same <a class='glossary' title='“.Rmd” is a file extension used for RMarkdown files, which are documents that combine text, R code, and the results of that code execution. These files are used to create reproducible reports, presentations, and other documents that can be converted into various formats such as HTML, PDF, and Word. R ws users to write text in Markdown syntax and embed R code chunks, which are executed to produce output that is included in the final document (“literate programming”). This makes it easy to create dynamic documents that can be updated automatically when the underlying data or code changes.'>.Rmd</a>.\n\nHere’s a simple example adapted from <https://shiny.rstudio.com/articles/generating-reports.html>, which describes this technique in more detail. The key idea is to call `rmarkdown::render()` from the content argument of `downloadHander()`. If you want to produce other output formats, just change the output format in the `.Rmd`, and make sure to update the extension (e.g. to `.pdf`). See it in action at <https://hadley.shinyapps.io/ms-download-rmd>.\n\n\n\n::: {.column-page-inset}\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-downloading-reports-1}\n: Downloading reports\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 550\n#| components: [editor, viewer]\n\n\nlibrary(shiny)\n\n# Workaround for Chromium Issue 468227 ######\n# Need this to properly download the csv file\n# this bug and workaround is only for shinylive, \n#you do not need it in your regular app\ndownloadButton <- function(...) {\n  tag <- shiny::downloadButton(...)\n  tag$attribs$download <- NULL\n  tag\n}\n### End of workaround ####\n\n## see the warning callout under this code chunk\nSys.setenv(\n    RSTUDIO_PANDOC=\"/Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/aarch64\")\n\n## I got the same error message with another pandoc version at macOS system level\n## Sys.setenv(RSTUDIO_PANDOC=\"/opt/homebrew/bin\")\n\nui <- fluidPage(\n  sliderInput(\"n\", \"Number of points\", 1, 100, 50),\n  downloadButton(\"report\", \"Generate report\")\n)\n\nserver <- function(input, output, session) {\n  output$report <- downloadHandler(\n    filename = \"report.html\",\n    content = function(file) {\n      params <- list(n = input$n)\n\n      id <- showNotification(\n        \"Rendering report...\",\n        duration = NULL,\n        closeButton = FALSE\n      )\n      on.exit(removeNotification(id), add = TRUE)\n\n      rmarkdown::render(\"report.Rmd\",\n        output_file = file,\n        params = params,\n        envir = new.env(parent = globalenv())\n      )\n    }\n  )\n}\n\nshinyApp(ui, server)\n\n\n## file: report.Rmd\n## {{< include report.Rmd >}}\n```\n\n::::\n:::::\n\n:::\n\n::: {.callout-warning #wrn-09-downloading-reports-1}\n###### Downloading reports is not working\n\nThe code chunk does not produce an error. But whenever you click the button \"Generate report\" the following message is created in a new browser window: \n\n> An error has occurred!\n> pandoc version 1.12.3 or higher is required and was not found (see the help page ?rmarkdown::pandoc_available).\n\nI tried to solve the problem with [hints from StackOverflow](https://stackoverflow.com/questions/28432607/pandoc-version-1-12-3-or-higher-is-required-and-was-not-found-r-shiny), especially the [answer edited by Yihui Xie](https://stackoverflow.com/a/29710643/7322615).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.getenv(\"RSTUDIO_PANDOC\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"/Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/aarch64\"\n```\n\n\n:::\n:::\n\n\nBut to add `Sys.setenv(\"RSTUDIO_PANDOC\"=Sys.getenv(\"RSTUDIO_PANDOC\"))` did not work.\n\nI tried it also with another [pandoc](https://pandoc.org/) version installed at my macOS with [homebrew](https://brew.sh/):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrmarkdown::pandoc_exec()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"/opt/homebrew/bin/pandoc\"\n```\n\n\n:::\n:::\n\n\nI assume there are path problems with `shinylive`. \n\n:::\n\n\n#### Using {**callr**} {#sec-09downloading-reports-callr}\n\nIt’ll generally take at least a few seconds to render a `.Rmd`, so this is a good place to use a notification from @sec-08-notification.\n\nThere are a couple of other tricks worth knowing about:\n\n- RMarkdown works in the current working directory, which will fail in many deployment scenarios (e.g. on <https:://shinyapps.io>). You can work around this by copying the report to a temporary directory when your app starts (i.e. outside of the server function):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreport_path <- tempfile(fileext = \".Rmd\")\nfile.copy(\"report.Rmd\", report_path, overwrite = TRUE)\n```\n:::\n\n\n\n\nThen replace \"report.Rmd\" with `report_path` in the call to `rmarkdown::render()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrmarkdown::render(report_path,\n  output_file = file,\n  params = params,\n  envir = new.env(parent = globalenv())\n)\n```\n:::\n\n\n\n\n- By default, RMarkdown will render the report in the current process, which means that it will inherit many settings from the Shiny app (like loaded packages, options, etc). For greater robustness, I recommend running `render()` in a separate R session using the {**callr**} package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrender_report <- function(input, output, params) {\n  rmarkdown::render(input,\n    output_file = output,\n    params = params,\n    envir = new.env(parent = globalenv())\n  )\n}\n\nserver <- function(input, output) {\n  output$report <- downloadHandler(\n    filename = \"report.html\",\n    content = function(file) {\n      params <- list(n = input$slider)\n      callr::r(\n        render_report,\n        list(input = report_path, output = file, params = params)\n      )\n    }\n  )\n}\n```\n:::\n\n\n\n\n::: {.column-page-inset}\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-downloading-reports-2}\n: Downloading reports\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 550\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\n# shinylive Workaround Start ######\ndownloadButton <- function(...) {\n    tag <- shiny::downloadButton(...)\n    tag$attribs$download <- NULL\n    tag\n}\n### End of workaround ####\n\n# Copy report to temporary directory. This is mostly important when\n# deploying the app, since often the working directory won't be writable\nreport_path <- tempfile(fileext = \".Rmd\")\nfile.copy(\"report.Rmd\", report_path, overwrite = TRUE)\n\nrender_report <- function(input, output, params) {\n    rmarkdown::render(input,\n                      output_file = output,\n                      params = params,\n                      envir = new.env(parent = globalenv())\n    )\n}\n\n rmarkdown::render(\"report.Rmd\",\n        output_file = file,\n        params = params,\n        envir = new.env(parent = globalenv())\n      )\n\nui <- fluidPage(\n    sliderInput(\"n\", \"Number of points\", 1, 100, 50),\n    downloadButton(\"report\", \"Generate report\")\n)\n\nserver <- function(input, output) {\n    output$report <- downloadHandler(\n        filename = \"report.html\",\n        content = function(file) {\n            params <- list(n = input$n)\n            callr::r(\n                render_report,\n                list(input = report_path, output = file, params = params)\n            )\n        }\n    )\n}\n\nshinyApp(ui, server)\n\n\n#### The include macro generates error\n#### \"object 'params' not found\n## file: report.Rmd\n# {{< include report.Rmd >}}    \n\n\n```\n\n::::\n:::::\n\n:::\n\n\n::: {.callout-warning  #wrn-09-download-report-failure}\nThe last two code chunks didn't work.\n\nAt first I got the message with a code version I can't reproduce\n> Warning: Error in : ! in callr subprocess      \n> Caused by error in `abs_path(input)`:          \n> ! The file '/var/folders/sd/g6yc4rq1731__gh38rw8whvc0000gr/T//RtmplpyWiO/file422772b5bfd1.Rmd' does not exist.\n\nIn the current code version I got an error message whenever I try to include the `report.Rmd` file.\n\n> error: object 'params' not found\n:::\n\n:::::{.my-resource}\n:::{.my-resource-header}\n:::::: {#lem-09-downloding-reports}\n: Downloading reports with shiny and looking for `shinylive` error messages\n::::::\n:::\n::::{.my-resource-container}\n\n- You can see all these pieces put together in [rmarkdown-report/](https://github.com/hadley/mastering-shiny/tree/main/rmarkdown-report), found inside the Mastering Shiny GitHub repo. It works as Shiny app but with `shinylive` I got the error message reported in @wrn-09-download-report-failure.\n- The {**shinymeta**} package solves a related problem: sometimes you need to be able to turn the current state of a Shiny app into a reproducible report that can be re-run in the future. ([Github Source](https://github.com/rstudio/shinymeta), [Documentation](https://rstudio.github.io/shinymeta/). My [latest CRAN version 0.2.0.3](https://github.com/rstudio/shinymeta/releases/tag/v0.2.0.3) is from November 17, 2021. In the meantime there were [15 commits](https://github.com/rstudio/shinymeta/compare/v0.2.0.3...main) indicating that a new version is in preparation. preparation. )\n- Learn more about the {**shinymeta**} package in Joe Cheng’s useR! 2019 keynote, “[Shiny’s holy grail](https://www.youtube.com/watch?v=5KByRC6eqC8)^[Attention: The video starts at minute 11:20.]: Interactivity with reproducibility”. There is also the code for the example Shiny app available, featuring package download data from <a class='glossary' title='CRAN stands for the Comprehensive R Archive Network, which is R’s central software repository, supported by the R Foundation. It contains an archive of the latest and previous versions of the R distribution, documentation, and contributed R packages. (https://cran.r-project.org/)'>CRAN</a>.The code for the example Shiny app is available at GitHub. The sample code is useful in its own. It features package download data from <a class='glossary' title='CRAN stands for the Comprehensive R Archive Network, which is R’s central software repository, supported by the R Foundation. It contains an archive of the latest and previous versions of the R distribution, documentation, and contributed R packages. (https://cran.r-project.org/)'>CRAN</a>.\n- Concerning again {**shinymeta**}: Keep in mind that there were  [breaking changes](https://github.com/rstudio/shinymeta/wiki/Syntax-changes-for-shinymeta-0.2.0) in the meantime by replacing bang-bang (`!!`) with the dot-dot operator (`..()`). \n- It seems to me that a [question on StackOverflow](https://stackoverflow.com/questions/28432607/pandoc-version-1-12-3-or-higher-is-required-and-was-not-found-r-shiny) is relevant to my `shinylive-r` issue. At least I got exactly the same error message as in the question. But even with the different hints to solve the problem, notably the [edited answer by Yihui Xie](https://stackoverflow.com/a/29710643/7322615) and the following several comments, I could not solve the `shinylive-r` error message.\n\n::::\n:::::\n\n\n\n## Case study {#sec-09-case-study}\n\nTo finish up, we’ll work through a small case study where we upload a file (with user supplied separator), preview it, perform some optional transformations using the {**janitor**} package [@janitor], and then let the user download it as a `.tsv`.\n\nTo make it easier to understand how to use the app, I’ve used `sidebarLayout()` to divide the app into three main steps:\n\n1. Uploading and parsing the file\n2. Cleaning the file\n3. Downloading the file\n\nAll three parts get assembled into a single `fluidPage()` and the server logic follows the same organization.\n\n\n::: {.column-page-inset}\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-case-study}\n: Upload a file, clean it, and then download the results\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 650\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\n# shinylive Workaround Start ######\ndownloadButton <- function(...) {\n    tag <- shiny::downloadButton(...)\n    tag$attribs$download <- NULL\n    tag\n}\n### End of workaround ####\n\nui_upload <- sidebarLayout(\n  sidebarPanel(\n    fileInput(\"file\", \"Data\", buttonLabel = \"Upload...\"),\n    textInput(\"delim\", \"Delimiter (leave blank to guess)\", \"\"),\n    numericInput(\"skip\", \"Rows to skip\", 0, min = 0),\n    numericInput(\"rows\", \"Rows to preview\", 10, min = 1)\n  ),\n  mainPanel(\n    h3(\"Raw data\"),\n    tableOutput(\"preview1\")\n  )\n)\n\nui_clean <- sidebarLayout(\n  sidebarPanel(\n    checkboxInput(\"snake\", \"Rename columns to snake case?\"),\n    checkboxInput(\"constant\", \"Remove constant columns?\"),\n    checkboxInput(\"empty\", \"Remove empty cols?\")\n  ),\n  mainPanel(\n    h3(\"Cleaner data\"),\n    tableOutput(\"preview2\")\n  )\n)\n\nui_download <- fluidRow(\n  column(width = 12, downloadButton(\"download\", class = \"btn-block\"))\n)\n\nui <- fluidPage(\n  ui_upload,\n  ui_clean,\n  ui_download\n)\n\nserver <- function(input, output, session) {\n  # Upload ---------------------------------------------------------\n  raw <- reactive({\n    req(input$file)\n    delim <- if (input$delim == \"\") NULL else input$delim\n    vroom::vroom(input$file$datapath, delim = delim, skip = input$skip)\n  })\n  output$preview1 <- renderTable(head(raw(), input$rows))\n\n  # Clean ----------------------------------------------------------\n  tidied <- reactive({\n    out <- raw()\n    if (input$snake) {\n      names(out) <- janitor::make_clean_names(names(out))\n    }\n    if (input$empty) {\n      out <- janitor::remove_empty(out, \"cols\")\n    }\n    if (input$constant) {\n      out <- janitor::remove_constant(out)\n    }\n\n    out\n  })\n  output$preview2 <- renderTable(head(tidied(), input$rows))\n\n  # Download -------------------------------------------------------\n  output$download <- downloadHandler(\n    filename = function() {\n      paste0(tools::file_path_sans_ext(input$file$name), \".tsv\")\n    },\n    content = function(file) {\n      vroom::vroom_write(tidied(), file)\n    }\n  )\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\n:::\n\n## Exercises\n\n### Multidimensional noise {#sec-09-ex-01}\n\n#### Task description\n\nUse the {**ambient**} package [@ambient] to generate [worley noise](https://ambient.data-imaginist.com/reference/noise_worley.html) and download a PNG of it.\n\n\n\n#### Solution\n\n::: {.callout-important #imp-09-conflict}\nThere is a conflict between the two versions. The first one (Shiny) does not work correctly at the beginning. One has to restart the app (clicking the right top arrow in the code window). The drop down menu changes it form and the reactive values work as intended. (The same problem occurs with the {**bslib**} version if it is the first one. There is no problem if there is only one version of the app.)\n:::\n\n\n::: {.column-screen-inset}\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-09-exercise-01}\n: Generate Worley noise and download a PNG of the resulting image\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Shiny UI version\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-exercise-01-shiny}\n: Generate noise with two variable parameters\n::::::\n:::\n::::{.my-r-code-container}\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 700\n#| components: [editor, viewer]\n\n## file: app.R\nlibrary(shiny)\nlibrary(ambient)\n\n# shinylive Workaround Start ######\ndownloadButton <- function(...) {\n    tag <- shiny::downloadButton(...)\n    tag$attribs$download <- NULL\n    tag\n}\n### End of workaround ####\n\nui <- fluidPage(\n    titlePanel(\"Generate Worley Noise\"),\n    sidebarLayout(\n        sidebarPanel(width = 4,\n             fluidRow(\n                 column(12, offset = 6,\n                        downloadButton(\"download\")\n                 )\n             ),\n            fluidRow(\n                column(12,\n                    numericInput(\"height\", \"Dimension-X\",\n                                value = 10),\n                   )\n            ),\n            fluidRow(\n                column(12,\n                   numericInput(\"width\", \"Dimension-Y\",\n                                value = 10),\n                )\n            ),\n            fluidRow(\n                column(12,\n                    selectInput(\"distance\", \"Select distance\",\n                                list(\"Euclidean\" = \"euclidean\",\n                                     \"Manhattan\" = \"manhattan\",\n                                     \"Natural\" = \"natural\"\n                                     )\n                                ),\n                       )\n            ),\n            fluidRow(\n                column(12,\n            selectInput(\"value\", \"Select noise value\",\n                        list(\"Distance\" = \"distance\",\n                             \"Distance2\" = \"distance2\",\n                             \"Distance2add\" = \"distance2add\",\n                             \"Distance2sub\" = \"distance2sub\",\n                             \"Distance2mul\" = \"distance2mul\",\n                             \"Distance2div\" = \"distance2div\",\n                             \"Cell\" = \"cell\"\n                            )\n                       )\n                )\n            ),\n            fluidRow(\n                column(12,\n            sliderInput(\"seed\", \"Seed for replication\",\n                        min = 1000,\n                        max = 1100,\n                        value = 1042\n                        )\n                    )\n            )\n        ),\n        mainPanel(width = 8,\n          plotOutput(\"plot\")\n        )\n    )\n)\n\nserver <- function(input, output) {\n\n    grid1 <-  reactive({\n        ambient::long_grid(seq(1, input$height, length.out = 1000),\n                  seq(1, input$width, length.out = 1000)\n                  )\n    })\n\n    grid2 <-  reactive({\n        grid1() |>\n            dplyr::mutate(noise = ambient::gen_worley(\n                grid1()$x, grid1()$y,\n                value = input$value,\n                distance = input$distance,\n                seed = input$seed)\n            )\n    })\n\n    output$plot <- renderPlot({\n        req(grid2())\n        plot(grid2(), noise)\n    })\n\n\n    output$download <- downloadHandler(\n        filename  = reactive({paste0(\n            \"worley_x-\", input$height,\n            \"_y-\", input$width,\n            \"_distance-\", input$distance,\n            \"_noise-\", input$value,\n            \"_seed-\", input$seed, \".png\"\n            )\n        }),\n        content = function(file) {\n            png(file)\n            plot(grid2(), noise)\n            dev.off()\n        }\n    )\n\n\n}\n\nshinyApp(ui, server)\n\n\n## file: R/shinylive.R\n#### R/shinylive.R\n\n# Workaround for Chromium Issue 468227 ######\n## see: https://shiny.posit.co/r/components/inputs/download-button/\n# Need this to properly download files\n# this bug and workaround is only for shinylive,\n# you do not need it in your regular app\ndownloadButton <- function(...) {\n    tag <- shiny::downloadButton(...)\n    tag$attribs$download <- NULL\n    tag\n}\n### End of workaround ####\n\n\n```\n\n\n::::\n:::::\n\n\n###### bslib UI version\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-exercise-01-bslib}\n: Generate noise with eight variable parameters\n::::::\n:::\n::::{.my-r-code-container}\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 700\n#| components: [editor, viewer]\n\n## file: app.R\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ambient)\n\nui <- page_sidebar(\n    titlePanel(\"Generate Worley Noise\"),\n    sidebar = sidebar(\n        downloadButton(\"download\"),\n        numericInput(\"height\", \"Dimension-X\", value = 10),\n        numericInput(\"width\", \"Dimension-Y\", value = 10),\n        selectInput(\"distance\", \"Select distance\",\n                list(\"Euclidean\" = \"euclidean\",\n                     \"Manhattan\" = \"manhattan\",\n                     \"Natural\" = \"natural\"\n                    )\n                ),\n\n        selectInput(\"value\", \"Select noise value\",\n                list(\"Distance\" = \"distance\",\n                     \"Distance2\" = \"distance2\",\n                     \"Distance2add\" = \"distance2add\",\n                     \"Distance2sub\" = \"distance2sub\",\n                     \"Distance2mul\" = \"distance2mul\",\n                     \"Distance2div\" = \"distance2div\",\n                     \"Cell\" = \"cell\"\n                    )\n                ),\n        sliderInput(\"seed\", \"Seed for replication\",\n                        min = 1000,\n                        max = 1100,\n                        value = 1042\n                    )\n        ),\n        plotOutput(\"plot\")\n)\n\nserver <- function(input, output) {\n\n    grid1 <-  reactive({\n        long_grid(seq(1, input$height, length.out = 1000),\n                  seq(1, input$width, length.out = 1000)\n        )\n    })\n\n    grid2 <-  reactive({\n        grid1() |>\n            dplyr::mutate(noise = gen_worley(\n                grid1()$x, grid1()$y,\n                value = input$value,\n                distance = input$distance,\n                seed = input$seed)\n            )\n    })\n\n    output$plot <- renderPlot({\n        plot(grid2(), noise)\n    })\n\n\n    output$download <- downloadHandler(\n        filename  = reactive({paste0(\n            \"worley_x-\", input$height,\n            \"_y-\", input$width,\n            \"_distance-\", input$distance,\n            \"_noise-\", input$value,\n            \"_seed-\", input$seed, \".png\"\n        )\n        }),\n        content = function(file) {\n            png(file)\n            plot(grid2(), noise)\n            dev.off()\n        }\n    )\n\n\n}\n\nshinyApp(ui, server)\n\n\n## file: R/shinylive.R\n#### R/shinylive.R\n\n# Workaround for Chromium Issue 468227 ######\n## see: https://shiny.posit.co/r/components/inputs/download-button/\n# Need this to properly download files\n# this bug and workaround is only for shinylive,\n# you do not need it in your regular app\ndownloadButton <- function(...) {\n    tag <- shiny::downloadButton(...)\n    tag$attribs$download <- NULL\n    tag\n}\n### End of workaround ####\n\n\n```\n\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n:::\n\n::: {.callout-note #nte-09-bslib-version}\n\nI was surprised how easy the sidebar layout was created with {**bslib**}. The only issue I discovered so far: The default layout is much bigger and therefore not so convenient as in the {**shiny**} layout version. But I assume that there are option to change the overall appearance easily.\n\nSee [Dashboards](https://rstudio.github.io/bslib/articles/dashboards/index.html), an article that shows using {**bslib**} to create the user interface (UI) for Shiny dashboards.\n\n:::\n\n\n\nIn this exercise I had to overcome several difficulties:\n\n1. **Exercise interpretation**: First of all I had to interpret the challenge. I don't now anything about multidimensional noise generator. So I had to use the two provided examples to play around. Soon I learned that there are several parameters that change the resulting noise picture. I concluded that it would be nice to have an environment where you could experiment with the different parameters. This would be a really advantage of a Shiny app in contrast to pages with fixed parameters. <br/><br />\nI learned that [Solution to Mastering Shiny](https://mastering-shiny-solutions.netlify.app/) and [Mastering Shiny Solution](https://mastering-shiny-solutions.org/) did not capture this idea. The first one skipped this exercise, the second one provided a solution without Shiny.\n\n2. **content(file) function**: My biggest problem was to download the <a class='glossary' title='Portable Network Graphic (PNG) is a non-patented raster graphics file format that supports lossless data compression. The format was not designed for professional-quality print graphics but for transferring images on the Internet (hence the name ‘portable’). (Wikipedia)'>PNG</a>. I didn't understand that the argument `file` for the function `content()` is only the way of Shiny to save the file internally. So the app author must not assign a value to `file`.\n\n3. **PNG function**: I never used so far the `png()` function with the `dev.off()` command at the end of the transaction.\n\nNot knowing about `png()` with my `content(file)` misunderstanding it took me several hours to find the solution.\n\n:::::{.my-resource}\n:::{.my-resource-header}\n:::::: {#lem-09-png-function}\n: PNG and other graphic devices\n::::::\n:::\n::::{.my-resource-container}\n - [BMP, JPEG, PNG and TIFF graphics devices](https://stat.ethz.ch/R-manual/R-devel/library/grDevices/html/png.html)\n - [Saving plots to a file with pdf(), jpeg() and png()](https://bookdown.org/ndphillips/YaRrr/saving-plots-to-a-file-with-pdf-jpeg-and-png.html).\n\n::::\n:::::\n\n\n### Upload CSV & t-test\n\n#### Task description\n\nCreate an app that lets you upload a <a class='glossary' title='Text files where the values are separated with commas (Comma Separated Values = CSV). These files have the file extension .csv'>CSV</a> file, select a variable, and then perform a `t.test()` on that variable. After the user has uploaded the csv file, you’ll need to use `updateSelectInput()` to fill in the available variables. See @XXX_10.1 for details.\n\n::: {.callout-note #nte-upload-file-and-t-test}\nI have extended the task with three more options:\n\n- Not only CSV but also <a class='glossary' title='A TSV file, or Tab-Separated Values file, is a simple text format used for storing data in a structured manner. Each line of the file represents a data record, while each field within the record is separated by a tab character. TSV file format is often preferred over CSV files when data includes commas, as often is the case in European datasets.'>TSV</a> files are allowed.\n- Because `t.test()` requires numeric data, load only columns with numeric data into `updateSelectInput()`.\n- Add input for the hypothesized mean, otherwise the one same t test will always use `0`.\n:::\n\n:::::{.my-resource}\n:::{.my-resource-header}\n:::::: {#lem-09-t-test}\n: How to calculate and report a t test?\n::::::\n:::\n::::{.my-resource-container}\n\n- [One-Sample T-test in R](https://www.sthda.com/english/wiki/one-sample-t-test-in-r)\n- [How to Do a T-test in R: Calculation and Reporting](https://www.datanovia.com/en/lessons/how-to-do-a-t-test-in-r-calculation-and-reporting/)\n- [Complete Guide: How to Interpret t-test Results in R](https://www.statology.org/interpret-t-test-results-in-r/)\n- [T-Tests](https://bookdown.org/pbaumgartner/swr-harris/06-t-test.html) from Notes on Statistics with R [@harris2020]\n\n::::\n:::::\n\n#### Solution\n\n\n\n::: {.column-screen-inset}\n\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-09-exercise-02}\n: Upload file, select a variable and perform a t test\n::::::\n:::\n::::{.my-exercise-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 550\n#| components: [editor, viewer]\n\n## file: app.R\nlibrary(shiny)\nlibrary(bslib)\n\nui <- page_sidebar(\n    titlePanel(\"One Sample t Test\"),\n    sidebar = sidebar(\n        fileInput(\"upload\", NULL, accept = c(\".csv\", \".tsv\")),\n        selectInput(\"my_var\", \"Choose variable\", NULL),\n        numericInput(\"num\", \"Hypothesized mean\", 0),\n        actionButton(\"go\", \"T Test\", disabled = TRUE)\n    ),\n    verbatimTextOutput(\"ttest\")\n)\n\nserver <- function(input, output, session) {\n    data <- reactive({\n        req(input$upload)\n\n        ext <- tools::file_ext(input$upload$name)\n        switch(ext,\n               csv = vroom::vroom(\n                   input$upload$datapath,\n                   delim = \",\",\n                   show_col_types = FALSE),\n               tsv = vroom::vroom(\n                   input$upload$datapath,\n                   delim = \"\\t\",\n                   show_col_types = FALSE),\n               validate(\"Invalid file;\n                        Please upload a .csv or .tsv file\")\n        )\n    })\n\n    observe({\n        req(data())\n        df <- data() |>\n            dplyr::select(tidyselect::where(is.numeric))\n        updateSelectInput(\n            inputId = \"my_var\",\n              choices = names(df)\n            )\n        updateActionButton(session, \"go\", disabled = FALSE)\n    })\n\n\n    output$ttest <-  renderPrint({\n        req(input$my_var)\n        input$go\n        value <-  dplyr::select(data(), input$my_var)\n        isolate(t.test(value, mu = input$num))\n    })\n\n}\n\nshinyApp(ui, server)\n\n\n\n```\n\n::::\n:::::\n\n:::\n\n### Download histogram\n\n#### Task description\n\n\nCreate an app that lets the user upload a csv file, select one variable, draw a histogram, and then download the histogram. For an additional challenge, allow the user to select from `.png`, `.pdf`, and `.svg` output formats.\n\nI have developed several version of this exercise provided in different tabs:\n\n(1) **base R plot**: This is the minimum solution using base R plot. It took my a long time to learn and understand how to reference a specific column for the plot. The `$` does not work, you have to use `[[` like `data()[[input$my_column]]`. See [SO: Shiny R Histogram](https://stackoverflow.com/a/52612138/7322615). <br/><br/>\nI used to replicate the code for plotting the histogram in `renderPlot()` and `downloadHandler()`.  By creating a reactive for the plot code I could prevent duplication. See: [SO: How to avoid code duplication in a render() function in Shiny for R](https://stackoverflow.com/questions/35246256/how-to-avoid-code-duplication-in-a-render-function-in-shiny-for-r).\n\n(2) **ggplot**: This is the minimal solution with {**ggplot2**}. The reference to a column with {**ggplot2**} is even more complicated with `.data[[input$my_column]]`. The `.data` part is the tidy eval pronoun. See: [SO: What is the difference between `.` and `.data`](https://stackoverflow.com/questions/63399011/what-is-the-difference-between-and-data). <br/><br/>\n  Tidy evaluation is a concept used in the tidyverse, particularly in packages like dplyr and ggplot2, to handle the evaluation of expressions in a way that allows for more flexible and powerful programming. It is especially useful when you want to build functions that can take column names as arguments and use them within dplyr verbs.<br/><br/> \n  It is a very complex topic and I will not open this Pandora box here, but these two references might provide a good start: [Programming with {dplyr}](https://dplyr.tidyverse.org/articles/programming.html) and [Evaluate an expression with quosures and pronoun support](https://rlang.r-lib.org/reference/eval_tidy.html) from the {**rlang**} package. (The {**rlang**} package is in this context important as it collects functions for the core {**tidyverse**} features like tidy evaluation.)\n  \n(3) **Hist button**: In the previous versions the histogram graphics appeared automatically with the first column in the `selectInput()` menu. In this version I have added a button to start drawing the histogram explicitly.\n\n(4) **shinyjs**: In all the previous trials was the `downloadButton()` active, even if there was nothing to download. I learned that I could prevent this easily with {**shinyjs**}. See [SO: shiny app: disable downloadbutton](https://stackoverflow.com/a/31719056/7322615)\n\n(5) **dynamic-UI**: With a dynamic UI there is another solution to present an active `downloadButton()`. The user only get the button when there is something to download. (It seems to me that this will be covered in the next book chapter on [Dynamic UI](https://mastering-shiny.org/action-dynamic.html). See @XXX_10.) But here I have used [SO: Display download button in Shiny R only when output appears in Main Panel](https://stackoverflow.com/a/51041905/7322615)<br/><br/> \nI do not know what is the better UI alternative. To have an inactive button that changes or appearing a complete new UI element during the processing.\n\n(6) **radioButtons**: In this exercise the user can decide if (s)he wants the graphic as base R plot or with {**ggplot2**}. <br/><br/>\nI personally prefer the `ggplot()` version for two reasons: (**ggplot2**) is the modern plotting variant and has in the meanwhile a huge ecosystem on supporting packages and I am more experienced with {**ggplot2**} than with base R graphic.\n\n::: {.callout-important #imp-09-plot-dimension}\n###### Provide plot dimensions and set resolution to 96\n\n\nThe first time I selected a tab of @exr-09-exercise-03 I got briefly `error: figure margin too large`. The problem is that the reserved plotting error is in the beginning too small. To prevent this error message I had to change `plotOutput(\"hist\")` to `plotOutput(\"hist\", width = '600px', height = '400px')`.\n\nBy this occasion I also changed the resolution in `renderPlot()` from the standard 72 to the better resolution of 96. For instance: `renderPlot(my_hist(), res = 96)`. If there is a function with several lines (and not one liner function `my_hist()` as in the just mentioned example), then you have to include the `res = 96` addition between the ending `})` like `}, res = 96)`.\n:::\n\n#### Solution\n\n\n::: {.column-screen-inset}\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-09-exercise-03}\n: Upload file, draw histogram and download in different formats\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Base R plot\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-exercise-03-01-base-r-plot}\n: Minimal version with base R plot\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 680\n#| components: [editor, viewer]\n\n## file: app.R\nlibrary(shiny)\nlibrary(bslib)\n\nui <- page_sidebar(\n    titlePanel(\"Draw & download a histogram\"),\n    sidebar = sidebar(\n        fileInput(\"upload\", NULL, accept = c(\".csv\", \".tsv\")),\n        selectInput(\"my_column\", \"Choose variable\", NULL),\n        selectInput(\"format\", \"Download as\",\n                    c(\"PNG\" = \".png\",\n                      \"PDF\" = \".pdf\",\n                      \"SVG\" = \".svg\")\n                    ),\n        downloadButton(\"my_download\", \"Download\")\n    ),\n    plotOutput(\"hist\", width = '600px', height = '400px')\n)\n\nserver <- function(input, output, session) {\n\n    data <- reactive({\n        req(input$upload)\n\n        ext <- tools::file_ext(input$upload$name)\n        switch(ext,\n               csv = vroom::vroom(\n                   input$upload$datapath,\n                   delim = \",\",\n                   show_col_types = FALSE),\n               tsv = vroom::vroom(\n                   input$upload$datapath,\n                   delim = \"\\t\",\n                   show_col_types = FALSE),\n               validate(\"Invalid file;\n                        Please upload a .csv or .tsv file\")\n        )\n    })\n\n    observe({\n        req(data())\n        df <- data() |> dplyr::select(tidyselect::where(is.numeric))\n        updateSelectInput(inputId = \"my_column\", choices = names(df))\n    })\n\n    my_hist <- reactive({\n        req(input$my_column)\n        hist(data()[[input$my_column]])\n        }\n    )\n\n    output$hist <-  renderPlot(my_hist(), res = 96)\n\n    output$my_download <- downloadHandler(\n        filename  = reactive({paste0(\n            \"histogram-\",\n            basename(tools::file_path_sans_ext(input$upload)),\n            \"-\", input$my_column, \"-\", Sys.Date(), input$format)}),\n        content = function(file) {\n            switch(input$format,\n                \".png\" = png(file),\n                \".pdf\" = pdf(file),\n                \".svg\" = svg(file)\n            )\n            plot(my_hist())\n            dev.off()\n        }\n    )\n}\n\nshinyApp(ui, server)\n\n\n\n\n## file: R/shinylive.R\n#### R/shinylive.R\n\n# Workaround for Chromium Issue 468227 ######\n## see: https://shiny.posit.co/r/components/inputs/download-button/\n# Need this to properly download files\n# this bug and workaround is only for shinylive,\n# you do not need it in your regular app\ndownloadButton <- function(...) {\n    tag <- shiny::downloadButton(...)\n    tag$attribs$download <- NULL\n    tag\n}\n### End of workaround ####\n\n```\n\n\n::::\n:::::\n\n\n###### ggplot\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-exercise-03-02-ggplot}\n: Minimal version with {**ggplot2**}\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 680\n#| components: [editor, viewer]\n\n## file: app.R\nlibrary(shiny)\nlibrary(bslib)\n\nui <- page_sidebar(\n    titlePanel(\"Draw & download a histogram\"),\n    sidebar = sidebar(\n        fileInput(\"upload\", NULL, accept = c(\".csv\", \".tsv\")),\n        selectInput(\"my_column\", \"Choose variable\", NULL),\n        selectInput(\"format\", \"Download as\",\n                    c(\"PNG\" = \".png\",\n                      \"PDF\" = \".pdf\",\n                      \"SVG\" = \".svg\")\n                    ),\n        downloadButton(\"my_download\", \"Download\")\n    ),\n    plotOutput(\"hist\", width = '600px', height = '400px')\n)\n\nserver <- function(input, output, session) {\n\n    data <- reactive({\n        req(input$upload)\n\n        ext <- tools::file_ext(input$upload$name)\n        switch(ext,\n               csv = vroom::vroom(\n                   input$upload$datapath,\n                   delim = \",\",\n                   show_col_types = FALSE),\n               tsv = vroom::vroom(\n                   input$upload$datapath,\n                   delim = \"\\t\",\n                   show_col_types = FALSE),\n               validate(\"Invalid file;\n                        Please upload a .csv or .tsv file\")\n        )\n    })\n\n    observe({\n        req(data())\n        df <- data() |> dplyr::select(tidyselect::where(is.numeric))\n        updateSelectInput(inputId = \"my_column\", choices = names(df))\n    })\n\n    my_hist <- reactive({\n        req(input$my_column)\n        data() |>\n            ggplot2::ggplot(ggplot2::aes(.data[[input$my_column]])) +\n            ggplot2::geom_histogram(bins = 30)\n        }\n    )\n\n    output$hist <-  renderPlot(my_hist(), res = 96)\n\n    output$my_download <- downloadHandler(\n        filename  = reactive({paste0(\n            \"histogram-\",\n            basename(tools::file_path_sans_ext(input$upload)),\n            \"-\", input$my_column, \"-\", Sys.Date(), input$format)}),\n        content = function(file) {ggplot2::ggsave(file, plot = my_hist())}\n    )\n}\n\nshinyApp(ui, server)\n\n\n\n\n## file: R/shinylive.R\n#### R/shinylive.R\n\n# Workaround for Chromium Issue 468227 ######\n## see: https://shiny.posit.co/r/components/inputs/download-button/\n# Need this to properly download files\n# this bug and workaround is only for shinylive,\n# you do not need it in your regular app\ndownloadButton <- function(...) {\n    tag <- shiny::downloadButton(...)\n    tag$attribs$download <- NULL\n    tag\n}\n### End of workaround ####\n\n```\n\n::::\n:::::\n\n###### Hist button\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-exercise-03-03-hist-button}\n: Using button to start drawing the histogram\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 680\n#| components: [editor, viewer]\n\n## file: app.R\nlibrary(shiny)\nlibrary(bslib)\n\nui <- page_sidebar(\n\n    titlePanel(\"Draw & download a histogram\"),\n    sidebar = sidebar(\n        fileInput(\"upload\", NULL, accept = c(\".csv\", \".tsv\")),\n        selectInput(\"my_variable\", \"Choose variable\", NULL),\n        actionButton(\"draw\", \"Draw Histogram\", disabled = TRUE),\n        selectInput(\"format\", \"Download as\",\n                    c(\"PNG\" = \".png\",\n                      \"PDF\" = \".pdf\",\n                      \"SVG\" = \".svg\")\n                    ),\n        downloadButton(\"download\")\n    ),\n    plotOutput(\"hist\", width = '600px', height = '400px')\n)\n\nserver <- function(input, output, session) {\n\n    data <- reactive({\n        req(input$upload)\n\n        ext <- tools::file_ext(input$upload$name)\n        switch(ext,\n               csv = vroom::vroom(\n                   input$upload$datapath,\n                   delim = \",\",\n                   show_col_types = FALSE),\n               tsv = vroom::vroom(\n                   input$upload$datapath,\n                   delim = \"\\t\",\n                   show_col_types = FALSE),\n               validate(\"Invalid file;\n                        Please upload a .csv or .tsv file\")\n        )\n    })\n\n    observe({\n        req(data())\n        df <- data() |>\n            dplyr::select(tidyselect::where(is.numeric))\n        updateSelectInput(\n            inputId = \"my_variable\",\n            choices = names(df)\n        )\n        updateActionButton(session, \"draw\", disabled = FALSE)\n\n    })\n\n\n    output$hist <-  renderPlot({\n        input$draw\n\n\n        ## version base::hist\n        ## to get the column you need `[[`: `$` does not work\n        # my_hist <- hist(data()[[isolate(req(input$my_variable))]])\n        # my_hist\n\n\n        # version tidy eval tools (dplyr, ggplot and rlang)\n        # .data retrieves data-variables for the data frame\n        my_hist <-\n            data() |>\n                ggplot2::ggplot(ggplot2::aes(.data[[isolate(req(input$my_variable))]])) +\n                ggplot2::geom_histogram(bins = 30)\n        my_hist\n    }, res = 96)\n\n    output$download <- downloadHandler(\n        filename = function() {\n            paste0(\"histogram\", input$format)\n        },\n        content = function(file) {\n            my_hist <- data() |>\n                ggplot2::ggplot(ggplot2::aes(.data[[isolate(req(input$my_variable))]])) +\n                ggplot2::geom_histogram(bins = 30)\n            ggplot2::ggsave(file, plot = my_hist)\n            # hist(data()[[input$my_variable]])\n        }\n    )\n\n\n\n}\n\nshinyApp(ui, server)\n\n\n\n\n## file: R/shinylive.R\n#### R/shinylive.R\n\n# Workaround for Chromium Issue 468227 ######\n## see: https://shiny.posit.co/r/components/inputs/download-button/\n# Need this to properly download files\n# this bug and workaround is only for shinylive,\n# you do not need it in your regular app\ndownloadButton <- function(...) {\n    tag <- shiny::downloadButton(...)\n    tag$attribs$download <- NULL\n    tag\n}\n### End of workaround ####\n\n```\n\n\n::::\n:::::\n\n\n\n###### shinyjs\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-exercise-03-04-shiny}\n: Enable download button with {**shinyjs**}\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 680\n#| components: [editor, viewer]\n\n## file: app.R\nlibrary(shiny)\nlibrary(bslib)\n\nui <- page_sidebar(\n    # need to make a call to useShinyjs() in order to use its functions in server\n    shinyjs::useShinyjs(),\n    titlePanel(\"Draw & download a histogram\"),\n    sidebar = sidebar(\n        fileInput(\"upload\", NULL, accept = c(\".csv\", \".tsv\")),\n        selectInput(\"my_column\", \"Choose variable\", NULL),\n        selectInput(\"format\", \"Download as\",\n                    c(\"PNG\" = \".png\",\n                      \"PDF\" = \".pdf\",\n                      \"SVG\" = \".svg\")\n                    ),\n        downloadButton(\"my_download\", \"Download\")\n    ),\n    plotOutput(\"hist\", width = '600px', height = '400px')\n)\n\nserver <- function(input, output, session) {\n\n\n    data <- reactive({\n        req(input$upload)\n\n        ext <- tools::file_ext(input$upload$name)\n        switch(ext,\n               csv = vroom::vroom(\n                   input$upload$datapath,\n                   delim = \",\",\n                   show_col_types = FALSE),\n               tsv = vroom::vroom(\n                   input$upload$datapath,\n                   delim = \"\\t\",\n                   show_col_types = FALSE),\n               validate(\"Invalid file;\n                        Please upload a .csv or .tsv file\")\n        )\n    })\n\n    observe({\n        req(data())\n        df <- data() |> dplyr::select(tidyselect::where(is.numeric))\n        updateSelectInput(inputId = \"my_column\", choices = names(df))\n\n        # enable the download button\n        shinyjs::enable(\"my_download\")\n\n    })\n\n    my_hist <- reactive({\n        req(input$my_column)\n        data() |>\n            ggplot2::ggplot(ggplot2::aes(.data[[input$my_column]])) +\n            ggplot2::geom_histogram(bins = 30)\n        }\n    )\n\n    output$hist <-  renderPlot(my_hist(), res = 96)\n\n\n    output$download <- downloadHandler(\n        filename  = reactive({paste0(\n            \"histogram-\",\n            basename(tools::file_path_sans_ext(input$upload)),\n            \"-\", input$my_column, \"-\", Sys.Date(), input$format)}),\n        content = function(file) {ggplot2::ggsave(file, plot = my_hist())}\n    )\n\n    # disable the downloaded button on page load\n    shinyjs::disable(\"my_download\")\n\n}\n\nshinyApp(ui, server)\n\n\n\n\n## file: R/shinylive.R\n#### R/shinylive.R\n\n# Workaround for Chromium Issue 468227 ######\n## see: https://shiny.posit.co/r/components/inputs/download-button/\n# Need this to properly download files\n# this bug and workaround is only for shinylive,\n# you do not need it in your regular app\ndownloadButton <- function(...) {\n    tag <- shiny::downloadButton(...)\n    tag$attribs$download <- NULL\n    tag\n}\n### End of workaround ####\n\n```\n\n\n::::\n:::::\n\n###### Dynamic UI\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-exercise-03-05-dynamic-ui}\n: Dynamic UI: Display download button only when there is something to download\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 680\n#| components: [editor, viewer]\n\n## file: app.R\nlibrary(shiny)\nlibrary(bslib)\n\nui <- page_sidebar(\n    titlePanel(\"Draw & download a histogram\"),\n    sidebar = sidebar(\n        fileInput(\"upload\", NULL, accept = c(\".csv\", \".tsv\")),\n        selectInput(\"my_column\", \"Choose variable\", NULL),\n        selectInput(\"format\", \"Download as\",\n                    c(\"PNG\" = \".png\",\n                      \"PDF\" = \".pdf\",\n                      \"SVG\" = \".svg\")\n                    ),\n        uiOutput(\"get_the_item\")\n    ),\n    plotOutput(\"hist\", width = '600px', height = '400px')\n)\n\nserver <- function(input, output, session) {\n    data <- reactive({\n        req(input$upload)\n\n        ext <- tools::file_ext(input$upload$name)\n        switch(ext,\n               csv = vroom::vroom(\n                   input$upload$datapath,\n                   delim = \",\",\n                   show_col_types = FALSE),\n               tsv = vroom::vroom(\n                   input$upload$datapath,\n                   delim = \"\\t\",\n                   show_col_types = FALSE),\n               validate(\"Invalid file;\n                        Please upload a .csv or .tsv file\")\n        )\n    })\n\n    observe({\n        req(data())\n        df <- data() |> dplyr::select(tidyselect::where(is.numeric))\n        updateSelectInput(inputId = \"my_column\", choices = names(df))\n    })\n\n    my_hist <- reactive({\n        req(input$my_column)\n        data() |>\n            ggplot2::ggplot(ggplot2::aes(.data[[input$my_column]])) +\n            ggplot2::geom_histogram(bins = 30)\n        }\n    )\n\n    output$hist <-  renderPlot(my_hist(), res = 96)\n\n    output$get_the_item <- renderUI({\n        req(input$my_column)\n            downloadButton('my_download', 'Download')\n    })\n\n    output$my_download <- downloadHandler(\n        filename  = reactive({paste0(\n            \"histogram-\",\n            basename(tools::file_path_sans_ext(input$upload)),\n            \"-\", input$my_column, \"-\", Sys.Date(), input$format)}),\n        content = function(file) {ggplot2::ggsave(file, plot = my_hist())}\n    )\n\n}\n\nshinyApp(ui, server)\n\n\n\n\n## file: R/shinylive.R\n#### R/shinylive.R\n\n# Workaround for Chromium Issue 468227 ######\n## see: https://shiny.posit.co/r/components/inputs/download-button/\n# Need this to properly download files\n# this bug and workaround is only for shinylive,\n# you do not need it in your regular app\ndownloadButton <- function(...) {\n    tag <- shiny::downloadButton(...)\n    tag$attribs$download <- NULL\n    tag\n}\n### End of workaround ####\n\n```\n\n\n::::\n:::::\n\n###### Radiobuttons\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-exercise-03-06-radiobuttons}\n: Radio buttons to choose whether base R or ggplot graphic\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 680\n#| components: [editor, viewer]\n\n## file: app.R\nlibrary(shiny)\nlibrary(bslib)\n\nui <- page_sidebar(\n    titlePanel(\"Draw & download a histogram\"),\n    sidebar = sidebar(\n        fileInput(\"upload\", NULL, accept = c(\".csv\", \".tsv\")),\n        selectInput(\"my_column\", \"Choose variable\", NULL),\n        radioButtons(\"my_plot\", label = NULL, choices =\n                      c(\"ggplot2\" = \"ggplot2\",\n                     \"Base\" = \"base\"),\n                     inline = TRUE),\n        selectInput(\"format\", \"Download as\",\n                    c(\"PNG\" = \".png\",\n                      \"PDF\" = \".pdf\",\n                      \"SVG\" = \".svg\")\n                    ),\n        downloadButton(\"my_download\", \"Download\")\n    ),\n    plotOutput(\"hist\", width = '600px', height = '400px')\n)\n\nserver <- function(input, output, session) {\n\n    data <- reactive({\n        req(input$upload)\n\n        ext <- tools::file_ext(input$upload$name)\n        switch(ext,\n               csv = vroom::vroom(\n                   input$upload$datapath,\n                   delim = \",\",\n                   show_col_types = FALSE),\n               tsv = vroom::vroom(\n                   input$upload$datapath,\n                   delim = \"\\t\",\n                   show_col_types = FALSE),\n               validate(\"Invalid file;\n                        Please upload a .csv or .tsv file\")\n        )\n    })\n\n    observe({\n        req(data())\n        df <- data() |> dplyr::select(tidyselect::where(is.numeric))\n        updateSelectInput(inputId = \"my_column\", choices = names(df))\n    })\n\n    my_hist <- reactive({\n        req(input$my_column)\n        hist(data()[[input$my_column]])\n        }\n    )\n\n    my_ggplot <-  reactive({\n        req(input$my_column)\n        data() |>\n            ggplot2::ggplot(ggplot2::aes(.data[[input$my_column]])) +\n            ggplot2::geom_histogram(bins = 30)\n    })\n\n    output$hist <-  renderPlot({\n        hist_plot  <- switch(input$my_plot,\n                          ggplot2 = my_ggplot(),\n                          base = plot(my_hist())\n                          )\n       hist_plot\n    }, res = 96)\n\n    output$my_download <- downloadHandler(\n        filename  = reactive({paste0(\n            \"histogram-\",\n            basename(tools::file_path_sans_ext(input$upload)),\n            \"-\", input$my_column, \"-\", Sys.Date(), input$format)}),\n        content = function(file) {\n            switch(input$my_plot,\n                       ggplot2 = {ggplot2::ggsave(file, plot = hist_plot())},\n                       base =  {switch(input$format,\n                                      \".png\" = png(file),\n                                      \".pdf\" = pdf(file),\n                                      \".svg\" = svg(file)\n                                    )\n                                hist_plot()\n                                dev.off()\n                                }\n            )\n        }\n    )\n}\n\nshinyApp(ui, server)\n\n\n\n\n## file: R/shinylive.R\n#### R/shinylive.R\n\n# Workaround for Chromium Issue 468227 ######\n## see: https://shiny.posit.co/r/components/inputs/download-button/\n# Need this to properly download files\n# this bug and workaround is only for shinylive,\n# you do not need it in your regular app\ndownloadButton <- function(...) {\n    tag <- shiny::downloadButton(...)\n    tag$attribs$download <- NULL\n    tag\n}\n### End of workaround ####\n\n```\n\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n:::\n\n:::::{.my-resource}\n:::{.my-resource-header}\n:::::: {#lem-09-exercise-03}\n: Used resources to solve exercise 3: Download plot with shiny\n::::::\n:::\n::::{.my-resource-container}\n- [Shiny download with `ggplot2()`](https://forum.posit.co/t/shiny-download-ggplot/90532/2): Posit forum.\n- [How to avoid code duplication in a render() function in Shiny for R](https://stackoverflow.com/a/35246347/7322615): StackOverflow.\n- [What is the difference between `.` and `.data`](https://stackoverflow.com/a/63407353/7322615): StackOverflow\n- [Programming with {dplyr}](https://dplyr.tidyverse.org/articles/programming.html): Vignette 'programming' from the {**dplyr**} package. \n- [Evaluate an expression with quosures and pronoun support](https://rlang.r-lib.org/reference/eval_tidy.html) and many more articles on the website for the {**rlang**} package.\n- [shiny app: disable downloadbutton](https://stackoverflow.com/a/31719056/7322615): StackOverflow.\n- [Display download button in Shiny R only when output appears in Main Panel](https://stackoverflow.com/a/51041905/7322615): StackOverflow.\n\nI also used two GitHub Gist articles, even if there were not decisive for my solution they provided general background to work with shiny plots:\n\n- [R Shiny Download ggplot() demo](https://gist.github.com/aagarw30/87c14725be815f9fd038).\n- [Shiny data upload and different plot options](https://gist.github.com/dgrapov/dfcf6ab2339b1cf19b090cfb8dadc855).\n\n::::\n:::::\n\n### LEGO bricks\n\n#### Task description\n\nWrite an app that allows the user to create a Lego mosaic from any `.png` file using [Ryan Timpe’s {**brickr**} package](https://brickr.org/index.html). Once you’ve completed the basics, add controls to allow the user to select the size of the mosaic (in bricks), and choose whether to use “universal” or “generic” color palettes.\n\n#### Solution\n\n::: {.callout-warning #wrn-09-ex-04-lego-bricks}\n##### Compiled {**brickr**} package for webR not available\n\nIt turned out, that I couldn't run my solution because the {**brickr**} was not available for `shinylive` (<a class='glossary' title='WebR is a version of the open-source R interpreter compiled for WebAssembly, along with a supporting TypeScript library for interacting with the console and R objects from a JavaScript environment. By compiling R to WebAssembly, a user can visit a website and run R code directly within the web browser, without R installed on their device or a supporting computational R server. All that is required is a normal web server, including the type of cloud hosting service provided by GitHub Pages or Netlify. WebR makes it possible to run R code in the browser without the need for an R server to execute the code: the R interpreter runs directly on the user’s machine. WebR maintains compatibility with standard R, meaning most R code will work the same way in both environments, though with some performance and availability limitations in the browser context.'>webR</a> / <a class='glossary' title='WebAssembly (also known as WASM) allows software that’s normally compiled for a specific computer system to instead run anywhere, including in web browsers. It is a binary instruction format for a stack-based virtual machine.'>WebAssembly</a>). I think the reason is that the current version of the package is neither on <a class='glossary' title='CRAN stands for the Comprehensive R Archive Network, which is R’s central software repository, supported by the R Foundation. It contains an archive of the latest and previous versions of the R distribution, documentation, and contributed R packages. (https://cran.r-project.org/)'>CRAN</a> anymore (it was until the [previous version 0.3.5](https://cran.r-project.org/src/contrib/Archive/brickr/)) nor is there a [GitHub release](https://github.com/ryantimpe/brickr/) available.\n\n\n::: {.cell type='rmddanger'}\n\\BeginKnitrBlock{rmddanger}<div class=\"rmddanger\">\nError in `get_github_wasm_assets()`:    \n! Can't find GitHub release for github::ryantimpe/brickr@HEAD   \n! Ensure a GitHub release exists for the package repository reference: \"HEAD\".       \nℹ Alternatively, install a CRAN version of this package to use the default Wasm      \n  binary repository.     \nCaused by error in `gh::gh()`:       \n! GitHub API error (404): Not Found         \n✖ URL not found:         \n  <https://api.github.com/repos/ryantimpe/brickr/releases/tags/HEAD>     \nℹ Read more at     \n  <https://docs.github.com/rest/releases/releases#get-a-release-by-tag-name>\n</div>\\EndKnitrBlock{rmddanger}\n:::\n\n:::\n\nI have therefore only the apps source code provided. To run the apps, copy it form the code chunks below or fork this repo and run the provided apps.\n\n:::::{.my-resource}\n:::{.my-resource-header}\n:::::: {#lem-compiling-packages-for-wasm}\n: Compiling packages for Webassembly and webR\n::::::\n:::\n::::{.my-resource-container}\n\nAbout providing / compiling R packages there is a daunting amount of literature available. I do not understand the connection of all of these resources and therefore is it extremely difficult for me to compile the {**bricksr**} package for WebAssembly myself.\n\nNonetheless I have collected links to the (presumed) most important resources to solve my problem:\n\n\n**rwasm**\n\n- {**rwasm**}: [Build R Packages for WebAssembly](https://r-wasm.github.io/rwasm/)\n- [Get started with WASM: Compiling R packages for WebAssembly](https://r-wasm.github.io/rwasm/articles/rwasm.html)\n- [Build one or more R packages for WebAssembly](https://r-wasm.github.io/rwasm/reference/build.html)\n- [R-universe now builds WASM binaries for all R packages](https://ropensci.org/blog/2023/11/17/runiverse-wasm/)\n- [Building R Packages for Webassembly (WASM)](https://docs.r-wasm.org/webr/latest/building.html)\n- [WebR - R in the Browser](https://github.com/r-wasm/webr/)\n- [The WebAssembly Binary Toolkit](https://github.com/WebAssembly/wabt)\n\n**V8**\n\n- {**V8**}: [Embedded JavaScript and WebAssembly Engine for R](https://jeroen.r-universe.dev/V8)\n- [What is V8?](https://v8.dev/)\n- [Introduction to V8 for R](https://jeroen.r-universe.dev/articles/V8/v8_intro.html)\n\n**webR** \n\n\n::: {.cell type='rmdattention'}\n\\BeginKnitrBlock{rmdattention}<div class=\"rmdattention\">There is a package {**webr**}. It is about \"Data and Functions for Web-Based Analysis\" and has therefore nothing to do with the open-source R interpreter webR compiled for WebAssembly,</div>\\EndKnitrBlock{rmdattention}\n:::\n\n\n- [WebR - R in the Browser](https://docs.r-wasm.org/webr/latest/)\n- [webR REPL app](https://webr.r-wasm.org/latest/). <a class='glossary' title='REPL stands for Read-Eval-Print Loop, which is a computer environment where user inputs are read, evaluated, and the results are printed back to the user. It allows for an interactive exploration of tools and programming languages, such as Pytho or R, where developers can communicate with the interpreter and see immediate results.'>REPL</a> stands for Read-Eval-Print Loop.\n- [Shiny Without a Server: webR & Shinylive](https://georgestagg.github.io/shiny-without-a-server-2023/): Slides\n\n**YouTube Videos by Geroge Stagg**\n  \n- [webR 0.2 Overview: R in the browse](brave://bookmarks/?id=7496)\n- [webR 0.2: R Packages and Shiny for WebAssembly](https://www.youtube.com/watch?v=CRKuH3ISPgI)\n- [Reproducible data science with webR and Shinylive](https://www.youtube.com/watch?v=wK3vPbcSoFE)\n- [webR 0.2: Updates to webRs developer API](https://www.youtube.com/watch?v=6b2EYmgObXc)\n\n\n::::\n:::::\n\n\n\n:::::{.my-procedure}\n:::{.my-procedure-header}\n:::::: {#prp-09-lego-bricks-exercise}\n: Exercise 4 of chapter 9: LEGO bricks\n::::::\n:::\n::::{.my-procedure-container}\n\n1. **Understanding {brickr}**: My first step to solve the exercise was to get an understanding what the {**brickr**} package does. I copied the demo code from the website [Emulate LEGO Bricks in 2D and 3D](https://brickr.org/index.html) and experimented with different pictures and parameters. Tab @lst-09-ex-04-understand-demo-code.\n2. **Implementing the basics**: My second step was to replicate the demo code with fixed values. See: @lst-ex-09-04-replicate-bricksr-demo-code-with-shiny.\n3. **Interactive functionality**: Third step was to take advantage of Shiny provide an interactive version. (See: @lst-09-ex-04-provide-bricksr-funktionality-with-shiny)\n4. **Improving the UI**: A last step was to disable/enable the `Process` button and to provide a spinning wheel provided by {**waiter**}. See @lst-09-ex-04-improving-shiny-ui-for-bricks-emulating.\n\nI've got several more ideas to improve the app. \n\n- Display original image and LEGO bricks image side by side.\n- Provide a download button.\n- Another more challenging option would be to suggest height and width of the LEGO output in relation to the uploaded image. This would require to detect the dimension of the original image and to find an optimal conversion rule for the number of LEGO bricks.\n- To output the numbers of LEGO bricks sorted by size and colors.\n- To generate a 3D picture.\n\n::::\n:::::\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-09-ex-04}\n: Build LEGO mosaics from any `.png` file using {**bricksr**} \n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Demo R code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-ex-04-understand-demo-code}\n: Play with the demo code to understand the core functionality of {**bricksr**}\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {#lst-09-ex-04-understand-demo-code}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(brickr)\n\ndemo_img = tempfile()\ndownload.file(\"http://ryantimpe.com/files/mf_unicorn.PNG\", demo_img, mode = \"wb\")\n\n(\n    mosaic1 <- png::readPNG(demo_img)  |>\n        image_to_mosaic(img_size = 36) |>\n        build_mosaic()\n)\n```\n\n::: {.cell-output-display}\n![](09-uploads-downloads_files/figure-html/ex-09-04-bricksr-01-demo-r-code-1.png){width=672}\n:::\n:::\n\n\nDemo code to understand the core functionality of {**bricksr**}\n\n:::\n::::\n:::::\n\n\n###### Replicate with Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-ex-09-04-replicate-code-with-shiny}\n: Replicate {**bricksr**} demo code with a Shiny app\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {#lst-ex-09-04-replicate-bricksr-demo-code-with-shiny}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(bslib)\nlibrary(base64enc)\nlibrary(brickr)\n\nui <- page_sidebar(\n    titlePanel(\"Emulate LEGO Bricks\"),\n    sidebar = sidebar(\n        fileInput(\"upload\", \"Load PNG image\", accept = c(\".png\"))\n        ),\n    uiOutput(\"image\"),\n    plotOutput(\"plot\", width = \"600px\", height = \"400px\")\n    )\n\nserver <- function(input, output, session) {\n    base64 <- reactive({\n        req(input$upload)\n        dataURI(file = input$upload$datapath, mime = \"image/png\")\n    })\n\n    output$plot <- renderPlot({\n        req(base64())\n        mosaic1 <- png::readPNG(input$upload$datapath) |>\n            image_to_mosaic(img_size = c(72, 48), color_palette = \"generic\") |>\n            build_mosaic()\n        mosaic1\n    }\n    )\n\n    output$image <- renderUI({\n        req(base64())\n        tags$div(\n            tags$img(src = base64(), width = \"100%\"),\n            style = \"width: 400px;\"\n        )\n\n    })\n}\n\n\nshinyApp(ui, server)\n```\n:::\n\n\n{**bricksr**} demo code replicated with Shiny\n:::\n::::\n:::::\n\n###### Interactivity\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-ex-04-bricksr-functionality}\n: Create interactive functionality to build mosaics with {**bricksr**}\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {#lst-09-ex-04-provide-bricksr-funktionality-with-shiny}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(bslib)\nlibrary(base64enc)\nlibrary(brickr)\n\nui <- page_sidebar(\n    titlePanel(\"Emulate LEGO Bricks\"),\n    sidebar = sidebar(\n        fileInput(\"upload\", \"Load PNG image\", accept = c(\".png\", \".PNG\")),\n        numericInput(\"width\", \"Width\", 36),\n        numericInput(\"height\", \"Height\", 36),\n        selectInput(\"pal\", \"Color Palette:\",\n                    c(\"Generic\" = \"generic\",\n                      \"Universal\" = \"universal\")),\n        actionButton(\"process\", \"Process\",\n                     icon = icon(\"cog\", lib = \"glyphicon\"),\n                     disabled = TRUE)\n        ),\n    uiOutput(\"image\"),\n    plotOutput(\"plot\", width = \"600px\", height = \"400px\")\n    )\n\nserver <- function(input, output, session) {\n    base64 <- reactive({\n        req(input$upload)\n        updateActionButton(\n            session, \"process\",\n            disabled = FALSE)\n        dataURI(file = input$upload$datapath, mime = \"image/png\")\n    })\n\n    output$plot <- renderPlot({\n        req(input$process > 0)\n        my_mosaic <-\n\n                png::readPNG(input$upload$datapath) |>\n                image_to_mosaic(img_size =\n                        c(isolate(input$width), isolate(input$height)),\n                        color_palette = isolate(input$pal)) |>\n                build_mosaic()\n        my_mosaic\n    })\n\n    output$image <- renderUI({\n        input$upload\n        tags$div(\n            tags$img(src = base64(), width = \"100%\"),\n            style = \"width: 400px;\"\n        )\n    })\n\n}\n\n\nshinyApp(ui, server)\n```\n:::\n\n\nProvided interactivity for emulating LEGO bricks with {**bricks**}\n\n:::\n::::\n:::::\n\n###### Improving UI\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-ex-04-improving-shiny-ui-for-bricks-emulating}\n: Improving User Interface of the LEGO bricks shiny app\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {#lst-09-ex-04-improving-shiny-ui-for-bricks-emulating}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(bslib)\nlibrary(base64enc)\nlibrary(brickr)\nlibrary(waiter)\n\n\nwaiting_screen <- tagList(\n    spin_flower(),\n    h4(\"Emulating picture with Lego bricks...\")\n)\n\nui <- page_sidebar(\n    useWaiter(),\n    titlePanel(\"Emulate LEGO Bricks\"),\n    sidebar = sidebar(\n        fileInput(\"upload\", \"Load PNG image\", accept = c(\".png\", \".PNG\")),\n        numericInput(\"width\", \"Width\", 36),\n        numericInput(\"height\", \"Height\", 36),\n        selectInput(\"pal\", \"Color Palette:\",\n                    c(\"Generic\" = \"generic\",\n                      \"Universal\" = \"universal\")),\n        actionButton(\"process\", \"Process\",\n                     icon = icon(\"cog\", lib = \"glyphicon\"),\n                     disabled = TRUE)\n        ),\n    uiOutput(\"image\"),\n    plotOutput(\"plot\", width = \"600px\", height = \"400px\")\n    )\n\nserver <- function(input, output, session) {\n    # create a waiter\n    w <- Waiter$new()\n\n    base64 <- reactive({\n        req(input$upload)\n        updateActionButton(\n            session, \"process\",\n            disabled = FALSE)\n        dataURI(file = input$upload$datapath, mime = \"image/png\")\n    })\n\n    output$plot <- renderPlot({\n        req(input$process > 0)\n        # w$show()\n        waiter_show(html = waiting_screen, color = \"black\")\n        my_mosaic <-\n\n                png::readPNG(input$upload$datapath) |>\n                image_to_mosaic(img_size =\n                        c(isolate(input$width), isolate(input$height)),\n                        color_palette = isolate(input$pal)) |>\n                build_mosaic()\n        # w$hide()\n        waiter_hide()\n        my_mosaic\n    })\n\n    output$image <- renderUI({\n        input$upload\n        tags$div(\n            tags$img(src = base64(), width = \"100%\"),\n            style = \"width: 400px;\"\n        )\n    })\n\n}\n\n\nshinyApp(ui, server)\n```\n:::\n\n\n\nImproving Shiny's UI for LEGO bricks emulating with {**bricksr**}\n:::\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\n\n### Reorganizing reactive(s)\n\n#### Task description\n\nThe app from the case study @sec-09-case-study contains a very large reactive. Break it up into multiple pieces so that (e.g.) `janitor::make_clean_names()` is not re-run when `input$empty` changes.\n\n````markdown\ntidied <- reactive({\n  out <- raw()\n  if (input$snake) {\n    names(out) <- janitor::make_clean_names(names(out))\n  }\n  if (input$empty) {\n    out <- janitor::remove_empty(out, \"cols\")\n  }\n  if (input$constant) {\n    out <- janitor::remove_constant(out)\n  }\n\n  out\n})\n\n````\n\n\n#### Solution\n\n\n::: {.column-page-inset}\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-09-ex-05-reorganize-reactives}\n: Code reorganizing of the final version of the case study in @sec-09-case-study\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 550\n#| components: [editor, viewer]\n\n## file: app.R\nlibrary(shiny)\n\n# shinylive Workaround Start ######\ndownloadButton <- function(...) {\n    tag <- shiny::downloadButton(...)\n    tag$attribs$download <- NULL\n    tag\n}\n### End of workaround ####\n\nui_upload <- sidebarLayout(\n    sidebarPanel(\n        fileInput(\"file\", \"Data\", buttonLabel = \"Upload...\", accept = c(\".csv\", \".tsv\")),\n        textInput(\"delim\", \"Delimiter (leave blank to guess)\", \"\"),\n        numericInput(\"skip\", \"Rows to skip\", 0, min = 0),\n        numericInput(\"rows\", \"Rows to preview\", 10, min = 1)\n    ),\n    mainPanel(\n        h3(\"Raw data\"),\n        tableOutput(\"preview1\")\n    )\n)\n\nui_clean <- sidebarLayout(\n    sidebarPanel(\n        checkboxInput(\"snake\", \"Rename columns to snake case?\"),\n        checkboxInput(\"constant\", \"Remove constant columns?\"),\n        checkboxInput(\"empty\", \"Remove empty cols?\")\n    ),\n    mainPanel(\n        h3(\"Cleaner data\"),\n        tableOutput(\"preview2\")\n    )\n)\n\nui_download <- fluidRow(\n    column(width = 12, downloadButton(\"download\", class = \"btn-block\"))\n)\n\nui <- fluidPage(\n    ui_upload,\n    ui_clean,\n    ui_download\n)\n\nserver <- function(input, output, session) {\n\n    # Upload ---------------------------------------------------------\n    raw <- eventReactive(input$file, {\n        delim <- if (input$delim == \"\") NULL else input$delim\n        vroom::vroom(input$file$datapath, delim = delim, skip = input$skip)\n    })\n\n    output$preview1 <- renderTable(head(raw(), input$rows))\n\n    # Clean ----------------------------------------------------------\n\n    remove_empty <- reactive({\n        out <- raw()\n        if (input$empty) {\n            out <- janitor::remove_empty(out, \"cols\")\n        }\n        out\n    })\n\n    snake_names <- reactive({\n        out <- remove_empty()\n        if (input$snake) {\n            names(out) <- janitor::make_clean_names(names(out))\n        }\n        out\n    })\n\n    remove_constant <- reactive({\n        out <- snake_names()\n        if (input$constant) {\n            out <- janitor::remove_constant(out)\n        }\n        out\n    })\n\n    output$preview2 <- renderTable(head(remove_constant(), input$rows))\n\n    # Download -------------------------------------------------------\n    output$download <- downloadHandler(\n        filename = function() {\n            paste0(tools::file_path_sans_ext(input$file$name), \".tsv\")\n        },\n        content = function(file) {\n            vroom::vroom_write(remove_constant(), file)\n        }\n    )\n}\n\nshinyApp(ui, server)\n\n```\n\n::::\n:::::\n\n:::\n\n::: {.callout-note #nte-09-reorganizing-reactive}\nAfter two days I gave up on this exercise and looked at the solution in [Mastering Shiny Solutions](https://mastering-shiny-solutions.netlify.app/uploads-and-downloads). \n\nI knew that the main change has to be happen in the cleaning function. Exactly the part of code that was repeated in the exercise formulation. But I did not know how to collect the results of of the three cleaning actions into on `tableRender()`. I tried it with `reactiveVal()` and managed the separate cleaning procedure but only for the first time. I didn't succeed to develop an app where the user could also take back the cleaning action through by resetting the selection.\n\nI learned two things from the solution:\n\n1. Each change of an input results is a call to each available reactive function. Thinking now about it, this seems obvious. In contrast to the `eventReactive()` handler that only is activated by a change of a specific input value a [reactive expression is called **always** when an input value has changed]{.mark}.\n\n2. But most important I did not know that \"if a reactive expression is marked as invalidated, any other reactive expressions that recently called it are also marked as invalidated. In this way, [invalidations ripple through the expressions that depend on each other]{.mark}\" (`reactive()``` help page).\n\nThis \"ripple through the expression\" is good visible as the result of every previous cleaning action is the start value of the `out` variable. Important is here the order of the different reactives. The raw data frame (`raw()`) must be included in the first reactive and is followed by one reactive after another applying or not applying each cleaning function. In this case is the order from top to bottom, because each reactive was invalidated by the previous one. this structure was a surprise for me, as I had a mental model of Shiny where code sequences **never** matters.\n\n:::\n",
    "supporting": [
      "09-uploads-downloads_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}