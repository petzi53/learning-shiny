{
  "hash": "90bd89ed6f55ea363461998276666542",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n  cache: true\n  echo: true\n---\n\n\n# Your first shiny app {#sec-chap01}\n\n\n\n## Introduction\n\n:::::: {#obj-chap01}\n::::: my-objectives\n::: my-objectives-header\nObjectives for Chapter 01\n:::\n\n::: my-objectives-container\n-   Using the minimum boilerplate needed for a Shiny app (@sec-01-minimum-app)\n-   How to start and stop a Shiny app (@sec-01-run-and-stop)\n-   UI is short for user interface, which defines how your app *looks* (@sec-01-ui-controls)\n-   Server function defines how your app *works* (@sec-01-adding-behaviour)\n-   <a class='glossary' title='Reactive expressions are a key component of reactive programming in Shiny. They are R expressions that use widget input and return a value, updating this value whenever the original widget changes. Reactive expressions cache their values and know when their values have become outdated, which helps in preventing unnecessary re-computation and makes the app faster.'>Reactive expressions</a> as Shiny uses\n    <a class='glossary' title='Reactive programming in R Shiny is a coding style that focuses on managing values that change over time and orchestrating actions based on those changes. This feature is crucial for Shiny applications because users interact with dynamic controls like sliders and checkboxes, which trigger server-side processes, such as data retrieval and updates to output elements. In Shiny, reactive programming creates a dynamic link between inputs and outputs, ensuring that outputs refresh automatically when there’s a change in inputs.'>reactive programming</a> to automatically update outputs\n    when inputs change (@sec-01-reactive-expressions)\n:::\n:::::\n::::::\n\n## Create app directory and file {#sec-01-minimum-app}\n\nThere are several ways to create a Shiny app. I am using the following\nprocedure:\n\n:::::: my-procedure\n:::: my-procedure-header\n::: {#prp-01-create-shiny-app}\n: My preferred procedure to create a Shiny app\n:::\n::::\n\n::: my-procedure-container\n1.  In RStudio choose `File | New File > Shiny Web App…`\n2.  In the window fill in the application name.\n3.  This will create the directory with the file `app.R` in the\n    directory. Additionally it will open `app.R` with a boiler template.\n4.  Delete the boiler template, e.g. the whole content of the `app.R`\n    file.\n5.  Type `sh1` followed by `Shift TAB` for my own boiler\n    template[^01-first-shiny-app-1] with the following content:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"My boiler template\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  \n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n\nSee the help documentation for creating [Code Snippets in the RStudio IDE](https://support.posit.co/hc/en-us/articles/204463668-Code-Snippets-in-the-RStudio-IDE).\n:::\n::::::\n\n[^01-first-shiny-app-1]: This works only in places where programming\n    code is expected (and not in Markdown text passages).\n\nPutting \"Hello World\" into the `shiny::fluidPage()` function results in\nthe most basic example:\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-01-minimum-example}\n: Most basic {**shiny**} example\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-01-minimum-example-code}\n: Most basic {**shiny**} example\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"Minimum {**shiny**} example\"}\nlibrary(shiny)\nui <- fluidPage(\n  \"Hello, world!\"\n)\n\nserver <- function(input, output, session) {\n\n    }\n\nshinyApp(ui, server)\n```\n:::\n\n\n***\n\n\n1.  It calls `library(shiny`) to load the shiny package.\n2.  It defines the user interface, the HTML webpage that humans interact\n    with. In this case, it’s a page containing the words “Hello,\n    world!”.\n3.  It specifies the behaviour of our app by defining a server function.\n    It’s currently empty, so our app doesn’t do anything, but we’ll be\n    back to revisit this shortly.\n4.  It executes `shinyApp(ui, server)` to construct and start a Shiny\n    application from UI and server.\n\n\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-01-minimum-example-shiny}\n: Minimum {**shiny**} example\n::::::\n:::\n::::{.my-r-code-container}\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 40\n\nlibrary(shiny)\nui <- fluidPage(\n  \"Hello, world!\"\n)\n\nserver <- function(input, output, session) {\n\n    }\n\nshinyApp(ui, server)\n```\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\n\n\n\n## Running and stopping {#sec-01-run-and-stop}\n\nThere are a few ways to run the app:\n\n-   Click the `Run App` button in the document toolbar.\n-   Use the keyboard shortcut on macOS: `Cmd + Shift + Enter`.\n\nBy choosing one of the options under the `Run App`button you can specify\nif you want the results presented\n\n-   in an extra browser **w**indow (shortcut: `Alt + Shift + W`)\n-   in the RStudio **v**iewer pane (shortcut: `Alt + Shift + V`) or\n-   run **e**xternal in your default browser (shortcut:\n    `Alt + Shift + E`).\n\nIn the console I found the \n\n> Listening on http://127.0.0.1:5959\n\nThis tells me the URL where your app can be found: `127.0.0.1` is a standard address that means “this computer” and `5959` is a randomly assigned port number. Entering that URL into any compatible web browser opens another copy of the Shiny app.\n\nThe red stop sign in the top right console window means that R is busy. I have to stop the app before I can write commands in the console. There are several options to stop the server:\n\n- Click on the stop sign\n- Click in the console and type ESC\n- Close the Shiny app window(s)\n\n::: {.callout-note}\nTo speed up the development process you don't need to stop and restart the server to see the changes. When the server is running the button `Run app` changes to `Reload app`. Click on it or use the `Cmd + Shift + Enter` keyboard shortcut to reload the (changed) app.\n:::\n\n## Adding UI controls {#sec-01-ui-controls}\n\nReplace your ui with this code:\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-01-add-ui-controls}\n: Add UI controls\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-01-add-ui-controls-code}\n: Add UI controls\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  selectInput(\"dataset\", label = \"Dataset\", choices = ls(\"package:datasets\")),\n  verbatimTextOutput(\"summary\"),\n  tableOutput(\"table\")\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n***\n\nThis example uses four new functions:\n\n1. `shiny::fluidPage()` is a layout function that sets up the basic visual structure of the page. (See @XXX_6.2)\n2. `shiny::selectInput()` is an input control that lets the user interact with the app by providing a value. In this case, it’s a select box with the label “Dataset” and lets you choose one of the built-in datasets that come with R. (See @XXX_2.2)\n3. `shiny::verbatimTextOutput()` is an output control that tell Shiny where to put rendered output, in this case where to display code. \n4. `shiny::tableOutput()` is another output controls that displays tables. (For output contols ee @XXX_2.3)\n\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-01-add-ui-controls-shiny}\n: Add UI controls\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 300\n\nlibrary(shiny)\n\nui <- fluidPage(\n  selectInput(\"dataset\", label = \"Dataset\", choices = ls(\"package:datasets\")),\n  verbatimTextOutput(\"summary\"),\n  tableOutput(\"table\")\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\n\n\n\n::: {.callout-note}\nLayout functions, inputs, and outputs have different uses, but they are fundamentally the same under the covers: they’re all just fancy ways to generate HTML, and if you call any of them outside of a Shiny app, you’ll see HTML printed out at the console.\n\nFor instance: \n\n```\n> shiny::tableOutput(\"table\") # results into:\n<div id=\"table\" class=\"shiny-html-output\"></div>\n```\n:::\n\nRunning the app again we’ll see a page containing a select box. We only see the input, not the two outputs, because we haven’t yet told Shiny how the input and outputs are related.\n\n## Adding behaviour {#sec-01-adding-behaviour}\n\nShiny uses <a class='glossary' title='Reactive programming in R Shiny is a coding style that focuses on managing values that change over time and orchestrating actions based on those changes. This feature is crucial for Shiny applications because users interact with dynamic controls like sliders and checkboxes, which trigger server-side processes, such as data retrieval and updates to output elements. In Shiny, reactive programming creates a dynamic link between inputs and outputs, ensuring that outputs refresh automatically when there’s a change in inputs.'>reactive programming</a> to make apps interactive. \n(More about reactive programming in @XXX_3.) For now, just be aware\nthat it involves telling Shiny how to perform a computation, not\nordering Shiny to actually go do it.\n\nWe’ll tell Shiny how to fill in the summary and table outputs in the sample app by providing the “recipes” for those outputs. Replace your empty server function the folowing code:\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-01-adding-behaviour}\n: Add behaviour\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-01-add-behaviour-code}\n: Add behaviour\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  selectInput(\"dataset\", label = \"Dataset\", choices = ls(\"package:datasets\")),\n  verbatimTextOutput(\"summary\"),\n  tableOutput(\"table\")\n)\n\nserver <- function(input, output, session) {\n  output$summary <- renderPrint({\n    dataset <- get(input$dataset, \"package:datasets\")\n    summary(dataset)\n  })\n  \n  output$table <- renderTable({\n    dataset <- get(input$dataset, \"package:datasets\")\n    dataset\n  })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n***\n\n\n- The left-hand side of the assignment operator (`<-`), `output$ID`, indicates that you’re providing the recipe for the Shiny output with that ID. \n- The right-hand side of the assignment uses a specific render function to wrap some code that you provide. Each `render{Type}` function is designed to produce a particular type of output (e.g. text, tables, and plots), and is often paired with a `{type}Output` function. For example, in this app, `shiny::renderPrint()` is paired with `shiny::verbatimTextOutput()` to display a statistical summary with fixed-width (verbatim) text, and `shiny::renderTable()` is paired with `shiny::tableOutput()` to show the input data in a table.\n\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-01-add-behaviour-shiny}\n: Add behaviour\n::::::\n:::\n::::{.my-r-code-container}\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\nlibrary(shiny)\n\nui <- fluidPage(\n  selectInput(\"dataset\", label = \"Dataset\", choices = ls(\"package:datasets\")),\n  verbatimTextOutput(\"summary\"),\n  tableOutput(\"table\")\n)\n\nserver <- function(input, output, session) {\n  output$summary <- renderPrint({\n    dataset <- get(input$dataset, \"package:datasets\")\n    summary(dataset)\n  })\n  \n  output$table <- renderTable({\n    dataset <- get(input$dataset, \"package:datasets\")\n    dataset\n  })\n}\n\nshinyApp(ui, server)\n```\n\n\n\n\n::::\n:::::\n\n\n:::\n\nNotice that the summary and table update whenever you change the input dataset. This dependency is created implicitly because we’ve referred to `shiny::input$dataset()` within the output functions. `shiny::input$dataset()` is populated with the current value of the UI component with id `dataset`, and will cause the outputs to automatically update whenever that value changes. *This is the essence of reactivity: outputs automatically react (recalculate) when their inputs change*.\n\n::::\n:::::\n\n## Reducing duplication with reactive expressions {#sec-01-reactive-expressions}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"The following line is duplicated:\"}\ndataset <- get(input$dataset, \"package:datasets\")\n```\n:::\n\n\n\nIn traditional R scripting, we use two techniques to deal with duplicated code: either we capture the value using a variable, or capture the computation with a function. Unfortunately neither of these approaches work here, for reasons you’ll learn about in @XXX_13.2. Therefore we need a new mechanism: <a class='glossary' title='Reactive expressions are a key component of reactive programming in Shiny. They are R expressions that use widget input and return a value, updating this value whenever the original widget changes. Reactive expressions cache their values and know when their values have become outdated, which helps in preventing unnecessary re-computation and makes the app faster.'>reactive expressions</a>.\n\n::: {.callout-important}\n###### Creating reactive expressions\n\nYou create a reactive expression by wrapping a block of code in `reactive({...})` and assigning it to a variable, and you use a reactive expression by calling it like a function. But while it looks like you’re calling a function, a reactive expression has an important difference: it only runs the first time it is called and then it caches its result until it needs to be updated.\n:::\n\nWe can update our `shiny::server()` function to use reactive expressions, as shown below. The app behaves identically, but works a little more efficiently because it only needs to retrieve the dataset once, not twice.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-01-add-reactive-expression}\n: Add reactive expression\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-01-add-reactive-expression-code}\n: Add reactive expression to simplify the code\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  selectInput(\"dataset\", label = \"Dataset\", choices = ls(\"package:datasets\")),\n  verbatimTextOutput(\"summary\"),\n  tableOutput(\"table\")\n)\n\nserver <- function(input, output, session) {\n  # Create a reactive expression\n  dataset <- reactive({\n    get(input$dataset, \"package:datasets\")\n  })\n\n  output$summary <- renderPrint({\n    # Use a reactive expression by calling it like a function\n    summary(dataset())\n  })\n  \n  output$table <- renderTable({\n    dataset()\n  })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-add-reactive-expression-shiny}\n: Added reactive expression to simplify the code\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\nlibrary(shiny)\n\nui <- fluidPage(\n  selectInput(\"dataset\", label = \"Dataset\", choices = ls(\"package:datasets\")),\n  verbatimTextOutput(\"summary\"),\n  tableOutput(\"table\")\n)\n\nserver <- function(input, output, session) {\n  # Create a reactive expression\n  dataset <- reactive({\n    get(input$dataset, \"package:datasets\")\n  })\n\n  output$summary <- renderPrint({\n    # Use a reactive expression by calling it like a function\n    summary(dataset())\n  })\n  \n  output$table <- renderTable({\n    dataset()\n  })\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\n\n## Summary\n\nIn this chapter we’ve created a simple app.\n\n:::::{.my-resource}\n:::{.my-resource-header}\n:::::: {#lem-01-shiny-cheatsheet}\n: Shiny cheatsheet\n::::::\n:::\n::::{.my-resource-container}\nTo remember the shiny components and functions download and use the [shiny cheatsheet](https://rstudio.github.io/cheatsheets/shiny.pdf).\n::::\n:::::\n\n## Exercises\n\n\n### Example 1: Greeting app\n\nCreate an app that greets the user by name. You don’t know all the functions you need to do this yet, so I’ve included some lines of code below. \n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-01-greeting-app}\n: Greeting app\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\n**Think about which lines you’ll use and then copy and paste them into the right place in a Shiny app**.\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-01-greeting-app-challenge}\n: Greeting app\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"Which lines of code in which place for a Shiny greeting app?\"}\ntableOutput(\"mortgage\")\noutput$greeting <- renderText({\n  paste0(\"Hello \", input$name)\n})\nnumericInput(\"age\", \"How old are you?\", value = NA)\ntextInput(\"name\", \"What's your name?\")\ntextOutput(\"greeting\")\noutput$histogram <- renderPlot({\n  hist(rnorm(1000))\n}, res = 96)\n```\n:::\n\n\n\n::::\n:::::\n\n\n\n###### Solution (Code)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-01-greeting-app-solution}\n: Greeting app\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\nui <- fluidPage(\n    textInput(\"name\", \"What's your name?\"),\n    textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n    output$greeting <- renderText({\n        paste0(\"Hello \", input$name)\n    })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Solution (Shiny)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-01-greeting-app-shiny}\n: Greeting app\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 100\n\nlibrary(shiny)\n\nui <- fluidPage(\n    textInput(\"name\", \"What's your name?\"),\n    textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n    output$greeting <- renderText({\n        paste0(\"Hello \", input$name)\n    })\n}\n\nshinyApp(ui, server)\n```\n\n\n\n\n\n\n::::\n:::::\n\n\n:::\n\n::::\n:::::\n\n\n### Example 2: Multiply `x` with 5\n\nSuppose your friend wants to design an app that allows the user to set a number (`x`) between 1 and 50, and displays the result of multiplying this number by 5. \n\nThis is their first attempt but it has an error.\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-01-multiply-x-with-5}\n: Multiply `x` with 5\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-01-multiply-x-with-5-challenge}\n: Multiply `x` with 5\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"Correct the error\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  sliderInput(\"x\", label = \"If x is\", min = 1, max = 50, value = 30),\n  \"then x times 5 is\",\n  textOutput(\"product\")\n)\n\nserver <- function(input, output, session) {\n  output$product <- renderText({ \n    x * 5\n  })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n![](https://mastering-shiny.org/demos/basic-app/ex-x-times-5.png)\n\n\n::::\n:::::\n\n\n\n###### Solution (Code)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-multiply-x-with-5-app-solution}\n: Multiply `x` with 5\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\nui <- fluidPage(\n    sliderInput(\"x\", label = \"If x is\", min = 1, max = 50, value = 30),\n    \"then x times 5 is\",\n    textOutput(\"product\")\n)\n\nserver <- function(input, output, session) {\n    output$product <- renderText({\n        input$x * 5\n    })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Solution (Shiny)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-multiply-with-5-app-shiny}\n: Multiply `x` with 5\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 200\n\nlibrary(shiny)\n\nui <- fluidPage(\n    sliderInput(\"x\", label = \"If x is\", min = 1, max = 50, value = 30),\n    \"then x times 5 is\",\n    textOutput(\"product\")\n)\n\nserver <- function(input, output, session) {\n    output$product <- renderText({\n        input$x * 5\n    })\n}\n\nshinyApp(ui, server)\n```\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\n\n### Example 3: Multiply `x` with `y`\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-01-multiply-x-with-y-challenge}\n: Multiply `x` with `y`\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\nExtend the app from the previous exercise to allow the user to set the value of the multiplier, y, so that the app yields the value of x * y. The final result should look like this:.\n\n![](https://mastering-shiny.org/demos/basic-app/ex-x-times-y.png)\n\n\n###### Solution (Code)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-01-multiply-x-with-y-app-solution}\n: Multiply `x` with `y`\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\nui <- fluidPage(\n    sliderInput(\"x\", label = \"If x is\", min = 1, max = 50, value = 30),\n    sliderInput(\"y\", label = \"and y is\", min = 1, max = 50, value = 5),\n    \"then x times y is\",\n    textOutput(\"product\")\n)\n\nserver <- function(input, output, session) {\n    output$product <- renderText({\n        input$x * input$y\n    })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Solution (Shiny)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-01-multiply-x-with-y-app-shiny}\n: Multiply `x` with `y`\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n\nlibrary(shiny)\n\nui <- fluidPage(\n    sliderInput(\"x\", label = \"If x is\", min = 1, max = 50, value = 30),\n    sliderInput(\"y\", label = \"and y is\", min = 1, max = 50, value = 5),\n    \"then x times y is\",\n    textOutput(\"product\")\n)\n\nserver <- function(input, output, session) {\n    output$product <- renderText({\n        input$x * input$y\n    })\n}\n\nshinyApp(ui, server)\n\n```\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\n\n### Example 4: Use reactive expression\n\nTake the following app which adds some additional functionality to the last app described in the last exercise. What’s new? How could you reduce the amount of duplicated code in the app by using a reactive expression.\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-01-reactive-expression}\n: Simplify code with a reactive expression\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-01-reactive-expression-challenge}\n: Simplify code with a reactive expression\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"Use a reactive expression\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  sliderInput(\"x\", \"If x is\", min = 1, max = 50, value = 30),\n  sliderInput(\"y\", \"and y is\", min = 1, max = 50, value = 5),\n  \"then, (x * y) is\", textOutput(\"product\"),\n  \"and, (x * y) + 5 is\", textOutput(\"product_plus5\"),\n  \"and (x * y) + 10 is\", textOutput(\"product_plus10\")\n)\n\nserver <- function(input, output, session) {\n  output$product <- renderText({ \n    product <- input$x * input$y\n    product\n  })\n  output$product_plus5 <- renderText({ \n    product <- input$x * input$y\n    product + 5\n  })\n  output$product_plus10 <- renderText({ \n    product <- input$x * input$y\n    product + 10\n  })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n::::\n:::::\n\n\n\n###### Solution (Code)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-reactive-expression-app-solution}\n: Simplify code with a reactive expression\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\nui <- fluidPage(\n    sliderInput(\"x\", \"If x is\", min = 1, max = 50, value = 30),\n    sliderInput(\"y\", \"and y is\", min = 1, max = 50, value = 5),\n    \"then, (x * y) is\", textOutput(\"product\"),\n    \"and, (x * y) + 5 is\", textOutput(\"product_plus5\"),\n    \"and (x * y) + 10 is\", textOutput(\"product_plus10\")\n)\n\nserver <- function(input, output, session) {\n    # Create a reactive expression\n    product <- reactive({\n        input$x * input$y\n    })\n\n    output$product <- renderText({\n        product()\n    })\n    output$product_plus5 <- renderText({\n        product() + 5\n    })\n    output$product_plus10 <- renderText({\n        product() + 10\n    })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Solution (Shiny)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-ID-WHAT-app-shiny}\n: Simplify code with a reactive expression\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n\nlibrary(shiny)\n\nui <- fluidPage(\n    sliderInput(\"x\", \"If x is\", min = 1, max = 50, value = 30),\n    sliderInput(\"y\", \"and y is\", min = 1, max = 50, value = 5),\n    \"then, (x * y) is\", textOutput(\"product\"),\n    \"and, (x * y) + 5 is\", textOutput(\"product_plus5\"),\n    \"and (x * y) + 10 is\", textOutput(\"product_plus10\")\n)\n\nserver <- function(input, output, session) {\n    # Create a reactive expression\n    product <- reactive({\n        input$x * input$y\n    })\n\n\n    output$product <- renderText({\n        product()\n    })\n    output$product_plus5 <- renderText({\n        product() + 5\n    })\n    output$product_plus10 <- renderText({\n        product() + 10\n    })\n}\n\nshinyApp(ui, server)\n\n```\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\n### Example 5: Find three bugs\n\nThe following app is very similar to one you’ve seen earlier in the chapter: you select a dataset from a package (this time we’re using the {**ggplot2**} package) and the app prints out a summary and plot of the data. It also follows good practice and makes use of reactive expressions to avoid redundancy of code. However there are three bugs in the code provided below. Can you find and fix them?\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-01-find-3-bugs}\n: Find three bugs\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-01-find-3-bugse}\n: Find three bugs\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"Find three bugs\"}\nlibrary(shiny)\nlibrary(ggplot2)\n\ndatasets <- c(\"economics\", \"faithfuld\", \"seals\")\nui <- fluidPage(\n  selectInput(\"dataset\", \"Dataset\", choices = datasets),\n  verbatimTextOutput(\"summary\"),\n  tableOutput(\"plot\")\n)\n\nserver <- function(input, output, session) {\n  dataset <- reactive({\n    get(input$dataset, datasets)\n  })\n  output$summary <- renderPrint({\n    summary(dataset())\n  })\n  output$plot <- renderPlot({\n    plot(dataset)\n  }, res = 96)\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n\n\n::::\n:::::\n\n\n\n###### Solution (Code)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-01-find-3-bugs-app-solution}\n: Find three bugs\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\nlibrary(ggplot2)\n\ndatasets <- c(\"economics\", \"faithfuld\", \"seals\")\nui <- fluidPage(\n    selectInput(\"dataset\", label = \"Dataset\", choices = datasets),\n    verbatimTextOutput(\"summary\"),\n    plotOutput(\"plot\")\n)\n\nserver <- function(input, output, session) {\n    dataset <- reactive({\n        get(input$dataset)\n    })\n    output$summary <- renderPrint({\n        summary(dataset())\n    })\n    output$plot <- renderPlot({\n        plot(dataset())\n    }, res = 96)\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Solution (Shiny)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-01-find-3-bugs-app-shiny}\n: Find three bugs\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\nlibrary(shiny)\nlibrary(ggplot2)\n\nmy_datasets <- c(\"economics\", \"faithfuld\", \"seals\")\nui <- fluidPage(\n    selectInput(\"dataset\", label = \"Dataset\", choices = my_datasets),\n    verbatimTextOutput(\"summary\"),\n    plotOutput(\"plot\")\n)\n\nserver <- function(input, output, session) {\n    dataset <- reactive({\n        get(input$dataset)\n    })\n    output$summary <- renderPrint({\n        summary(dataset())\n    })\n    output$plot <- renderPlot({\n        plot(dataset())\n    }, res = 96)\n}\n\nshinyApp(ui, server)\n\n```\n\n::: {.callout-warning}\nThis code chunk works as a standalone {**shiny**} app. I do not know what's the difference here with {**shinylive**}. I have to ask in the appropriate forum(s).\n:::\n\n\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}