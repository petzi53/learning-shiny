{
  "hash": "c2aaf4ae402db533691ebfe0394fe33c",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n  cache: true\n---\n\n\n# Basic UI {#sec-chap02}\n\n\n\n\n## Table of content for chapter 02 {.unnumbered}\n\n::::: {#obj-chap03}\n:::: {.my-objectives}\n::: {.my-objectives-header}\nChapter section list\n:::\n\n::: {.my-objectives-container}\n\n\n:::\n::::\n:::::\n\n## Introduction\n\nIn this chapter, we’ll focus on the front end, and give you a whirlwind tour of the HTML inputs and outputs provided by Shiny. We’ll mostly stick to the inputs and outputs built into Shiny itself. However, there is a rich and vibrant community of extension packages, like\n\n- [shinyWidgets](https://dreamrs.github.io/shinyWidgets/index.html) [@shinyWidgets], \n- [colourpicker](https://daattali.com/shiny/colourInput/) [@colourpicker], and \n- [sortable](https://rstudio.github.io/sortable/) [@sortable]. \n\nYou can find a comprehensive, [actively-maintained list of packages supporting {**shiny**}](https://github.com/nanxstats/awesome-shiny-extensions) at , maintained by [Nan Xiao](https://nanx.me/).\n\n## Inputs\n\n### Common structure\n\nThere are three common parameters:\n\n1. **inputID**: All input functions have the same first argument: `inputId`. This is the identifier used to connect the front end with the back end: if your UI has an input with ID `\"name\"`, the server function will access it with `input$name`. The `inputId` has two constraints:\n    - It must be a simple string that contains only letters, numbers, and underscores (no spaces, dashes, periods, or other special characters allowed!). Name it like you would name a variable in R.\n    - It must be unique. If it’s not unique, you’ll have no way to refer to this control in your server function!\n2. **label**: Most input functions have a second parameter called `label`. This is used to create a human-readable label for the control. Shiny doesn’t place any restrictions on this string.\n3. **value**: The third parameter is typically `value`, which, where possible, lets you set the default value.\n\nRemaining parameters are unique to the specific control.\n\nWhen creating an input, I recommend supplying the `inputId` and `label` arguments by position, and all other arguments by name:\n\n```\nsliderInput(\"min\", \"Limit (minimum)\", value = 50, min = 0, max = 100)\n```\n\n::: {.callout-note}\nThe following sections describe the inputs built into Shiny, loosely grouped according to the type of control they create. The goal is to give you a rapid overview of your options, not to exhaustively describe all the arguments. Read the documentation to get the full details!\n:::\n\n\n### Free text\n\nCollect small amounts of text with `textInput()`, passwords with `passwordInput()`, and paragraphs of text with `textAreaInput()`.\n\n::: {.callout-warning}\nAll `passwordInput()` does is hide what the user is typing, so that someone looking over their shoulder can't read it. It's up to you to make sure that any passwords are not accidentally exposed, so we don't recommend using passwords unless you have had some training in secure programming.\n:::\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-free-text-input}\n: Free text input\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-free-text-input-code}\n: Free text input examples\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  passwordInput(\"password\", \"What's your password?\"),\n  textAreaInput(\"story\", \"Tell me about yourself\", rows = 3)\n)\n\nserver <- function(input, output, session) {\n\n    }\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-free-text-input-shiny}\n: Free text input examples\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 300\n\nlibrary(shiny)\n\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  passwordInput(\"password\", \"What's your password?\"),\n  textAreaInput(\"story\", \"Tell me about yourself\", rows = 3)\n)\n\nserver <- function(input, output, session) {\n\n    }\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\nIf you want to ensure that the text has certain properties you can use `shiny::validate()`, which we’ll come back to in @XXX_8.\n\n### Numeric input {#sec-02-numeric-input}\n\nTo collect numeric values, create a constrained text box with `numericInput()` or a slider with `sliderInput()`. If you supply a length-2 numeric vector for the default value of `sliderInput()`, you get a “range” slider with two ends.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-numeric-input}\n: Numeric input\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-numeric-input-code}\n: Numeric input examples\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  numericInput(\"num\", \"Number one\", value = 0, min = 0, max = 100),\n  sliderInput(\"num2\", \"Number two\", value = 50, min = 0, max = 100),\n  sliderInput(\"rng\", \"Range\", value = c(10, 20), min = 0, max = 100)\n)\n\nserver <- function(input, output, session) {\n\n    }\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-numeric-input-shiny}\n: Numeric input examples\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 300\n\nlibrary(shiny)\n\nui <- fluidPage(\n  numericInput(\"num\", \"Number one\", value = 0, min = 0, max = 100),\n  sliderInput(\"num2\", \"Number two\", value = 50, min = 0, max = 100),\n  sliderInput(\"rng\", \"Range\", value = c(10, 20), min = 0, max = 100)\n)\n\nserver <- function(input, output, session) {\n\n    }\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\nSliders are extremely customisable and there are many ways to tweak their appearance. See [Slider Input Widget — sliderInput](https://shiny.posit.co/r/reference/shiny/latest/sliderinput.html) and [Using sliders](https://shiny.rstudio.com/articles/sliders.html) for more details. See also my experiments in @sec-annex-choose-year-via-slider.\n\n### Dates\n\nCollect a single day with `shiny::dateInput()` or a range of two days with `shiny::dateRangeInput()`. These provide a convenient calendar picker, and additional arguments like `datesdisabled` and `daysofweekdisabled` allow you to restrict the set of valid inputs.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-date-input}\n: Date input\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-date-input-code}\n: Date input examples\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n  dateInput(\"dob\", \"When were you born?\"),\n  dateRangeInput(\"holiday\", \"When do you want to go on vacation next?\")\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-date-input-shiny}\n: Date input examples\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n\nlibrary(shiny)\n\nui <- fluidPage(\n  dateInput(\"dob\", \"When were you born?\"),\n  dateRangeInput(\"holiday\", \"When do you want to go on vacation next?\")\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\nDate format, language, and the day on which the week starts defaults to US standards. If you are creating an app with an international audience, set `format`, `language`, and `weekstart` so that the dates are natural to your users.\n\n### Limited choices\n\n#### Introduction\n\nThere are two different approaches to allow the user to choose from a prespecified set of options: `shiny::selectInput()` and `shiny::radioButtons()`.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-limited-choices}\n: Limited choices\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-limited-choices-code}\n: Limited choices: drop-down menu and radio buttons\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nanimals <- c(\"dog\", \"cat\", \"mouse\", \"bird\", \"other\", \"I hate animals\")\n\nui <- fluidPage(\n  selectInput(\"state\", \"What's your favourite state?\", state.name),\n  radioButtons(\"animal\", \"What's your favourite animal?\", animals)\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-limited-choices-shiny}\n: Limited choices: drop-down menu and radio buttons\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n\nlibrary(shiny)\n\nanimals <- c(\"dog\", \"cat\", \"mouse\", \"bird\", \"other\", \"I hate animals\")\n\nui <- fluidPage(\n  selectInput(\"state\", \"What's your favourite state?\", state.name),\n  radioButtons(\"animal\", \"What's your favourite animal?\", animals)\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\nSee my experiment in @sec-annex-whr-exercises-year-via-drop-down.\n\n#### Radio buttons\n\nRadio buttons have two nice features: \n\n- they show all possible options, making them suitable for *short* lists, and \n- via the `choiceNames`/`choiceValues` arguments, they can display options other than plain text. \n    - `choiceNames` determines what is shown to the user; \n    - `choiceValues` determines what is returned in your server function.\n    \n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-radio-buttons}\n: Radio buttons\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-radio-buttons-code}\n: Radio buttons\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n  radioButtons(\"rb\", \"Choose one:\",\n    choiceNames = list(\n      icon(\"angry\"),\n      icon(\"smile\"),\n      icon(\"sad-tear\")\n    ),\n    choiceValues = list(\"angry\", \"happy\", \"sad\")\n  )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-radio-buttons-shiny}\n: Radio buttons\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 120\n\nlibrary(shiny)\n\nui <- fluidPage(\n  radioButtons(\"rb\", \"Choose one:\",\n    choiceNames = list(\n      icon(\"angry\"),\n      icon(\"smile\"),\n      icon(\"sad-tear\")\n    ),\n    choiceValues = list(\"angry\", \"happy\", \"sad\")\n  )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n#### Drop-down menus\n\nDropdowns created with `shiny::selectInput()` take up the same amount of space, regardless of the number of options, making them *more suitable for longer options*. You can also set `multiple = TRUE` to allow the user to select multiple elements.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-drop-down-menus}\n: Drop-down menus\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-drop-down-menus-code}\n: Drop-down menus\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n  selectInput(\n    \"state\", \"What are your favourite states?\", state.name,\n    multiple = TRUE\n  )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-drop-down-menus-shiny}\n: Drop-down menus\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 300\n\nlibrary(shiny)\n\nui <- fluidPage(\n  selectInput(\n    \"state\", \"What are your favourite states?\", state.name,\n    multiple = TRUE\n  )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\nIf you have a very large set of possible options, you may want to use “server-side” `shiny::selectInput()` so that the complete set of possible options are not embedded in the UI (which can make it slow to load), but instead sent as needed by the server. You can learn more about this advanced topic at [Server-side selectize](https://shiny.rstudio.com/articles/selectize.html#server-side-selectize).\n\n#### Check boxes\n\nThere’s no way to select multiple values with radio buttons, but there’s an alternative that’s conceptually similar: `shiny::checkboxGroupInput()`. For a checkbox for a single yes/no question, use `shiny::checkboxInput()`:\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-check-boxes}\n: Check boxes\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-check-boxes-code}\n: Check boxes\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nanimals <- c(\"dog\", \"cat\", \"mouse\", \"bird\", \"other\", \"I hate animals\")\nui <- fluidPage(\n    checkboxGroupInput(\"animal\", \"What animals do you like?\", animals),\n    checkboxInput(\"cleanup\", \"Clean up?\", value = TRUE),\n    checkboxInput(\"shutdown\", \"Shutdown?\")\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-check-boxes-shiny}\n: Check boxes\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 300\n\nlibrary(shiny)\n\nanimals <- c(\"dog\", \"cat\", \"mouse\", \"bird\", \"other\", \"I hate animals\")\nui <- fluidPage(\n    checkboxGroupInput(\"animal\", \"What animals do you like?\", animals),\n    checkboxInput(\"cleanup\", \"Clean up?\", value = TRUE),\n    checkboxInput(\"shutdown\", \"Shutdown?\")\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\n### File uploads\n\n`shiny::fileInput()` requires special handling on the server side, and is discussed in detail in @XXX_9.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-file-uploads}\n: File uploads\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-file-uploads-code}\n: File uploads\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n  fileInput(\"upload\", NULL)\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-file-uploads-shiny}\n: File uploads\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 100\n\nlibrary(shiny)\n\nui <- fluidPage(\n  fileInput(\"upload\", NULL)\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\n### Action buttons\n\nLet the user perform an action with shiny::actionButton() or shiny::actionLink(): Actions links and buttons are most naturally paired with shiny::observeEvent() or shiny::eventReactive() in your server function. You haven’t learned about these important functions yet, but we’ll come back to them in @XXX_3.5.\n\nYou can customize the appearance using the class argument by using one of `\"btn-primary\"`, `\"btn-success\"`, `\"btn-info\"`, `\"btn-warning`\", or `\"btn-danger\"`. You can also change the size with `\"btn-lg`\", `\"btn-sm\"`, `\"btn-xs`\". Finally, you can make buttons span the entire width of the element they are embedded within using `\"btn-block\"`.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-action-buttons}\n: Action buttons\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-action-buttons-code}\n: Action buttons\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n  fluidRow(\n    actionButton(\"click\", \"Click me!\", class = \"btn-danger\"),\n    actionButton(\"drink\", \"Drink me!\", class = \"btn-lg btn-success\")\n  ),\n  fluidRow(\n    actionButton(\"eat\", \"Eat me!\", class = \"btn-block\")\n  )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-action-buttons-shiny}\n: Action buttons\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 100\n\nlibrary(shiny)\n\nui <- fluidPage(\n  fluidRow(\n    actionButton(\"click\", \"Click me!\", class = \"btn-danger\"),\n    actionButton(\"drink\", \"Drink me!\", class = \"btn-lg btn-success\")\n  ),\n  fluidRow(\n    actionButton(\"eat\", \"Eat me!\", class = \"btn-block\")\n  )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\nThe class argument works by setting the class attribute of the underlying HTML, which affects how the element is styled. To see other options, you can read the [documentation for Bootstrap](http://bootstrapdocs.com/v3.3.6/docs/css/#buttons), the CSS design system used by Shiny.\n\n### Exercises\n\n#### Label as placeholder\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-02-input-ex-01-label-as-placeholder}\n: Use label as placeholder\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\n\nWhen space is at a premium, it’s useful to label text boxes using a placeholder that appears inside the text entry area. How do you call `shiny::textInput()` to generate the UI below?\n\n![](https://mastering-shiny.org/demos/basic-ui/placeholder.png)\n\n\n\n###### Solution (Code)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-02-input-ex-01-label-as-placeholder-solution}\n: Use label as placeholder\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\nui <- fluidPage(\n    textInput(\n        \"name\", \n        label = NULL, \n        placeholder = label\n        )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Solution (Shiny)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-02-input-ex-01-label-as-placeholder-shiny}\n: Use label as placeholder\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 100\n\nlibrary(shiny)\n\nui <- fluidPage(\n    textInput(\n        \"name\", \n        label = NULL, \n        placeholder = \"Your name\"\n        )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n\n```\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n#### Create a date slider\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-02-input-ex-02-create-date-slider}\n: Create a date slider\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\n\nCarefully read the documentation for `shiny::sliderInput()` to figure out how to create a date slider, as shown below.\n\n![](https://mastering-shiny.org/demos/basic-ui/date-slider.png)\n\n\n\n###### Solution (Code)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-02-input-ex-02-create-date-slider-solution}\n: Create a data slider\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\nlibrary(lubridate)\n\nui <- fluidPage(\n    sliderInput(\n        \"deliver\",\n        \"When should we deliver?\",\n        timeFormat = \"%F\",\n        min = as_date(\"2020-09-16\"),\n        max = as_date(\"2020-09-23\"),\n        value = as_date(\"2020-09-17\")\n    )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Solution (Shiny)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-02-input-ex-02-create-date-slider-shiny}\n: Create a date slider\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 100\n\nlibrary(shiny)\nlibrary(lubridate)\n\nui <- fluidPage(\n    sliderInput(\n        \"deliver\",\n        \"When should we deliver?\",\n        timeFormat = \"%F\",\n        min = as_date(\"2020-09-16\"),\n        max = as_date(\"2020-09-23\"),\n        value = as_date(\"2020-09-17\")\n    )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n\n```\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n#### Slider animation\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-02-input-ex-03-slider-animation}\n: Slider animation\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\n\nCreate a slider input to select values between 0 and 100 where the interval between each selectable value on the slider is 5. Then, add animation to the input widget so when the user presses play the input widget scrolls through the range automatically.\n\n###### Solution (Code)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-02-input-ex-03-slider-animation-solution}\n: Slider animation\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nui <- fluidPage(\n    sliderInput(\n        \"num\",\n        \"Press play button\",\n        min = 0,\n        max = 100,\n        value = 0,\n        step = 5,\n        animate = animationOptions(\n            interval = 1000,\n            loop = TRUE,\n            playButton = \"Play\",\n            pauseButton = \"Stop\"\n        )\n    )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Solution (Shiny)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-02-input-ex-03-slider-animation-shiny}\n: Slider animation\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 150\n\nui <- fluidPage(\n    sliderInput(\n        \"num\",\n        \"Press play button\",\n        min = 0,\n        max = 100,\n        value = 0,\n        step = 5,\n        animate = animationOptions(\n            interval = 1000,\n            loop = TRUE,\n            playButton = \"Play\",\n            pauseButton = \"Stop\"\n        )\n    )\n)\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n\n\n```\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\n#### Menu with subheadings\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-02-input-ex-04-menu-with-subheadings}\n: Menu with subheadings\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\n\nIf you have a moderately long list in a `shiny::selectInput()`, it’s useful to create sub-headings that break the list up into pieces. Read the documentation to figure out how. (Hint: the underlying HTML is called `<optgroup>`.)\n\n\n###### Solution (Code)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-02-input-ex-04-menu-with-subheadings-solution}\n: Menu with subheadings\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\n  ui = fluidPage(\n    selectInput(\"state\", \"Choose a state:\",\n      list(`East Coast` = list(\"NY\", \"NJ\", \"CT\"),\n           `West Coast` = list(\"WA\", \"OR\", \"CA\"),\n           `Midwest` = list(\"MN\", \"WI\", \"IA\")\n           )\n    )\n  )\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Solution (Shiny)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-02-input-ex-04-menu-with-subheadings-shiny}\n: Menu with subheadings\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 300\n\nlibrary(shiny)\n\n  ui = fluidPage(\n    selectInput(\"state\", \"Choose a state:\",\n      list(`East Coast` = list(\"NY\", \"NJ\", \"CT\"),\n           `West Coast` = list(\"WA\", \"OR\", \"CA\"),\n           `Midwest` = list(\"MN\", \"WI\", \"IA\")\n           )\n    )\n  )\n\nserver <- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n\n\n```\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n## Outputs\n\nOutputs in the UI create placeholders that are later filled by the server function. Like inputs, outputs take a unique ID as their first argument: if your UI specification creates an output with ID `\"plot\"`, you’ll access it in the server function with `output$plot`.\n\n**Each output function on the front end is coupled with a render function in the back end.** There are three main types of output, corresponding to the three things you usually include in a report: text, tables, and plots. The following sections show you the basics of the output functions on the front end, along with the corresponding render functions in the back end.\n\n### Text\n\nOutput regular text with `shiny::textOutput()` and fixed code and console output with `shiny::verbatimTextOutput()`.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-text-output-examples}\n: Text output examples\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code1\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-text-output-examples-code1}\n: Text output examples\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n  textOutput(\"text\"),\n  verbatimTextOutput(\"code\")\n)\nserver <- function(input, output, session) {\n  output$text <- renderText({ \n    \"Hello friend!\" \n  })\n  output$code <- renderPrint({ \n    summary(1:10) \n  })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n***\n\nNote that the `{}` are only required in render functions if you need to run multiple lines of code. As you’ll learn shortly, you should do as little computation in your render functions as possible, which means you can often omit them.\n::::\n:::::\n\n###### Code2\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-text-output-examples-code2}\n: Text output examples\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n  textOutput(\"text\"),\n  verbatimTextOutput(\"code\")\n)\nserver <- function(input, output, session) {\n  output$text <- renderText(\"Hello friend!\")\n  output$code <- renderPrint(summary(1:10))\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n***\n\nHere’s what the server function would look like if written more compactly.\n\n::::\n:::::\n\n###### Shiny1\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-text-output-examples-shiny1}\n: Text output examples\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 150\n\nui <- fluidPage(\n  textOutput(\"text\"),\n  verbatimTextOutput(\"code\")\n)\nserver <- function(input, output, session) {\n  output$text <- renderText({ \n    \"Hello friend!\" \n  })\n  output$code <- renderPrint({ \n    summary(1:10) \n  })\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\n###### Shiny2\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-text-output-examples-shiny2}\n: Text output examples\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 150\n\nui <- fluidPage(\n  textOutput(\"text\"),\n  verbatimTextOutput(\"code\")\n)\n\nserver <- function(input, output, session) {\n  output$text <- renderText(\"Hello friend!\")\n  output$code <- renderPrint(summary(1:10))\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\nNote that there are two render functions which behave slightly differently:\n\n- `renderText()` combines the result into a single string, and is usually paired with `textOutput()`\n- `renderPrint()` prints the result, as if you were in an R console, and is usually paired with `verbatimTextOutput()`.\nWe can see the difference with a toy app:\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-diff-renderText-renderPrint}\n: Difference between `renderText()` and `renderPrint()`\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-diff-renderText-renderPrint-code}\n: Difference between `renderText()` and `renderPrint()`\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n  textOutput(\"text\"),\n  verbatimTextOutput(\"print\")\n)\nserver <- function(input, output, session) {\n  output$text <- renderText(\"hello!\")\n  output$print <- renderPrint(\"hello!\")\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-diff-renderText-renderPrint-shiny}\n: Difference between `renderText()` and `renderPrint()`\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 100\n\nlibrary(shiny)\n\nui <- fluidPage(\n  textOutput(\"text\"),\n  verbatimTextOutput(\"print\")\n)\nserver <- function(input, output, session) {\n  output$text <- renderText(\"hello!\")\n  output$print <- renderPrint(\"hello!\")\n}\n\nshinyApp(ui, server)\n```\n\n***\n\nThis is equivalent to the difference between `cat()` and `print()` in base R.\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n### Tables\n\nThere are two options for displaying data frames in tables:\n\n- `tableOutput()` and `renderTable()` render a static table of data, showing all the data at once.\n- `dataTableOutput()` and `renderDataTable()` render a dynamic table, showing a fixed number of rows along with controls to change which rows are visible.\n\n`tableOutput()` is most useful for small, fixed summaries (e.g. model coefficients); `dataTableOutput()` is most appropriate if you want to expose a complete data frame to the user. \n\nIf you want greater control over the output of `dataTableOutput()`, I highly recommend the {**reactable**} package by Greg Lin [@reactable].\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-table-output}\n: Table output examples\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code1\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-table-output-examples-code1}\n: Table output examples\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n  tableOutput(\"static\"),\n  dataTableOutput(\"dynamic\")\n)\n\nserver <- function(input, output, session) {\n  output$static <- renderTable(head(mtcars))\n  output$dynamic <- renderDataTable(mtcars, options = list(pageLength = 5))\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n`shiny::renderDataTable()` is deprecated as of shiny 1.8.1.\nPlease use `DT::renderDT()` instead.\nSince you have a suitable version of DT (>= v0.32.1), `shiny::renderDataTable()` will automatically use `DT::renderDT()` under-the-hood.\nIf this happens to break your app, set `options(shiny.legacy.datatable = TRUE)` to get the legacy datatable implementation (or `FALSE` to squelch this message).\nSee <https://rstudio.github.io/DT/shiny.html> for more information.\n\n::: {.callout-warning}\nThere are no warning/error messages in the {**shinylive-r**} mode. For debugging purposes it is necessary to use the standard `app.R` file approach.\n:::\n\n::::\n:::::\n\n###### Code2\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-table-output-examples-code2}\n: Table output examples\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n    tableOutput(\"static\"),\n    DT::DTOutput(\"dynamic\")\n)\n\nserver <- function(input, output, session) {\n    output$static <- renderTable(head(mtcars))\n    output$dynamic <- DT::renderDT(mtcars, options = list(pageLength = 5))\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\nIf I had used `library(DT)` then I wouldn't needed `DT::` in front of the {**DT**} functions.\n\n::: {.callout-note }\nBut there is an important difference: Using the `library(<package-name>)` function downloads several packages via <https://repo.r-wasm.org/> ([The WebR binary R package repository](https://repo.r-wasm.org/) contains more than 15,000 packages that have been built for WebAssembly and are available for download from this repository). I think therefore that is generally better to use the `<package-name>::` mode if there are used only some functions from the package in question.\n:::\n\n\n::::\n:::::\n\n\n###### Shiny1\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-table-output-examples-shiny1}\n: Table output examples\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 700\n\nlibrary(shiny)\n\nui <- fluidPage(\n  tableOutput(\"static\"),\n  dataTableOutput(\"dynamic\")\n)\n\nserver <- function(input, output, session) {\n  output$static <- renderTable(head(mtcars))\n  output$dynamic <- renderDataTable(mtcars, options = list(pageLength = 5))\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\n\n\n###### Shiny2\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-table-output-examples-shiny2}\n: Table output examples\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 700\n\nlibrary(shiny)\nlibrary(DT)\n\nui <- fluidPage(\n    tableOutput(\"static\"),\n    DTOutput(\"dynamic\")\n)\n\nserver <- function(input, output, session) {\n    output$static <- renderTable(head(mtcars))\n    output$dynamic <- renderDT(mtcars, options = list(pageLength = 5))\n}\n\nshinyApp(ui, server)\n\n```\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\n\n\n\n### Plots {#sec-02-plots}\n\nYou can display any type of R graphic (base, {**ggplot2**}, or otherwise) with `plotOutput()` and `renderPlot()`.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-output-plots}\n: Plot output example\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-output-plot-example-code}\n: Plot output example\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n    plotOutput(\"plot1\", height = \"400px\", width = \"400px\"),\n    plotOutput(\"plot2\")\n)\n\nserver <- function(input, output, session) {\n    output$plot1 <- renderPlot(plot(1:5), res = 96)\n    output$plot2 <- renderPlot(plot(1:5), res = 96)\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-output-plot-example-shiny}\n: Plot output example\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 800\n\nlibrary(shiny)\n\nui <- fluidPage(\n    plotOutput(\"plot1\", height = \"400px\", width = \"400px\"),\n    plotOutput(\"plot2\")\n)\n\nserver <- function(input, output, session) {\n    output$plot1 <- renderPlot(plot(1:5), res = 96)\n    output$plot2 <- renderPlot(plot(1:5), res = 96)\n}\n\nshinyApp(ui, server)\n \n\n\n```\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\nBy default, `plotOutput()` will take up the full width of its container (more on that shortly), and will be 400 pixels high. You can override these defaults with the `height` and `width` arguments. We recommend always setting `res = 96` as that will make your Shiny plots match what you see in RStudio as closely as possible.\n\nPlots are special because they are outputs that can also act as inputs. `plotOutput()` has a number of arguments like `click`, `dblclick`, and `hover`. If you pass these a string, like `click = \"plot_click\"`, they’ll create a reactive input (`input$plot_click`) that you can use to handle user interaction on the plot, e.g. clicking on the plot. We’ll come back to interactive plots in Shiny in @XXX_7.\n\n\n### Downloads\n\nYou can let the user download a file with `downloadButton()` or `downloadLink()`. These require new techniques in the server function, so we’ll come back to that in @XXX_9.\n\n### Exercises\n\n#### Render function to pair\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-02-output-ex-01-render-function-to-pair}\n: Render function to pair\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\nWhich of `textOutput()` and `verbatimTextOutput()` should each of the following render functions be paired with?\n\na) `renderPrint(summary(mtcars))`\nb) `renderText(\"Good morning!\")`\nc) `renderPrint(t.test(1:5, 2:6))`\nd) `renderText(str(lm(mpg ~ wt, data = mtcars)))`\n\n\n###### Solution (Code)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-02-input-ex-01-label-as-placeholder-solution}\n: Use label as placeholder\n::::::\n:::\n::::{.my-solution-container}\n\nWhich of `textOutput()` and `verbatimTextOutput()` should each of the following render functions be paired with?\n\n\na) `renderPrint(summary(mtcars))`: `verbatimTextOutput()`\nb) `renderText(\"Good morning!\")`: `textOutput()`\nc) `renderPrint(t.test(1:5, 2:6))`: `verbatimTextOutput()`\nd) `renderText(str(lm(mpg ~ wt, data = mtcars)))`: `textOutput()`\n\n::::\n:::::\n\n\n\n:::\n\n::::\n:::::\n\n#### Plot dimensions and `alt`-tag\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-02-output-ex-02-plot-dimensions-alt-tag}\n: Change plot dimensions and add `alt`-tag\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\n\nRe-create the Shiny app from @sec-02-plots, this time setting height to 300px and width to 700px. Set the plot `“alt”` text so that a visually impaired user can tell that its a scatterplot of five random numbers.\n\n\n###### Solution (Code)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-02-output-ex-02-plot-dimensions-alt-tag-solution}\n: Plot dimensions and `alt`-tag\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n    plotOutput(\"plot\", height = \"300px\", width = \"700px\"),\n)\n\nserver <- function(input, output, session) {\n    output$plot <- renderPlot(\n        plot(1:5), \n        res = 96,\n        alt = \"Scatterplot of five random numbers\")\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Solution (Shiny)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-02-input-ex-02-plot-dimension-alt-tag-solution}\n: Plot dimensions and `alt`-tag\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n\nlibrary(shiny)\n\nui <- fluidPage(\n    plotOutput(\"plot\", height = \"300px\", width = \"700px\"),\n)\n\nserver <- function(input, output, session) {\n    output$plot <- renderPlot(\n        plot(1:5), \n        res = 96,\n        alt = \"Scatterplot of five random numbers\")\n}\n\nshinyApp(ui, server)\n\n```\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n#### `DT::renderDT()` options\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-02-input-ex-03-renderDT-options}\n: `DT::renderDT()` options\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge Code\n\n\nUpdate the options in the call to `DT::renderDT()` below so that the data is displayed, but all other controls are suppressed (i.e., remove the search, ordering, and filtering commands). You’ll need to read [Using DT in shiny](https://rstudio.github.io/DT/shiny.html) and review the more complex [DT options](https://datatables.net/reference/option/).\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02--output-ex-03-renderDT-options-challenge}\n: Standard `DT::renderDT()` options\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n  DT::DTOutput(\"table\")\n)\n\nserver <- function(input, output, session) {\n  output$table <- DT::renderDT(mtcars, options = list(pageLength = 5))\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n###### Challenge Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02--output-ex-03-renderDT-options-challenge}\n: Standard `DT::renderDT()` options\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\nlibrary(shiny)\n\nui <- fluidPage(\n  DT::DTOutput(\"table\")\n)\n\nserver <- function(input, output, session) {\n  output$table <- DT::renderDT(mtcars, options = list(pageLength = 5))\n}\n\nshinyApp(ui, server)\n\n\n```\n\n::::\n:::::\n\n\n###### Solution (Code)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-02-output-ex-03-renderDT-options-solution-code}\n: Change `DT::renderDT()` options\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n    DT::DTOutput(\"table\")\n)\n\nserver <- function(input, output, session) {\n    output$table <- DT::renderDT(\n        mtcars,\n        options = list(\n            pageLength = 5,\n            searching = FALSE,\n            ordering = FALSE,\n            lengthChange = FALSE\n        )\n    )\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Solution (Shiny)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-02-output-ex-03-renderDT-options-solution-shiny}\n: Change `DT::renderDT()` options\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\nlibrary(shiny)\n\nui <- fluidPage(\n    DT::DTOutput(\"table\")\n)\n\nserver <- function(input, output, session) {\n    output$table <- DT::renderDT(\n        mtcars,\n        options = list(\n            pageLength = 5,\n            searching = FALSE,\n            ordering = FALSE,\n            lengthChange = FALSE\n        )\n    )\n}\n\nshinyApp(ui, server)\n```\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\n#### Use {reactable}\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-02-output-ex-04-use-reactable}\n: Use reactable\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\n\nAlternatively, read up on {**reactable**}, and convert the @sol-02-output-ex-03-renderDT-options-solution-code to use {**reactable**} instead.\n\n\n###### Solution (Code)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-02-output-ex-04-use-reactable-solution-code}\n: Menu with subheadings\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n    reactable::reactableOutput(\"table\")\n)\n\nserver <- function(input, output, session) {\n    output$table <- reactable::renderReactable({\n        reactable::reactable(mtcars)\n    })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n::::\n:::::\n\n\n###### Solution (Shiny)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-02-output-ex-04-use-reactable-solution-shiny}\n: Use {**reactable**}\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 700\n\nlibrary(shiny)\n\nui <- fluidPage(\n    reactable::reactableOutput(\"table\")\n)\n\nserver <- function(input, output, session) {\n    output$table <- reactable::renderReactable({\n        reactable::reactable(mtcars)\n    })\n}\n\nshinyApp(ui, server)\n\n\n\n```\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\n## Summary\n\nThis chapter has introduced the major input and output functions that make up the front end of a Shiny app. This was a big info dump, so don’t expect to remember everything after a single read. Instead, come back to this chapter when you’re looking for a specific component: you can quickly scan the figures, and then find the code you need.\n\nIn the next chapter, we’ll move on to the back end of a Shiny app: the R code that makes your user interface come to life.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}