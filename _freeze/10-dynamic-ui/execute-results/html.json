{
  "hash": "8c53b4e0c89f51c0fd35f0c52f197ae8",
  "result": {
    "engine": "knitr",
    "markdown": "# Dynamic UI {#sec-chap10}\n\n\n\n\n## Table of content for chapter 10 {.unnumbered}\n\n::::: {#obj-chap03}\n:::: {.my-objectives}\n::: {.my-objectives-header}\nChapter section list\n:::\n\n::: {.my-objectives-container}\n\n\n:::\n::::\n:::::\n\nThere are three key techniques for creating dynamic user interfaces:\n\n- Using the update family of functions to modify parameters of input controls.\n- Using `tabsetPanel()` to conditionally show and hide parts of the user interface.\n- Using `uiOutput()` and `renderUI()` to generate selected parts of the user interface with code.\n\n\n## Updating inputs\n\nWe’ll begin with a simple technique that allows you to modify an input after it has been created: the update family of functions. [Every input control]{.mark}, e.g. `textInput()`, [is paired with an **update function**]{.mark}, e.g. `updateTextInput()`, that allows you to modify the control after it has been created.\n\nThe key idea to modify an input is to use `observeEvent()` to trigger the corresponding update<whatever> function whenever the input changes. (For the `observeEvent()` function see @sec-03-observers and @XXX15.3.)\n\n::: {.column-page-inset}\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-10-updating-inputs-intro}\n: Updating the slider whenever the the minimum or maximum input changes\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n#| components: [editor, viewer]\n\n## file: app.R\nlibrary(shiny)\n\nui <- fluidPage(\n    numericInput(\"min\", \"Minimum\", 0),\n    numericInput(\"max\", \"Maximum\", 3),\n    sliderInput(\"n\", \"n\", min = 0, max = 3, value = 1)\n)\nserver <- function(input, output, session) {\n    observeEvent(input$min, {\n        updateSliderInput(inputId = \"n\", min = input$min)\n    })\n    observeEvent(input$max, {\n        updateSliderInput(inputId = \"n\", max = input$max)\n    })\n}\n\nshinyApp(ui, server)\n\n```\n\n\n\n::::\n:::::\n\n::: \n\n### Simple uses\n\n#### Reset button\n\n\nThe simplest uses of the update functions are to provide small conveniences for the user. For example, maybe you want to make it easy to reset parameters back to their initial value.\n\n::: {.column-page-inset}\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-10-updating-with-reset-button}\n: Updating controls with reset button\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n#| components: [editor, viewer]\n\n## file: app.R\n\nui <- fluidPage(\n    sliderInput(\"x1\", \"x1\", 0, min = -10, max = 10),\n    sliderInput(\"x2\", \"x2\", 0, min = -10, max = 10),\n    sliderInput(\"x3\", \"x3\", 0, min = -10, max = 10),\n    actionButton(\"reset\", \"Reset\")\n)\n\nserver <- function(input, output, session) {\n    observeEvent(input$reset, {\n        updateSliderInput(inputId = \"x1\", value = 0)\n        updateSliderInput(inputId = \"x2\", value = 0)\n        updateSliderInput(inputId = \"x3\", value = 0)\n    })\n}\n\nshinyApp(ui, server)\n\n```\n::::\n:::::\n\n::: \n\n\n### Button changed functionality\n\nA similar application is to tweak the text of an action button so you know exactly what it’s going to do.\n\n\n::: {.column-page-inset}\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-10-updating-vutton-text}\n: Updating button text if it has changed functionality\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 400\n#| components: [editor, viewer]\n\n## file: app.R\nlibrary(shiny)\n\nui <- fluidPage(\n    numericInput(\"n\", \"Simulations\", 10),\n    actionButton(\"simulate\", \"Simulate\")\n)\n\nserver <- function(input, output, session) {\n    observeEvent(input$n, {\n        label <- paste0(\"Simulate \", input$n, \" times\")\n        updateActionButton(inputId = \"simulate\", label = label)\n    })\n}\n\nshinyApp(ui, server)\n\n```\n::::\n:::::\n\n::: \n\n### Hierarchical select boxes {#sec-10-hierarchical-selct-boxes}\n\nA more complicated, but particularly useful, application of the update functions is to allow interactive drill down across multiple categories. I’ll illustrate their usage with some imaginary data for a sales dashboard.\n\n:::::{.my-resource}\n:::{.my-resource-header}\n:::::: {#lem-10-kaggle}\n: Kaggle --- An online community platform for data scientists and machine learning enthusiasts\n::::::\n:::\n::::{.my-resource-container}\nThis section uses [Sample Sales Data](https://www.kaggle.com/datasets/kyanyoga/sample-sales-data), a well-documented imaginary dataset provided by <a class='glossary' title='Kaggle is one of the largest hosting platforms used by data scientists and machine learning enthusiasts globally. It allows users to collaborate with other users, find and publish datasets, use GPU integrated notebooks, and compete with other data scientists to solve data science challenges. Founded in 2010 by Anthony Goldbloom and Jeremy Howard, Kaggle was acquired by Google in 2017.'>Kaggle</a> for education, training and research. To download the dataset from Kaggle you have to register. But you can also download the Sample Sales Data as <a class='glossary' title='Text files where the values are separated with commas (Comma Separated Values = CSV). These files have the file extension .csv'>.csv</a> file from the [GitHub repo of Mastering Shiny](https://github.com/hadley/mastering-shiny/raw/refs/heads/main/sales-dashboard/sales_data_sample.csv) or alternatively my own version of the dataset.\n\n***\n\n[Kaggle](https://www.kaggle.com/) is one of the largest hosting platforms used by data scientists and machine learning enthusiasts globally. It allows users to collaborate with other users, find and publish datasets, use GPU integrated notebooks, and compete with other data scientists to solve data science challenges.  \n\nFounded in 2010 by [Anthony Goldbloom](https://en.wikipedia.org/wiki/Anthony_Goldbloom) and [Jeremy Howard](https://en.wikipedia.org/wiki/Jeremy_Howard_(entrepreneur)), Kaggle was acquired by Google in 2017. \n::::\n:::::\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-10-load-sales-dataset}\n: Load and display sales dataset\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nsales <- vroom::vroom(\"data/sales_data_sample.csv\", col_types = list(), na = \"\")\nsales  |> \n  dplyr::select(TERRITORY, CUSTOMERNAME, ORDERNUMBER, dplyr::everything()) |> \n  dplyr::arrange(ORDERNUMBER)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 2,823 × 25\n#>    TERRITORY CUSTOMERNAME  ORDERNUMBER QUANTITYORDERED PRICEEACH ORDERLINENUMBER\n#>    <chr>     <chr>               <dbl>           <dbl>     <dbl>           <dbl>\n#>  1 NA        Online Dieca…       10100              30     100                 3\n#>  2 NA        Online Dieca…       10100              50      67.8               2\n#>  3 NA        Online Dieca…       10100              22      86.5               4\n#>  4 NA        Online Dieca…       10100              49      34.5               1\n#>  5 EMEA      Blauer See A…       10101              25     100                 4\n#>  6 EMEA      Blauer See A…       10101              26     100                 1\n#>  7 EMEA      Blauer See A…       10101              45      31.2               3\n#>  8 EMEA      Blauer See A…       10101              46      53.8               2\n#>  9 NA        Vitachrome I…       10102              39     100                 2\n#> 10 NA        Vitachrome I…       10102              41      50.1               1\n#> # ℹ 2,813 more rows\n#> # ℹ 19 more variables: SALES <dbl>, ORDERDATE <chr>, STATUS <chr>,\n#> #   QTR_ID <dbl>, MONTH_ID <dbl>, YEAR_ID <dbl>, PRODUCTLINE <chr>, MSRP <dbl>,\n#> #   PRODUCTCODE <chr>, PHONE <chr>, ADDRESSLINE1 <chr>, ADDRESSLINE2 <chr>,\n#> #   CITY <chr>, STATE <chr>, POSTALCODE <chr>, COUNTRY <chr>,\n#> #   CONTACTLASTNAME <chr>, CONTACTFIRSTNAME <chr>, DEALSIZE <chr>\n```\n\n\n:::\n:::\n\n\n::::\n:::::\n\nFor this demo, I’m going to focus on a natural hierarchy in the data:\n\n- Each territory contains customers.\n- Each customer has multiple orders.\n- Each order contains rows.\n\nI want to create a user interface where you can:\n\n- Select a territory to see all customers.\n- Select a customer to see all orders.\n- Select an order to see the underlying rows.\n\nThe essence of the UI is simple: I’ll create three select boxes and one output table. The choices for the `customername` and `ordernumber` select boxes will be dynamically generated, so I set `choices = NULL`.\n\nIn the server function, there is th following top-down procedure to follow:\n\n:::::{.my-procedure}\n:::{.my-procedure-header}\n:::::: {#prp-10-replicate-hierarchical-data-structure}\n: Replicating the hierarchical data structure in the server function\n::::::\n:::\n::::{.my-procedure-container}\n\n1. Create a reactive, `territory()`, that contains the rows from sales that match the selected territory.\n2. Whenever `territory()` changes, update the list of choices in the `input$customername` select box.\n3. Create another reactive, `customer()`, that contains the rows from `territory()` that match the selected customer.\n4. Whenever `customer()` changes, update the list of choices in the `input$ordernumber` select box.\n5. Display the selected orders in `output$data`.\n\n::::\n:::::\n\n:::{.column-page-inset}\n\n:::::{.my-example}\n:::{.my-example-header}\n:::::: {#exm-10-updating-nested}\n: Hierarchical select boxes\n::::::\n:::\n::::{.my-example-container}\n\n::: {.panel-tabset}\n\n###### First take\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-10-updating-nested1}\n: Hierarchical select boxes: Small demo\n::::::\n:::\n::::{.my-r-code-container}\n::: {#lst-10-updating-nested1}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 550\n#| components: [editor, viewer]\n\n## file: app.R\nlibrary(shiny)\n\nui <- fluidPage(\n    fileInput(\"upload\", \"Upload File\", accept = \".csv\"),\n    selectInput(\"territory\", \"Territory\", choices = NULL),\n    selectInput(\"customername\", \"Customer\", choices = NULL),\n    selectInput(\"ordernumber\", \"Order number\", choices = NULL),\n    tableOutput(\"data\")\n)\n\nserver <- function(input, output, session) {\n\n    sales <- reactiveVal()\n\n    observeEvent(input$upload, {\n        df <- vroom::vroom(input$upload$datapath, delim = \",\", col_types = list(), na = \"\")\n        sales(df)\n        updateSelectInput(inputId = \"territory\", choices = unique(sales()$TERRITORY))\n         })\n\n    territory <- reactive({\n        req(input$upload)\n        dplyr::filter(sales(), TERRITORY == input$territory)\n    })\n\n    observeEvent(territory(), {\n        choices <- unique(territory()$CUSTOMERNAME)\n        updateSelectInput(inputId = \"customername\", choices = choices)\n    })\n\n    customer <- reactive({\n        req(input$customername)\n        dplyr::filter(territory(), CUSTOMERNAME == input$customername)\n    })\n    observeEvent(customer(), {\n        choices <- unique(customer()$ORDERNUMBER)\n        updateSelectInput(inputId = \"ordernumber\", choices = choices)\n    })\n\n    output$data <- renderTable({\n        req(input$ordernumber)\n        customer()  |>\n            dplyr::filter(ORDERNUMBER == input$ordernumber)  |>\n            dplyr::select(QUANTITYORDERED, PRICEEACH, PRODUCTCODE)\n    })\n}\n\nshinyApp(ui, server)\n\n```\n\nSmall demo of hierarchical select boxes\n:::\n\n::::\n:::::\n\n\n###### Improved demo\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-10-updating-nested2}\n: Hierarchical select boxes: More fleshed out\n::::::\n:::\n::::{.my-r-code-container}\n::: {#lst-10-updating-nested2}\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 550\n#| components: [editor, viewer]\n\n\n## file: app.R\nlibrary(shiny)\n\nui <- fluidPage(\n    titlePanel(\"Sales Dashboard\"),\n    sidebarLayout(\n        sidebarPanel(\n            fileInput(\"upload\", \"Upload File\", accept = \".csv\"),\n            selectInput(\"territory\", \"Territory\", choices = NULL),\n            selectInput(\"customername\", \"Customer\", choices = NULL),\n            selectInput(\"ordernumber\", \"Order number\", choices = NULL, size = 5, selectize = FALSE),\n        ),\n        mainPanel(\n            uiOutput(\"customer\"),\n            tableOutput(\"data\")\n        )\n    )\n)\nserver <- function(input, output, session) {\n    sales <- reactiveVal()\n\n    observeEvent(input$upload, {\n        df <- vroom::vroom(input$upload$datapath, delim = \",\", col_types = list(), na = \"\")\n        sales(df)\n        updateSelectInput(inputId = \"territory\", choices = unique(sales()$TERRITORY))\n    })\n\n    territory <- reactive({\n        req(input$upload)\n        dplyr::filter(sales(), TERRITORY == input$territory)\n    })\n    customer <- reactive({\n        req(input$customername)\n        dplyr::filter(territory(), CUSTOMERNAME == input$customername)\n    })\n\n    output$customer <- renderUI({\n        row <- customer()[1, ]\n        tags$div(\n            class = \"well\",\n            tags$p(tags$strong(\"Name: \"), row$CUSTOMERNAME),\n            tags$p(tags$strong(\"Phone: \"), row$PHONE),\n            tags$p(tags$strong(\"Contact: \"), row$CONTACTFIRSTNAME, \" \", row$CONTACTLASTNAME)\n        )\n    })\n\n    order <- reactive({\n        req(input$ordernumber)\n        customer() |>\n            dplyr::filter(ORDERNUMBER == input$ordernumber)  |>\n            dplyr::arrange(ORDERLINENUMBER)  |>\n            dplyr::select(PRODUCTLINE, QUANTITYORDERED, PRICEEACH, SALES, STATUS)\n    })\n\n    output$data <- renderTable(order())\n\n    observeEvent(territory(), {\n        updateSelectInput(session, \"customername\", choices = unique(territory()$CUSTOMERNAME), selected = character())\n    })\n    observeEvent(customer(), {\n        updateSelectInput(session, \"ordernumber\", choices = unique(customer()$ORDERNUMBER))\n    })\n\n}\nshinyApp(ui, server)\n\n\n```\n\nHierarchical select boxes: more fleshed out demo\n:::\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n:::\n\n::: {.callout-warning #wrn-10-upating-nested}\n###### Couldn't load data without user input\n\nTo get a version that works with Shiny and shinylive-r at the same time, I had to provide `fileInput()`. This is suboptimal as the user has to find and select the file to get the intended data for playing around.\n\nIt was easy to find a solution for Shiny: Just load the data before the ui/server part into an R object and then reference it from the `server()` function. I couldn’t manage the same result for `shinylive-r`. Local references, relative URL and non-HTTPS URL generate error. The only possible way seems to doanload the data via HTTPS. I tried but didn’t succeed. I asked for help via the [Posit Community](https://forum.posit.co/t/shinylive-in-quarto-document-with-reactive-data-source/204237) and are currently waiting for answers.\n\nA workaround was to provide a file upload control. But even to create a workable demo took me hours. It was a bitter experience to learn that I still didn't understand quite well how reactives work. As the debugger `browser()` did not work, it was finally for me quite helpful to install `print()` outputs in **every** reactive function to see what happens. In the end I solved this problem with three important changes:\n\n1. Creating a reactive value with `sales <- reactiveVal()`.\n2. Adding an `observeEvent()` function which fulfilled several tasks:\n    - Loading the data after `fileInput()` was active.  \n    - Assigning the file to the reactive value `sales`.\n    - Updating with the data the choice of the territory `selectInput()` function. (Previously I had to set the UI choices for territory to NULL to prevent an error because the data was not available at start up.)\n3. The reference to the previous `sales` object had to be changed to the reactive function `sales()`. Additional had I to add `req(input$upload)` to prevent that the reactive territory function is called immediately after start up without available data.\n\n\n:::\n\n\n## Glossary Entries {#unnumbered}\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> term </th>\n   <th style=\"text-align:left;\"> definition </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> CSV </td>\n   <td style=\"text-align:left;\"> Text files where the values are separated with commas (Comma Separated Values = CSV). These files have the file extension .csv </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Kaggle </td>\n   <td style=\"text-align:left;\"> Kaggle is one of the largest hosting platforms used by data scientists and machine learning enthusiasts globally. It allows users to collaborate with other users, find and publish datasets, use GPU integrated notebooks, and compete with other data scientists to solve data science challenges. Founded in 2010 by Anthony Goldbloom and Jeremy Howard, Kaggle was acquired by Google in 2017. </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n## Session Info {.unnumbered}\n\n::: my-r-code\n::: my-r-code-header\nSession Info\n:::\n\n::: my-r-code-container\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> ─ Session info ───────────────────────────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.5.1 (2025-06-13)\n#>  os       macOS Sequoia 15.5\n#>  system   aarch64, darwin20\n#>  ui       X11\n#>  language (EN)\n#>  collate  en_US.UTF-8\n#>  ctype    en_US.UTF-8\n#>  tz       Europe/Vienna\n#>  date     2025-07-04\n#>  pandoc   3.7.0.2 @ /opt/homebrew/bin/ (via rmarkdown)\n#>  quarto   1.8.4 @ /usr/local/bin/quarto\n#> \n#> ─ Packages ───────────────────────────────────────────────────────────────────\n#>  package      * version    date (UTC) lib source\n#>  archive        1.1.12     2025-03-20 [1] CRAN (R 4.5.0)\n#>  bit            4.6.0      2025-03-06 [1] CRAN (R 4.5.0)\n#>  bit64          4.6.0-1    2025-01-16 [1] CRAN (R 4.5.0)\n#>  cli            3.6.5      2025-04-23 [1] CRAN (R 4.5.0)\n#>  commonmark     1.9.5      2025-03-17 [1] CRAN (R 4.5.0)\n#>  crayon         1.5.3      2024-06-20 [1] CRAN (R 4.5.0)\n#>  curl           6.4.0      2025-06-22 [1] CRAN (R 4.5.0)\n#>  dichromat      2.0-0.1    2022-05-02 [1] CRAN (R 4.5.0)\n#>  digest         0.6.37     2024-08-19 [1] CRAN (R 4.5.0)\n#>  dplyr          1.1.4      2023-11-17 [1] CRAN (R 4.5.0)\n#>  evaluate       1.0.4      2025-06-18 [1] CRAN (R 4.5.0)\n#>  farver         2.1.2      2024-05-13 [1] CRAN (R 4.5.0)\n#>  fastmap        1.2.0      2024-05-15 [1] CRAN (R 4.5.0)\n#>  generics       0.1.4      2025-05-09 [1] CRAN (R 4.5.0)\n#>  glossary     * 1.0.0.9003 2025-06-08 [1] local\n#>  glue           1.8.0      2024-09-30 [1] CRAN (R 4.5.0)\n#>  htmltools      0.5.8.1    2024-04-04 [1] CRAN (R 4.5.0)\n#>  htmlwidgets    1.6.4      2023-12-06 [1] CRAN (R 4.5.0)\n#>  jsonlite       2.0.0      2025-03-27 [1] CRAN (R 4.5.0)\n#>  kableExtra     1.4.0      2024-01-24 [1] CRAN (R 4.5.0)\n#>  knitr          1.50       2025-03-16 [1] CRAN (R 4.5.0)\n#>  lifecycle      1.0.4      2023-11-07 [1] CRAN (R 4.5.0)\n#>  litedown       0.7        2025-04-08 [1] CRAN (R 4.5.0)\n#>  magrittr       2.0.3      2022-03-30 [1] CRAN (R 4.5.0)\n#>  markdown       2.0        2025-03-23 [1] CRAN (R 4.5.0)\n#>  pillar         1.10.2     2025-04-05 [1] CRAN (R 4.5.0)\n#>  pkgconfig      2.0.3      2019-09-22 [1] CRAN (R 4.5.0)\n#>  R6             2.6.1      2025-02-15 [1] CRAN (R 4.5.0)\n#>  RColorBrewer   1.1-3      2022-04-03 [1] CRAN (R 4.5.0)\n#>  rlang          1.1.6      2025-04-11 [1] CRAN (R 4.5.0)\n#>  rmarkdown      2.29       2024-11-04 [1] CRAN (R 4.5.0)\n#>  rstudioapi     0.17.1     2024-10-22 [1] CRAN (R 4.5.0)\n#>  rversions      2.1.2      2022-08-31 [1] CRAN (R 4.5.0)\n#>  scales         1.4.0      2025-04-24 [1] CRAN (R 4.5.0)\n#>  sessioninfo    1.2.3      2025-02-05 [1] CRAN (R 4.5.0)\n#>  stringi        1.8.7      2025-03-27 [1] CRAN (R 4.5.0)\n#>  stringr        1.5.1      2023-11-14 [1] CRAN (R 4.5.0)\n#>  svglite        2.2.1      2025-05-12 [1] CRAN (R 4.5.0)\n#>  systemfonts    1.2.3      2025-04-30 [1] CRAN (R 4.5.0)\n#>  textshaping    1.0.1      2025-05-01 [1] CRAN (R 4.5.0)\n#>  tibble         3.3.0      2025-06-08 [1] CRAN (R 4.5.0)\n#>  tidyselect     1.2.1      2024-03-11 [1] CRAN (R 4.5.0)\n#>  tzdb           0.5.0      2025-03-15 [1] CRAN (R 4.5.0)\n#>  utf8           1.2.6      2025-06-08 [1] CRAN (R 4.5.0)\n#>  vctrs          0.6.5      2023-12-01 [1] CRAN (R 4.5.0)\n#>  viridisLite    0.4.2      2023-05-02 [1] CRAN (R 4.5.0)\n#>  vroom          1.6.5      2023-12-05 [1] CRAN (R 4.5.0)\n#>  withr          3.0.2      2024-10-28 [1] CRAN (R 4.5.0)\n#>  xfun           0.52       2025-04-02 [1] CRAN (R 4.5.0)\n#>  xml2           1.3.8      2025-03-14 [1] CRAN (R 4.5.0)\n#>  yaml           2.3.10     2024-07-26 [1] CRAN (R 4.5.0)\n#> \n#>  [1] /Library/Frameworks/R.framework/Versions/4.5-arm64/library\n#>  [2] /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/library\n#>  * ── Packages attached to the search path.\n#> \n#> ──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n:::\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}