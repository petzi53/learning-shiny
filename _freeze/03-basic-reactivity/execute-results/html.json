{
  "hash": "3a6a60779ee737e22ac4496b4fdf96b1",
  "result": {
    "engine": "knitr",
    "markdown": "# Basic reactivity {#sec-chap03}\n\n\n\n\n## Introduction\n\n::::: {#obj-chap03}\n:::: {.my-objectives}\n::: {.my-objectives-header}\nChapter section list\n:::\n\nThis chapter will provide a gentle introduction to reactive programming, teaching you the basics of the most common reactive constructs you’ll use in Shiny apps.\n\n- Survey of the server function in @sec-03-server-function\n- Simplest form of reactivity in @sec-03-reactive-programming\n- How reactive expressions eliminate duplicated work in @sec-03-reactive-expressions\n- Controlling the time of the evaluation @sec-03-control-timing\n- Observers @sec-03-observers\n\n::: {.my-objectives-container}\n\n:::\n::::\n:::::\n\n## The server function {#sec-03-server-function}\n\n### Input\n\nThe `input` argument is a list-like object that contains all the input data sent from the browser, named according to the input ID. Unlike a typical list, `input` objects are read-only. If you attempt to modify an input inside the server function, you’ll get an error.\n\nThe error occurs because `input` reflects what’s happening in the browser, and the browser is Shiny’s “single source of truth”. If you could modify the value in R, you could introduce inconsistencies, where the input slider said one thing in the browser, and `input$count` said something different in R. That would make programming challenging! (Later, in @XXX_8, you’ll learn how to use functions like `shiny::updateNumericInput()` to modify the value in the browser, and then `input$count` will update accordingly.)\n\nOne more important thing about input: it’s selective about who is allowed to read it. To read from an `input`, you must be in a <a class='glossary' title='In Shiny, reactive contexts are essential for handling user inputs and updating outputs automatically. Reactive values can only be accessed within a reactive context, meaning they must be used inside functions like reactive(), observer(), or any render*() functions.'>reactive context</a> created by a function like `shiny::renderText()` or `shiny::reactive()`.\n\n### Output\n\n`output` is very similar to `input`: it’s also a list-like object named according to the output ID. The main difference is that you use it for sending output instead of receiving input. You always use the `output` object in concert with a `render` function.\n\nThe render function does two things:\n\n- It sets up a special reactive context that automatically tracks what inputs the output uses.\n- It converts the output of your R code into HTML suitable for display on a web page.\n\nLike the `input`, the `output` is picky about how you use it. You’ll get an error if:\n\n- You forget the render function.\n- You attempt to read from an output.\n\n\n## Reactive programming {#sec-03-reactive-programming}\n\nAn app is going to be pretty boring if it only has inputs or only has outputs. The real magic of Shiny happens when you have an app with both.\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-greeting-example}\n: Interactive greeting as an example for reactive programming\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {#lst-greeting-example}\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- shiny::fluidPage(\n  shiny::textInput(\"name\", \"What's your name?\"),\n  shiny::textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  output$greeting <- shiny::renderText({\n    paste0(\"Hello \", input$name, \"!\")\n  })\n}\n\nshiny::shinyApp(ui, server)\n```\n:::\n\n\n:::\n\n```{shinylive-r}\n#| standalone: true\n\n\nui <- shiny::fluidPage(\n  shiny::textInput(\"name\", \"What's your name?\"),\n  shiny::textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  output$greeting <- shiny::renderText({\n    paste0(\"Hello \", input$name, \"!\")\n  })\n}\n\nshiny::shinyApp(ui, server)\n```\n\nThis is the big idea in Shiny: you don’t need to tell an output when to update, because Shiny automatically figures it out for you.\n::::\n:::::\n\n::: {.callout-important}\nIt’s Shiny’s responsibility to decide when code is executed, not yours. Think of your app as providing Shiny with recipes, not giving it commands.\n:::\n\n\n\n\n### Imperative vs declarative programming\n\nThis difference between commands and recipes is one of the key differences between two important styles of programming:\n\n- In **imperative programming**, you issue a specific command and it’s carried out immediately. This is the style of programming you’re used to in your analysis scripts: you command R to load your data, transform it, visualise it, and save the results to disk.\n- In **declarative programming**, you express higher-level goals or describe important constraints, and rely on someone else to decide how and/or when to translate that into action. This is the style of programming you use in Shiny.\n\nWith imperative code you say “Make me a sandwich”. With declarative code you say “Ensure there is a sandwich in the refrigerator whenever I look inside of it”. Imperative code is assertive; declarative code is passive-aggressive.\n\n### Lazyness\n\nOne of the strengths of declarative programming in Shiny is that it allows apps to be extremely lazy. A Shiny app will only ever do the minimal amount of work needed to update the output controls that you can currently see. This laziness, however, comes with an important downside that you should be aware of.\n\n::: {.callout-important}\nIf you’re working on a Shiny app and you just can’t figure out why your code never gets run, double check that your UI and server functions are using the same identifiers.\n:::\n\n\n### The reactive graph\n\nShiny’s laziness has another important property. In most R code, you can understand the order of execution by reading the code from top to bottom. That doesn’t work in Shiny, because code is only run when needed. To understand the order of execution you need to instead look at the <a class='glossary' title='In Shiny, the reactive graph is a powerful tool for understanding how your app works. It shows how inputs and outputs are connected, allowing you to visualize the dependencies and execution order of your reactive expressions and render functions. This graph is particularly useful as your app becomes more complex, helping you to manage and debug the interdependencies between different components of your app. To visualize the reactive graph, you can use the reactlog package, which provides an interactive browser-based tool for visualizing reactive dependencies and execution in your application.'>reactive graph</a>, which describes how inputs and outputs are connected.\n\n![This is the reactive graph for @cnj-03-greeting-example. It shows how the inputs and outputs are connected](https://mastering-shiny.org/diagrams/basic-reactivity/graph-1b.png){#fig-03-01 \nfig-alt=\"The graph consists of two blocks titled 'name' and 'greeting'. They are connected horizontally by an arrow from left tot the right. The left 'name' block has a pike to the right which would fit into the bump of the 'greeting' block.\" fig-align=\"center\" \nwidth=\"8cm\"}\n\nThe reactive graph contains one symbol for every input and output, and we connect an input to an output whenever the output accesses the input. This graph tells you that greeting will need to be recomputed whenever name is changed. We’ll often describe this relationship as `greeting` has a <a class='glossary' title='In Shiny, reactive dependencies are automatically inferred by the framework, meaning that when you define a reactive expression, Shiny determines which inputs it depends on. For example, if you have a reactive expression b &lt;- reactive(a * 2), Shiny infers that b depends on a. This information is stored internally within the Shiny framework, but it is not directly accessible through standard functions. For more detailed control over dependencies, you might consider using isolate() to prevent certain parts of your code from being reactive, or using reactiveValues() to manage stateful objects that can be updated and accessed across different parts of your application.'>reactive dependency</a> on `name`.\n\nNote the graphical conventions we used for the inputs and outputs: the name input naturally fits into the greeting output.\n\n![The shapes used by the components of the reactive graph evoke the ways in which they connect.](https://mastering-shiny.org/diagrams/basic-reactivity/graph-1a.png){#fig-03-02 \nfig-alt=\"The graph consists of two blocks titled 'name' and 'greeting'. The left 'name' block has a pike to the right which fits into the bump of the 'greeting' block.\" fig-align=\"center\" \nwidth=\"35%\"}\n\nThe reactive graph is a powerful tool for understanding how your app works. As your app gets more complicated, it’s often useful to make a quick high-level sketch of the reactive graph to remind you how all the pieces fit together. Throughout this book we’ll show you the reactive graph to help understand how the examples work, and later on, in @XXX_14, you’ll learn how to use {**reactlog**} which will draw the graph for you.\n\n### Reactive expressions {#sec-03-reactive-expressions-sub}\n\nThere’s one more important component that you’ll see in the reactive graph: the reactive expression. We’ll come back to reactive expressions in detail very shortly; for now think of them as a tool that reduces duplication in your reactive code by introducing additional nodes into the reactive graph.\n\nWe don’t need a reactive expression in our very simple app, but I’ll add one anyway so you can see how it affects the reactive graph (see @fig-03-03).\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-greeting-example}\n: Interactive greeting as an example for reactive programming\n::::::\n:::\n::::{.my-r-code-container}\n\n:::{#lst-greeting-example2}\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- shiny::fluidPage(\n  shiny::textInput(\"name\", \"What's your name?\"),\n  shiny::textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  output$greeting <- shiny::renderText(string())\n  string <- shiny::reactive(paste0(\"Hello \", input$name, \"!\"))\n}\n\nshiny::shinyApp(ui, server)\n```\n:::\n\n\n:::\n\n```{shinylive-r}\n#| standalone: true\n\nui <- shiny::fluidPage(\n  shiny::textInput(\"name\", \"What's your name?\"),\n  shiny::textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  string <- shiny::reactive(paste0(\"Hello \", input$name, \"!\"))\n  output$greeting <- shiny::renderText(string())\n}\n\nshiny::shinyApp(ui, server)\n```\n\n***\n\nCompare the tiny difference in the server code with @lst-greeting-example.\n::::\n:::::\n\n\n\n![A reactive expression is drawn with angles on both sides because it connects inputs to outputs.](https://mastering-shiny.org/diagrams/basic-reactivity/graph-2b.png){#fig-03-03 \nfig-alt=\"The graph consists of three blocks titled 'name', 'string and 'greeting'. The blocks are connected by two arrows from left to the right. 'name' block has a pike to the right which fits into the bump of the 'string' block which itself has a bump fitting into the 'greeting' block.\" fig-align=\"center\" \nwidth=\"70%\"}\n\nReactive expressions take inputs and produce outputs so they have a shape that combines features of both inputs and outputs.\n\n### Execution order\n\nIt’s important to understand that the order in which your code runs is solely determined by the reactive graph. This is different from most R code where the execution order is determined by the order of lines. For example, we could flip the order of the two lines in our simple server function:\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-greeting-example}\n: Interactive greeting as an example for reactive programming\n::::::\n:::\n::::{.my-r-code-container}\n\n:::{#lst-greeting-example3}\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- shiny::fluidPage(\n  shiny::textInput(\"name\", \"What's your name?\"),\n  shiny::textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  string <- shiny::reactive(paste0(\"Hello \", input$name, \"!\"))\n  output$greeting <- shiny::renderText(string())\n}\n\nshiny::shinyApp(ui, server)\n```\n:::\n\n\n:::\n\n```{shinylive-r}\n#| standalone: true\n\nui <- shiny::fluidPage(\n  shiny::textInput(\"name\", \"What's your name?\"),\n  shiny::textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  output$greeting <- shiny::renderText(string())\n  string <- shiny::reactive(paste0(\"Hello \", input$name, \"!\"))\n}\n\nshiny::shinyApp(ui, server)\n```\n\n***\n\nAgain: Compare the tiny difference in the server code; this time with @lst-greeting-example2.\n::::\n:::::\n\n\n\nYou might think that this would yield an error because `output$greeting` refers to a reactive expression, string, that hasn’t been created yet. But remember Shiny is lazy, so that code is only run when the session starts, after string has been created.\n\nInstead, this code yields the same reactive graph as above, so the order in which the code is run is exactly the same. Organizing your code like this is confusing for humans, and best avoided. Instead, make sure that reactive expressions and outputs only refer to things defined above, not below. This will make your code easier to understand.\n\nThis concept is very important and different to most other R code, so I’ll say it again:\n\n::: {.callout-important}\nThe order in which reactive code is run is determined only by the reactive graph, not by its layout in the server function.\n:::\n\n### Exercises\n\n#### Find bugs\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-03-ex-01-find-bugs}\n: Find the bugs in the three server functions\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-ex-01-find-bugs-challenge}\n: Find the bugs in the three server functions\n::::::\n:::\n::::{.my-r-code-container}\n\nFix the simple errors found in each of the three server functions below. First try spotting the problem just by reading the code; then run the code to make sure you’ve fixed it.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\n\nserver1 <- function(input, output, server) {\n  input$greeting <- renderText(paste0(\"Hello \", name))\n}\n\nserver2 <- function(input, output, server) {\n  greeting <- paste0(\"Hello \", input$name)\n  output$greeting <- renderText(greeting)\n}\n\nserver3 <- function(input, output, server) {\n  output$greting <- paste0(\"Hello\", input$name)\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n::::\n:::::\n\n\n\n###### Solution (Code)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-ex-01-find-bugs-solution-code}\n: Show the bugs in the three server functions and add correct code\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {#lst-03-ex-01-find-bugs-solution-code}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\n\n# server1 <- function(input, output, server) {\n#   input$greeting <- renderText(paste0(\"Hello \", name))\n##### output$greeting instead of input$greeting #######\n# }\n# \n# server2 <- function(input, output, server) {\n#   greeting <- paste0(\"Hello \", input$name)\n##### assigning value directly not allowed ######\n#   output$greeting <- renderText(greeting)\n# }\n# \n# server3 <- function(input, output, server) {\n#   output$greting <- paste0(\"Hello\", input$name)\n##### missing 'e' in output$greting #######\n# }\n\n# correct code\nserver <- function(input, output, server) {\n    output$greeting <- renderText(paste0(\"Hello\", input$name))\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n:::\n::::\n:::::\n\n\n\n###### Solution (Shiny)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-03-ex-01-find-bugs-app-shiny}\n: Run @lst-03-ex-01-find-bugs-solution-code with correct code\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 100\n\nlibrary(shiny)\n\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\n\n# server1 <- function(input, output, server) {\n#   input$greeting <- renderText(paste0(\"Hello \", name))\n##### output$greeting instead of input$greeting #######\n# }\n# \n# server2 <- function(input, output, server) {\n#   greeting <- paste0(\"Hello \", input$name)\n##### assigning value directly not allowed ######\n#   output$greeting <- renderText(greeting)\n# }\n# \n# server3 <- function(input, output, server) {\n#   output$greting <- paste0(\"Hello\", input$name)\n##### missing 'e' in output$greting #######\n# }\n\n# correct code\nserver <- function(input, output, server) {\n    output$greeting <- renderText(paste0(\"Hello\", input$name))\n}\n\nshinyApp(ui, server)\n\n```\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n#### Draw reactive graphs\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-03-ex-02-draw-reactive-graphs}\n: Draw reactive graph for server functions\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-ex-02-find-bugs-challenge}\n: Draw reactive graph for server functions\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {#lst-draw-graphs-challenge}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nserver1 <- function(input, output, session) {\n  c <- reactive(input$a + input$b)\n  e <- reactive(c() + input$d)\n  output$f <- renderText(e())\n}\n\nserver2 <- function(input, output, session) {\n  x <- reactive(input$x1 + input$x2 + input$x3)\n  y <- reactive(input$y1 + input$y2)\n  output$z <- renderText(x() / y())\n}\n\nserver3 <- function(input, output, session) {\n  d <- reactive(c() ^ input$d)\n  a <- reactive(input$a * 10)\n  c <- reactive(b() / input$c)\n  b <- reactive(a() + input$b)\n}\n```\n:::\n\n\n:::\n::::\n:::::\n\n\n\n###### Solution (Graphs)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-ex-02-draw-graphs-solution}\n: Draw the graphs in the three server functions of @lst-draw-graphs-challenge\n::::::\n:::\n::::{.my-r-code-container}\n\nI've tried to find the solution myself and then I've compared my result with the [drawing graph solutions](https://mastering-shiny-solutions.org/basic-reactivity.html#solution-15) in Mastering Shiny Solutions [@ther4dsonlinelearningcommunity2023]\n\nThe first two examples of my trials coincide with Mastering Shiny Solutions. In the third example I had a chain of the inputs a,b,c,d and not — as in Mastering Shiny Solutions — a step by step chain where each input is depending of an input with the same name.\n\n***\n\n![Solution of the reactive graph: server 1](https://mastering-shiny-solutions.org/images/4.3.6.1-s1.png){#fig-03-ex-02-1 \nfig-alt=\"The graph consists of six blocks titled a-f. 'a' and 'b' are connected horizontally by an arrow from left tot the right with 'c'. The block 'e' gets its input (= arrows) by 'c' and 'd' and 'e' finally put its result into 'f'\" fig-align=\"center\" \nwidth=\"50%\"}\n\n***\n\n![Solution of the reactive graph: server 2](https://mastering-shiny-solutions.org/images/4.3.6.1-s2.png){#fig-03-ex-02-2 \nfig-alt=\"The graph consists of six blocks titled a-f. 'a' and 'b' are connected horizontally by an arrow from left tot the right with 'c'. The block 'e' gets its input (= arrows) by 'c' and 'd' and 'e' finally put its result into 'f'\" fig-align=\"center\" \nwidth=\"50%\"}\n\n***\n\n![Solution of the reactive graph: server 3](https://mastering-shiny-solutions.org/images/4.3.6.1-s3.png){#fig-03-ex-02-3 \nfig-alt=\"The graph consists of six blocks titled a-f. 'a' and 'b' are connected horizontally by an arrow from left tot the right with 'c'. The block 'e' gets its input (= arrows) by 'c' and 'd' and 'e' finally put its result into 'f'\" fig-align=\"center\" \nwidth=\"50%\"}\n\n\n::::\n:::::\n\nCompare the graphs with the server code snippets in @lst-draw-graphs-challenge.\n\n\n\n:::\n\n::::\n:::::\n\n#### Failed code snippet\n\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-03-ex-03-failed-code}\n: Why will this code fail?\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-ex-03-failed-code-challenge}\n: Why will this code snippet fail?\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {#lst-03-ex-03-failed-code-challenge}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nvar <- reactive(df[[input$var]])\nrange <- reactive(range(var(), na.rm = TRUE))\n```\n:::\n\n\n\nFailed code snippet\n:::\n::::\n:::::\n\n\n\n###### Solution (Code)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-ex-03-failed-code-solution}\n: Why failed the code in @lst-03-ex-03-failed-code-challenge\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {#lst-03-ex-03-failed-code-solution}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\ndf <- mtcars\n\nui <- fluidPage(\n    selectInput(\"var\", NULL, choices = colnames(df)),\n    verbatimTextOutput(\"debug\")\n)\n\nserver <- function(input, output, session) {\n    col_var <- reactive( df[input$var] )\n    col_range <- reactive({ range(col_var(), na.rm = TRUE ) })\n    output$debug <- renderPrint({ col_range() })\n\n}\n\nshinyApp(ui = ui, server = server)\n```\n:::\n\n\nCode example with changed names of the reactives\n:::\n::::\n:::::\n\n\n\n###### Solution (Shiny)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-03-ex-01-find-bugs-app-shiny}\n: Run @lst-03-ex-03-failed-code-challenge with correct code\n::::::\n:::\n::::{.my-solution-container}\n\nbase::range() and stats::var() are bad names for reactives because they are reserved names for other functions:\n\n- `base::range()` returns a vector containing the minimum and maximum of all the given arguments.\n- `stats::var()` computes the variance of x.\n\nIn the following solution code from [Mastering Shiny Solutions](https://mastering-shiny-solutions.org/basic-reactivity.html#solution-16) I have followed their idea to change `range` into `col_range` and  `var` into `col_var`. These new names substitute the bad names for the reactives in the failed code snippet.\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 300\n\nlibrary(shiny)\n\ndf <- mtcars\n\nui <- fluidPage(\n    selectInput(\"var\", NULL, choices = colnames(df)),\n    verbatimTextOutput(\"debug\")\n)\n\nserver <- function(input, output, session) {\n    col_var <- reactive( df[input$var] )\n    col_range <- reactive({ range(col_var(), na.rm = TRUE ) })\n    output$debug <- renderPrint({ col_range() })\n\n}\n\nshinyApp(ui = ui, server = server)\n\n```\n::::\n:::::\n\nCompare the Shiny result with the code used for the solution in @lst-03-ex-03-failed-code-solution.\n\n:::\n\n::::\n:::::\n\n## Reactive expressions {#sec-03-reactive-expressions}\n\nReactive expressions have a flavor of both inputs and outputs:\n\n- Like outputs, reactive expressions depend on inputs and automatically know when they need updating.\n- Like inputs, you can use the results of a reactive expression in an output.\n\nThis duality means we need some new vocab: I’ll use **producers** to refer to reactive inputs and expressions, and **consumers** to refer to reactive expressions and outputs.\n\n![Inputs and expressions are reactive producers; expressions and outputs are reactive consumers](https://mastering-shiny.org/diagrams/basic-reactivity/producers-consumers.png){#fig-03-07\nfig-alt=\"The graphics shows the connection between `input`, `expression` and `outputs` as Venn diagram. `input` and `expression` form the so-called **Producers**; `expression` and `outputs` constitute the **Consumers**\" fig-align=\"center\" \nwidth=\"70%\"}\n\n### The motivation\n\nImagine I want to compare two simulated datasets with a plot and a hypothesis test. I’ve done a little experimentation and come up with the functions below: `freqpoly()` visualizes the two distributions with <a class='glossary' title='A frequency polygon is a histogram that’s drawn with a line, instead of bars, which makes it easier to compare multiple data sets on the same plot.'>frequency polygon</a>s, and `t_test()` uses a t-test to compare means and summarizes the results with a string:\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-compare-simulated-datasets}\n: Compare two simulated datasets with a plot and a hypothesis test.\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nfreqpoly <- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) {\n  df <- base::data.frame(\n    x = base::c(x1, x2),\n    g = base::c(base::rep(\"x1\", base::length(x1)), \n                base::rep(\"x2\", base::length(x2)))\n  )\n\n  ggplot2::ggplot(df, ggplot2::aes(x, colour = g)) +\n    ggplot2::geom_freqpoly(binwidth = binwidth, linewidth = 1) +\n    ggplot2::coord_cartesian(xlim = xlim)\n}\n\nt_test <- function(x1, x2) {\n  test <- stats::t.test(x1, x2)\n\n  # use sprintf() to format t.test() results compactly\n  base::sprintf(\n    \"p value: %0.3f\\n[%0.2f, %0.2f]\",\n    test$p.value, test$conf.int[1], test$conf.int[2]\n  )\n}\n\n### prepare values\nx1 <- stats::rnorm(100, mean = 0, sd = 0.5)\nx2 <- stats::rnorm(200, mean = 0.15, sd = 0.9)\n\n### call functions\nfreqpoly(x1, x2)\nbase::cat(t_test(x1, x2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> p value: 0.741\n#> [-0.18, 0.13]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Compare two simulated datasets with a plot and a hypothesis test](03-basic-reactivity_files/figure-html/fig-compare-simulated-datasets-1.png){#fig-compare-simulated-datasets width=672}\n:::\n:::\n\n\n\n::::\n:::::\n\n\n### The app\n\nI’d like to use these two tools to quickly explore a bunch of simulations. A Shiny app is a great way to do this because it lets you avoid tediously modifying and re-running R code. Below I wrap the pieces into a Shiny app where I can interactively tweak the inputs.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-03-compare-simulated-data}\n: Case study: Compare simulated data\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-compare-simulated-data-code}\n: Case study: Compare simulated data\n::::::\n:::\n::::{.my-r-code-container}\n::: {#lst-03-compare-simulated-data-code}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n  fluidRow(\n    column(4,\n      \"Distribution 1\",\n      numericInput(\"n1\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean1\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd1\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4,\n      \"Distribution 2\",\n      numericInput(\"n2\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean2\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd2\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4,\n      \"Frequency polygon\",\n      numericInput(\"binwidth\", label = \"Bin width\", value = 0.1, step = 0.1),\n      sliderInput(\"range\", label = \"range\", value = c(-3, 3), min = -5, max = 5)\n    )\n  ),\n  fluidRow(\n    column(9, plotOutput(\"hist\")),\n    column(3, verbatimTextOutput(\"ttest\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  output$hist <- renderPlot({\n    x1 <- rnorm(input$n1, input$mean1, input$sd1)\n    x2 <- rnorm(input$n2, input$mean2, input$sd2)\n\n    freqpoly(x1, x2, binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    x1 <- rnorm(input$n1, input$mean1, input$sd1)\n    x2 <- rnorm(input$n2, input$mean2, input$sd2)\n\n    t_test(x1, x2)\n  })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\nCompare simulated data with plot and t-test\n\n:::\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-compare-simulated-data-shiny}\n: Case study: Compare simulated data\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(munsell)\n\nfreqpoly <- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) {\n  df <- base::data.frame(\n    x = base::c(x1, x2),\n    g = base::c(base::rep(\"x1\", base::length(x1)), \n                base::rep(\"x2\", base::length(x2)))\n  )\n\n  ggplot2::ggplot(df, ggplot2::aes(x, colour = g)) +\n    ggplot2::geom_freqpoly(binwidth = binwidth, linewidth = 1) +\n    ggplot2::coord_cartesian(xlim = xlim)\n}\n\nt_test <- function(x1, x2) {\n  test <- stats::t.test(x1, x2)\n\n  # use sprintf() to format t.test() results compactly\n  base::sprintf(\n    \"p value: %0.3f\\n[%0.2f, %0.2f]\",\n    test$p.value, test$conf.int[1], test$conf.int[2]\n  )\n}\n\nui <- fluidPage(\n  fluidRow(\n    column(4,\n      \"Distribution 1\",\n      numericInput(\"n1\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean1\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd1\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4,\n      \"Distribution 2\",\n      numericInput(\"n2\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean2\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd2\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4,\n      \"Frequency polygon\",\n      numericInput(\"binwidth\", label = \"Bin width\", value = 0.1, step = 0.1),\n      sliderInput(\"range\", label = \"range\", value = c(-3, 3), min = -5, max = 5)\n    )\n  ),\n  fluidRow(\n    column(9, plotOutput(\"hist\")),\n    column(3, verbatimTextOutput(\"ttest\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  output$hist <- renderPlot({\n    x1 <- rnorm(input$n1, input$mean1, input$sd1)\n    x2 <- rnorm(input$n2, input$mean2, input$sd2)\n\n    freqpoly(x1, x2, binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    x1 <- rnorm(input$n1, input$mean1, input$sd1)\n    x2 <- rnorm(input$n2, input$mean2, input$sd2)\n\n    t_test(x1, x2)\n  })\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\nCompare the code in @lst-03-compare-simulated-data-code for this shiny app.\n\n:::\n\n::::\n:::::\n\n\n\n\n### The reactive graph\n\n### Simplifying the graph\n\n\n## Controlling timing of evaluation {#sec-03-control-timing}\n\n## Observers {#sec-03-observers}\n",
    "supporting": [
      "03-basic-reactivity_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}