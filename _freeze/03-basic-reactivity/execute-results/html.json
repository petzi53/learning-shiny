{
  "hash": "02f7ce1f8e1831087dee1605d595ce86",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n  cache: true\n---\n\n# Basic reactivity {#sec-chap03}\n\n\n\n\n## Introduction\n\n::::: {#obj-chap03}\n:::: {.my-objectives}\n::: {.my-objectives-header}\nChapter section list\n:::\n\n\n::: {.my-objectives-container}\n\nThis chapter will provide a gentle introduction to reactive programming, teaching you the basics of the most common reactive constructs you’ll use in Shiny apps.\n\n- Survey of the server function in @sec-03-server-function\n- Simplest form of reactivity in @sec-03-reactive-programming\n- How reactive expressions eliminate duplicated work in @sec-03-reactive-expressions\n- Controlling the time of the evaluation @sec-03-control-timing\n- Observers @sec-03-observers\n\n:::\n::::\n:::::\n\n\n\n## The server function {#sec-03-server-function}\n\n### Input\n\nThe `input` argument is a list-like object that contains all the input data sent from the browser, named according to the input ID. Unlike a typical list, `input` objects are read-only. If you attempt to modify an input inside the server function, you’ll get an error.\n\nThe error occurs because `input` reflects what’s happening in the browser, and the browser is Shiny’s “single source of truth”. If you could modify the value in R, you could introduce inconsistencies, where the input slider said one thing in the browser, and `input$count` said something different in R. That would make programming challenging! (Later, in @XXX_8, you’ll learn how to use functions like `shiny::updateNumericInput()` to modify the value in the browser, and then `input$count` will update accordingly.)\n\nOne more important thing about input: it’s selective about who is allowed to read it. To read from an `input`, you must be in a <a class='glossary' title='In Shiny, reactive contexts are essential for handling user inputs and updating outputs automatically. Reactive values can only be accessed within a reactive context, meaning they must be used inside functions like reactive(), observer(), or any render*() functions.'>reactive context</a> created by a function like `shiny::renderText()` or `shiny::reactive()`.\n\n### Output\n\n`output` is very similar to `input`: it’s also a list-like object named according to the output ID. The main difference is that you use it for sending output instead of receiving input. You always use the `output` object in concert with a `render` function.\n\nThe render function does two things:\n\n- It sets up a special reactive context that automatically tracks what inputs the output uses.\n- It converts the output of your R code into HTML suitable for display on a web page.\n\nLike the `input`, the `output` is picky about how you use it. You’ll get an error if:\n\n- You forget the render function.\n- You attempt to read from an output.\n\n\n## Reactive programming {#sec-03-reactive-programming}\n\nAn app is going to be pretty boring if it only has inputs or only has outputs. The real magic of Shiny happens when you have an app with both.\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-greeting-example}\n: Interactive greeting as an example for reactive programming\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {#lst-greeting-example}\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- shiny::fluidPage(\n  shiny::textInput(\"name\", \"What's your name?\"),\n  shiny::textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  output$greeting <- shiny::renderText({\n    paste0(\"Hello \", input$name, \"!\")\n  })\n}\n\nshiny::shinyApp(ui, server)\n```\n:::\n\n\n:::\n\n```{shinylive-r}\n#| standalone: true\n\n\nui <- shiny::fluidPage(\n  shiny::textInput(\"name\", \"What's your name?\"),\n  shiny::textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  output$greeting <- shiny::renderText({\n    paste0(\"Hello \", input$name, \"!\")\n  })\n}\n\nshiny::shinyApp(ui, server)\n```\n\nThis is the big idea in Shiny: you don’t need to tell an output when to update, because Shiny automatically figures it out for you.\n::::\n:::::\n\n::: {.callout-important}\nIt’s Shiny’s responsibility to decide when code is executed, not yours. Think of your app as providing Shiny with recipes, not giving it commands.\n:::\n\n\n\n\n### Imperative vs declarative programming\n\nThis difference between commands and recipes is one of the key differences between two important styles of programming:\n\n- In **imperative programming**, you issue a specific command and it’s carried out immediately. This is the style of programming you’re used to in your analysis scripts: you command R to load your data, transform it, visualise it, and save the results to disk.\n- In **declarative programming**, you express higher-level goals or describe important constraints, and rely on someone else to decide how and/or when to translate that into action. This is the style of programming you use in Shiny.\n\nWith imperative code you say “Make me a sandwich”. With declarative code you say “Ensure there is a sandwich in the refrigerator whenever I look inside of it”. Imperative code is assertive; declarative code is passive-aggressive.\n\n### Lazyness\n\nOne of the strengths of declarative programming in Shiny is that it allows apps to be extremely lazy. A Shiny app will only ever do the minimal amount of work needed to update the output controls that you can currently see. This laziness, however, comes with an important downside that you should be aware of.\n\n::: {.callout-important}\nIf you’re working on a Shiny app and you just can’t figure out why your code never gets run, double check that your UI and server functions are using the same identifiers.\n:::\n\n\n### The reactive graph {#sec-03-reactive-graph}\n\nShiny’s laziness has another important property. In most R code, you can understand the order of execution by reading the code from top to bottom. That doesn’t work in Shiny, because code is only run when needed. To understand the order of execution you need to instead look at the <a class='glossary' title='In Shiny, the reactive graph is a powerful tool for understanding how your app works. It shows how inputs and outputs are connected, allowing you to visualize the dependencies and execution order of your reactive expressions and render functions. This graph is particularly useful as your app becomes more complex, helping you to manage and debug the interdependencies between different components of your app. To visualize the reactive graph, you can use the reactlog package, which provides an interactive browser-based tool for visualizing reactive dependencies and execution in your application.'>reactive graph</a>, which describes how inputs and outputs are connected.\n\n![This is the reactive graph for @cnj-03-greeting-example. It shows how the inputs and outputs are connected](https://mastering-shiny.org/diagrams/basic-reactivity/graph-1b.png){#fig-03-01 \nfig-alt=\"The graph consists of two blocks titled 'name' and 'greeting'. They are connected horizontally by an arrow from left tot the right. The left 'name' block has a pike to the right which would fit into the bump of the 'greeting' block.\" fig-align=\"center\" \nwidth=\"8cm\"}\n\nThe reactive graph contains one symbol for every input and output, and we connect an input to an output whenever the output accesses the input. This graph tells you that greeting will need to be recomputed whenever name is changed. We’ll often describe this relationship as `greeting` has a <a class='glossary' title='In Shiny, reactive dependencies are automatically inferred by the framework, meaning that when you define a reactive expression, Shiny determines which inputs it depends on. For example, if you have a reactive expression b &lt;- reactive(a * 2), Shiny infers that b depends on a. This information is stored internally within the Shiny framework, but it is not directly accessible through standard functions. For more detailed control over dependencies, you might consider using isolate() to prevent certain parts of your code from being reactive, or using reactiveValues() to manage stateful objects that can be updated and accessed across different parts of your application.'>reactive dependency</a> on `name`.\n\nNote the graphical conventions we used for the inputs and outputs: the name input naturally fits into the greeting output.\n\n![The shapes used by the components of the reactive graph evoke the ways in which they connect.](https://mastering-shiny.org/diagrams/basic-reactivity/graph-1a.png){#fig-03-02 \nfig-alt=\"The graph consists of two blocks titled 'name' and 'greeting'. The left 'name' block has a pike to the right which fits into the bump of the 'greeting' block.\" fig-align=\"center\" \nwidth=\"35%\"}\n\nThe reactive graph is a powerful tool for understanding how your app works. As your app gets more complicated, it’s often useful to make a quick high-level sketch of the reactive graph to remind you how all the pieces fit together. Throughout this book we’ll show you the reactive graph to help understand how the examples work, and later on, in @XXX_14, you’ll learn how to use {**reactlog**} which will draw the graph for you.\n\n### Reactive expressions {#sec-03-reactive-expressions-sub}\n\nThere’s one more important component that you’ll see in the reactive graph: the reactive expression. We’ll come back to reactive expressions in detail very shortly; for now think of them as a tool that reduces duplication in your reactive code by introducing additional nodes into the reactive graph.\n\nWe don’t need a reactive expression in our very simple app, but I’ll add one anyway so you can see how it affects the reactive graph (see @fig-03-03).\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-greeting-example}\n: Interactive greeting as an example for reactive programming\n::::::\n:::\n::::{.my-r-code-container}\n\n:::{#lst-greeting-example2}\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- shiny::fluidPage(\n  shiny::textInput(\"name\", \"What's your name?\"),\n  shiny::textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  output$greeting <- shiny::renderText(string())\n  string <- shiny::reactive(paste0(\"Hello \", input$name, \"!\"))\n}\n\nshiny::shinyApp(ui, server)\n```\n:::\n\n\n:::\n\n```{shinylive-r}\n#| standalone: true\n\nui <- shiny::fluidPage(\n  shiny::textInput(\"name\", \"What's your name?\"),\n  shiny::textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  string <- shiny::reactive(paste0(\"Hello \", input$name, \"!\"))\n  output$greeting <- shiny::renderText(string())\n}\n\nshiny::shinyApp(ui, server)\n```\n\n***\n\nCompare the tiny difference in the server code with @lst-greeting-example.\n::::\n:::::\n\n\n\n![A reactive expression is drawn with angles on both sides because it connects inputs to outputs.](https://mastering-shiny.org/diagrams/basic-reactivity/graph-2b.png){#fig-03-03 \nfig-alt=\"The graph consists of three blocks titled 'name', 'string and 'greeting'. The blocks are connected by two arrows from left to the right. 'name' block has a pike to the right which fits into the bump of the 'string' block which itself has a bump fitting into the 'greeting' block.\" fig-align=\"center\" \nwidth=\"70%\"}\n\nReactive expressions take inputs and produce outputs so they have a shape that combines features of both inputs and outputs.\n\n### Execution order\n\nIt’s important to understand that the order in which your code runs is solely determined by the reactive graph. This is different from most R code where the execution order is determined by the order of lines. For example, we could flip the order of the two lines in our simple server function:\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-greeting-example}\n: Interactive greeting as an example for reactive programming\n::::::\n:::\n::::{.my-r-code-container}\n\n:::{#lst-greeting-example3}\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- shiny::fluidPage(\n  shiny::textInput(\"name\", \"What's your name?\"),\n  shiny::textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  string <- shiny::reactive(paste0(\"Hello \", input$name, \"!\"))\n  output$greeting <- shiny::renderText(string())\n}\n\nshiny::shinyApp(ui, server)\n```\n:::\n\n\n:::\n\n```{shinylive-r}\n#| standalone: true\n\nui <- shiny::fluidPage(\n  shiny::textInput(\"name\", \"What's your name?\"),\n  shiny::textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  output$greeting <- shiny::renderText(string())\n  string <- shiny::reactive(paste0(\"Hello \", input$name, \"!\"))\n}\n\nshiny::shinyApp(ui, server)\n```\n\n***\n\nAgain: Compare the tiny difference in the server code; this time with @lst-greeting-example2.\n::::\n:::::\n\n\n\nYou might think that this would yield an error because `output$greeting` refers to a reactive expression, string, that hasn’t been created yet. But remember Shiny is lazy, so that code is only run when the session starts, after string has been created.\n\nInstead, this code yields the same reactive graph as above, so the order in which the code is run is exactly the same. Organizing your code like this is confusing for humans, and best avoided. Instead, make sure that reactive expressions and outputs only refer to things defined above, not below. This will make your code easier to understand.\n\nThis concept is very important and different to most other R code, so I’ll say it again:\n\n::: {.callout-important}\nThe order in which reactive code is run is determined only by the reactive graph, not by its layout in the server function.\n:::\n\n### Exercises\n\n#### Find bugs\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-03-ex-01-find-bugs}\n: Find the bugs in the three server functions\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-ex-01-find-bugs-challenge}\n: Find the bugs in the three server functions\n::::::\n:::\n::::{.my-r-code-container}\n\nFix the simple errors found in each of the three server functions below. First try spotting the problem just by reading the code; then run the code to make sure you’ve fixed it.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\n\nserver1 <- function(input, output, server) {\n  input$greeting <- renderText(paste0(\"Hello \", name))\n}\n\nserver2 <- function(input, output, server) {\n  greeting <- paste0(\"Hello \", input$name)\n  output$greeting <- renderText(greeting)\n}\n\nserver3 <- function(input, output, server) {\n  output$greting <- paste0(\"Hello\", input$name)\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n::::\n:::::\n\n\n\n###### Solution (Code)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-ex-01-find-bugs-solution-code}\n: Show the bugs in the three server functions and add correct code\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {#lst-03-ex-01-find-bugs-solution-code}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\n\n# server1 <- function(input, output, server) {\n#   input$greeting <- renderText(paste0(\"Hello \", name))\n##### output$greeting instead of input$greeting #######\n# }\n# \n# server2 <- function(input, output, server) {\n#   greeting <- paste0(\"Hello \", input$name)\n##### assigning value directly not allowed ######\n#   output$greeting <- renderText(greeting)\n# }\n# \n# server3 <- function(input, output, server) {\n#   output$greting <- paste0(\"Hello\", input$name)\n##### missing 'e' in output$greting #######\n# }\n\n# correct code\nserver <- function(input, output, server) {\n    output$greeting <- renderText(paste0(\"Hello\", input$name))\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n:::\n::::\n:::::\n\n\n\n###### Solution (Shiny)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-03-ex-01-find-bugs-app-shiny}\n: Run @lst-03-ex-01-find-bugs-solution-code with correct code\n::::::\n:::\n::::{.my-solution-container}\n\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 100\n\nlibrary(shiny)\n\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\n\n# server1 <- function(input, output, server) {\n#   input$greeting <- renderText(paste0(\"Hello \", name))\n##### output$greeting instead of input$greeting #######\n# }\n# \n# server2 <- function(input, output, server) {\n#   greeting <- paste0(\"Hello \", input$name)\n##### assigning value directly not allowed ######\n#   output$greeting <- renderText(greeting)\n# }\n# \n# server3 <- function(input, output, server) {\n#   output$greting <- paste0(\"Hello\", input$name)\n##### missing 'e' in output$greting #######\n# }\n\n# correct code\nserver <- function(input, output, server) {\n    output$greeting <- renderText(paste0(\"Hello\", input$name))\n}\n\nshinyApp(ui, server)\n\n```\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n#### Draw reactive graphs\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-03-ex-02-draw-reactive-graphs}\n: Draw reactive graph for server functions\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-ex-02-find-bugs-challenge}\n: Draw reactive graph for server functions\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {#lst-draw-graphs-challenge}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nserver1 <- function(input, output, session) {\n  c <- reactive(input$a + input$b)\n  e <- reactive(c() + input$d)\n  output$f <- renderText(e())\n}\n\nserver2 <- function(input, output, session) {\n  x <- reactive(input$x1 + input$x2 + input$x3)\n  y <- reactive(input$y1 + input$y2)\n  output$z <- renderText(x() / y())\n}\n\nserver3 <- function(input, output, session) {\n  d <- reactive(c() ^ input$d)\n  a <- reactive(input$a * 10)\n  c <- reactive(b() / input$c)\n  b <- reactive(a() + input$b)\n}\n```\n:::\n\n\n:::\n::::\n:::::\n\n\n\n###### Solution (Graphs)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-ex-02-draw-graphs-solution}\n: Draw the graphs in the three server functions of @lst-draw-graphs-challenge\n::::::\n:::\n::::{.my-r-code-container}\n\nI've tried to find the solution myself and then I've compared my result with the [drawing graph solutions](https://mastering-shiny-solutions.org/basic-reactivity.html#solution-15) in Mastering Shiny Solutions [@ther4dsonlinelearningcommunity2023]\n\nThe first two examples of my trials coincide with Mastering Shiny Solutions. In the third example I had a chain of the inputs a,b,c,d and not — as in Mastering Shiny Solutions — a step by step chain where each input is depending of an input with the same name.\n\n***\n\n![Solution of the reactive graph: server 1](https://mastering-shiny-solutions.org/images/4.3.6.1-s1.png){#fig-03-04\nfig-alt=\"The graph consists of six blocks titled a-f. 'a' and 'b' are connected horizontally by an arrow from left tot the right with 'c'. The block 'e' gets its input (= arrows) by 'c' and 'd' and 'e' finally put its result into 'f'\" fig-align=\"center\" \nwidth=\"50%\"}\n\n***\n\n![Solution of the reactive graph: server 2](https://mastering-shiny-solutions.org/images/4.3.6.1-s2.png){#fig-03-05 \nfig-alt=\"The graph consists of six blocks titled a-f. 'a' and 'b' are connected horizontally by an arrow from left tot the right with 'c'. The block 'e' gets its input (= arrows) by 'c' and 'd' and 'e' finally put its result into 'f'\" fig-align=\"center\" \nwidth=\"50%\"}\n\n***\n\n![Solution of the reactive graph: server 3](https://mastering-shiny-solutions.org/images/4.3.6.1-s3.png){#fig-03-06 \nfig-alt=\"The graph consists of six blocks titled a-f. 'a' and 'b' are connected horizontally by an arrow from left tot the right with 'c'. The block 'e' gets its input (= arrows) by 'c' and 'd' and 'e' finally put its result into 'f'\" fig-align=\"center\" \nwidth=\"50%\"}\n\n\n::::\n:::::\n\nCompare the graphs with the server code snippets in @lst-draw-graphs-challenge.\n\n\n\n:::\n\n::::\n:::::\n\n#### Failed code snippet\n\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n:::::: {#exr-03-ex-03-failed-code}\n: Why will this code fail?\n::::::\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Challenge\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-ex-03-failed-code-challenge}\n: Why will this code snippet fail?\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {#lst-03-ex-03-failed-code-challenge}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nvar <- reactive(df[[input$var]])\nrange <- reactive(range(var(), na.rm = TRUE))\n```\n:::\n\n\n\nFailed code snippet\n:::\n::::\n:::::\n\n\n\n###### Solution (Code)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-ex-03-failed-code-solution}\n: Why failed the code in @lst-03-ex-03-failed-code-challenge\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {#lst-03-ex-03-failed-code-solution}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(shiny)\n\ndf <- mtcars\n\nui <- fluidPage(\n    selectInput(\"var\", NULL, choices = colnames(df)),\n    verbatimTextOutput(\"debug\")\n)\n\nserver <- function(input, output, session) {\n    col_var <- reactive( df[input$var] )\n    col_range <- reactive({ range(col_var(), na.rm = TRUE ) })\n    output$debug <- renderPrint({ col_range() })\n\n}\n\nshinyApp(ui = ui, server = server)\n```\n:::\n\n\nCode example with changed names of the reactives\n:::\n::::\n:::::\n\n\n\n###### Solution (Shiny)\n\n:::::{.my-solution}\n:::{.my-solution-header}\n:::::: {#sol-03-ex-01-find-bugs-app-shiny}\n: Run @lst-03-ex-03-failed-code-challenge with correct code\n::::::\n:::\n::::{.my-solution-container}\n\nbase::range() and stats::var() are bad names for reactives because they are reserved names for other functions:\n\n- `base::range()` returns a vector containing the minimum and maximum of all the given arguments.\n- `stats::var()` computes the variance of x.\n\nIn the following solution code from [Mastering Shiny Solutions](https://mastering-shiny-solutions.org/basic-reactivity.html#solution-16) I have followed their idea to change `range` into `col_range` and  `var` into `col_var`. These new names substitute the bad names for the reactives in the failed code snippet.\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 300\n\nlibrary(shiny)\n\ndf <- mtcars\n\nui <- fluidPage(\n    selectInput(\"var\", NULL, choices = colnames(df)),\n    verbatimTextOutput(\"debug\")\n)\n\nserver <- function(input, output, session) {\n    col_var <- reactive( df[input$var] )\n    col_range <- reactive({ range(col_var(), na.rm = TRUE ) })\n    output$debug <- renderPrint({ col_range() })\n\n}\n\nshinyApp(ui = ui, server = server)\n\n```\n::::\n:::::\n\nCompare the Shiny result with the code used for the solution in @lst-03-ex-03-failed-code-solution.\n\n:::\n\n::::\n:::::\n\n## Reactive expressions {#sec-03-reactive-expressions}\n\nReactive expressions have a flavor of both inputs and outputs:\n\n- Like outputs, reactive expressions depend on inputs and automatically know when they need updating.\n- Like inputs, you can use the results of a reactive expression in an output.\n\nThis duality means we need some new vocab: I’ll use **producers** to refer to reactive inputs and expressions, and **consumers** to refer to reactive expressions and outputs.\n\n![Inputs and expressions are reactive producers; expressions and outputs are reactive consumers](https://mastering-shiny.org/diagrams/basic-reactivity/producers-consumers.png){#fig-03-07\nfig-alt=\"The graphics shows the connection between `input`, `expression` and `outputs` as Venn diagram. `input` and `expression` form the so-called **Producers**; `expression` and `outputs` constitute the **Consumers**\" fig-align=\"center\" \nwidth=\"70%\"}\n\n### The motivation\n\nImagine I want to compare two simulated datasets with a plot and a hypothesis test. I’ve done a little experimentation and come up with the functions below: `freqpoly()` visualizes the two distributions with <a class='glossary' title='A frequency polygon is a histogram that’s drawn with a line, instead of bars, which makes it easier to compare multiple data sets on the same plot.'>frequency polygon</a>s, and `t_test()` uses a t-test to compare means and summarizes the results with a string:\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-compare-simulated-datasets}\n: Compare two simulated datasets with a plot and a hypothesis test.\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\nfreqpoly <- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) {\n  df <- base::data.frame(\n    x = base::c(x1, x2),\n    g = base::c(base::rep(\"x1\", base::length(x1)), \n                base::rep(\"x2\", base::length(x2)))\n  )\n\n  ggplot2::ggplot(df, ggplot2::aes(x, colour = g)) +\n    ggplot2::geom_freqpoly(binwidth = binwidth, linewidth = 1) +\n    ggplot2::coord_cartesian(xlim = xlim)\n}\n\nt_test <- function(x1, x2) {\n  test <- stats::t.test(x1, x2)\n\n  # use sprintf() to format t.test() results compactly\n  base::sprintf(\n    \"p value: %0.3f\\n[%0.2f, %0.2f]\",\n    test$p.value, test$conf.int[1], test$conf.int[2]\n  )\n}\n\n### prepare values\nx1 <- stats::rnorm(100, mean = 0, sd = 0.5)\nx2 <- stats::rnorm(200, mean = 0.15, sd = 0.9)\n\n### call functions\nfreqpoly(x1, x2)\nbase::cat(t_test(x1, x2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> p value: 0.001\n#> [-0.47, -0.13]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Compare two simulated datasets with a plot and a hypothesis test](03-basic-reactivity_files/figure-html/fig-compare-simulated-datasets-1.png){#fig-compare-simulated-datasets width=672}\n:::\n:::\n\n\n\n::::\n:::::\n\n\n### The app\n\nI’d like to use these two tools to quickly explore a bunch of simulations. A Shiny app is a great way to do this because it lets you avoid tediously modifying and re-running R code. Below I wrap the pieces into a Shiny app where I can interactively tweak the inputs.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-03-compare-simulated-data}\n: Case study: Compare simulated data V1\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-compare-simulated-data-code}\n: Case study: Compare simulated data V1\n::::::\n:::\n::::{.my-r-code-container}\n::: {#lst-03-compare-simulated-data-code1}\n\n::: {.cell}\n\n```{.r .cell-code}\n## source .R file with the two functions didn't work\n## so I had to use the original code instead of the following\n\nbase::source(\n      base::paste0(here::here(), \"/R/shiny-03-V2.R\"),\n      local = TRUE,\n      chdir = TRUE,\n      encoding = \"utf-8\"\n    )\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(munsell)\n\nui <- fluidPage(\n  fluidRow(\n    column(4,\n      \"Distribution 1\",\n      numericInput(\"n1\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean1\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd1\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4,\n      \"Distribution 2\",\n      numericInput(\"n2\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean2\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd2\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4,\n      \"Frequency polygon\",\n      numericInput(\"binwidth\", label = \"Bin width\", value = 0.1, step = 0.1),\n      sliderInput(\"range\", label = \"range\", value = c(-3, 3), min = -5, max = 5)\n    )\n  ),\n  fluidRow(\n    column(9, plotOutput(\"hist\")),\n    column(3, verbatimTextOutput(\"ttest\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  output$hist <- renderPlot({\n    x1 <- rnorm(input$n1, input$mean1, input$sd1)\n    x2 <- rnorm(input$n2, input$mean2, input$sd2)\n\n    freqpoly(x1, x2, binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    x1 <- rnorm(input$n1, input$mean1, input$sd1)\n    x2 <- rnorm(input$n2, input$mean2, input$sd2)\n\n    t_test(x1, x2)\n  })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\nCompare simulated data with plot and t-test\n\n:::\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-compare-simulated-data-shiny}\n: Case study: Compare simulated data V1\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(munsell)\n\n# source .R file with the two functions didn't work\nfreqpoly <- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) {\n    df <- base::data.frame(\n        x = base::c(x1, x2),\n        g = base::c(base::rep(\"x1\", base::length(x1)),\n                    base::rep(\"x2\", base::length(x2)))\n    )\n\n    ggplot2::ggplot(df, ggplot2::aes(x, colour = g)) +\n        ggplot2::geom_freqpoly(binwidth = binwidth, linewidth = 1) +\n        ggplot2::coord_cartesian(xlim = xlim)\n}\n\nt_test <- function(x1, x2) {\n    test <- stats::t.test(x1, x2)\n\n    # use sprintf() to format t.test() results compactly\n    base::sprintf(\n        \"p value: %0.3f\\n[%0.2f, %0.2f]\",\n        test$p.value, test$conf.int[1], test$conf.int[2]\n    )\n}\n\n# base::source(\n#       base::paste0(here::here(), \"/R/shiny-03-V2.R\"),\n#       local = TRUE,\n#       chdir = TRUE,\n#       encoding = \"utf-8\"\n#     )\n\n\n\nui <- fluidPage(\n  fluidRow(\n    column(4,\n      \"Distribution 1\",\n      numericInput(\"n1\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean1\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd1\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4,\n      \"Distribution 2\",\n      numericInput(\"n2\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean2\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd2\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4,\n      \"Frequency polygon\",\n      numericInput(\"binwidth\", label = \"Bin width\", value = 0.1, step = 0.1),\n      sliderInput(\"range\", label = \"range\", value = c(-3, 3), min = -5, max = 5)\n    )\n  ),\n  fluidRow(\n    column(9, plotOutput(\"hist\")),\n    column(3, verbatimTextOutput(\"ttest\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  output$hist <- renderPlot({\n    x1 <- rnorm(input$n1, input$mean1, input$sd1)\n    x2 <- rnorm(input$n2, input$mean2, input$sd2)\n\n    freqpoly(x1, x2, binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    x1 <- rnorm(input$n1, input$mean1, input$sd1)\n    x2 <- rnorm(input$n2, input$mean2, input$sd2)\n\n    t_test(x1, x2)\n  })\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\nCompare the code in @lst-03-compare-simulated-data-code1 for this shiny app.\n\n:::\n\n::::\n:::::\n\n::: {.callout-warning}\nI had to duplicate the code for the two functions `freqpoly()` and `t_test()` because sourcing the code from an extra .R file did not work. I tried several options of `source(\"path-to-file\", local = TRUE)`\n\n- file in an extra directory with additional option `chdir = TRUE`,\n- file in main directory references with `source('./<file_name>', local=TRUE)`\n- file calling with `here::here()` applying `if(FALSE){library(here)}` to include additional R packages that are not automatically discovered,\n- adding `encoding=\"utf-8\"`\n\n:::\n\nYou can find a live version at <https://hadley.shinyapps.io/ms-case-study-1>; I recommend opening the app with the above link, because it uses the whole screen width and it is therefore easier to play with. Having a quick play to make sure you understand its basic operation is essential before you continue reading.\n\n\n### The reactive graph\n\nShiny is smart enough to update an output only when the inputs it refers to change; it’s not smart enough to only selectively run pieces of code inside an output. In other words, outputs are atomic: they’re either executed or not as a whole.\n\nFor example, take this snippet from the server:\n\n```\nx1 <- rnorm(input$n1, input$mean1, input$sd1)\nx2 <- rnorm(input$n2, input$mean2, input$sd2)\nt_test(x1, x2)\n```\n\nAs a human reading this code you can tell that we only need to update `x1` when `n1`, `mean1`, or `sd1` changes, and we only need to update `x2` when `n2`, `mean2`, or `sd2` changes. Shiny, however, only looks at the output as a whole, so it will update both `x1` and `x2` every time one of `n1`, `mean1`, `sd1`, `n2`, `mean2`, or `sd2` changes. This leads to the reactive graph shown in @fig-03-08.\n\n![The reactive graph shows that every output depends on every input](https://mastering-shiny.org/diagrams/basic-reactivity/case-study-1.png){#fig-03-08 \nfig-alt=\"The inputs n1, mean1, sd1, n2, mean2, sd2 are all connected to the outputs ttest and hist. Additionally binwidth and range are connected to hist.\" fig-align=\"center\" \nwidth=\"40%\"}\n\nYou’ll notice that the graph is very dense: almost every input is connected directly to every output. This creates two problems:\n\n- The app is hard to understand because there are so many connections. There are no pieces of the app that you can pull out and analyse in isolation.\n- The app is inefficient because it does more work than necessary. For example, if you change the breaks of the plot, the data is recalculated; if you change the value of `n1`, `x2` is updated (in two places!).\n\nThere’s one other major flaw in the app: the frequency polygon and t-test use separate random draws. This is rather misleading, as you’d expect them to be working on the same underlying data.\n\nFortunately, we can fix all these problems by using reactive expressions to pull out repeated computation.\n\n\n### Simplifying the graph\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-03-compare-simulated-data2}\n: Case study: Compare simulated data V2\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-compare-simulated-data-code2}\n: Case study: Compare simulated data V2\n::::::\n:::\n::::{.my-r-code-container}\n::: {#lst-03-compare-simulated-data-code2}\n\n::: {.cell}\n\n```{.r .cell-code}\n## source .R file with the two functions didn't work\nbase::source(\n      base::paste0(here::here(), \"/R/shiny-03-V2.R\"),\n      local = TRUE,\n      chdir = TRUE,\n      encoding = \"utf-8\"\n    )\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(munsell)\n\nui <- fluidPage(\n  fluidRow(\n    column(4,\n      \"Distribution 1\",\n      numericInput(\"n1\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean1\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd1\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4,\n      \"Distribution 2\",\n      numericInput(\"n2\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean2\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd2\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4,\n      \"Frequency polygon\",\n      numericInput(\"binwidth\", label = \"Bin width\", value = 0.1, step = 0.1),\n      sliderInput(\"range\", label = \"range\", value = c(-3, 3), min = -5, max = 5)\n    )\n  ),\n  fluidRow(\n    column(9, plotOutput(\"hist\")),\n    column(3, verbatimTextOutput(\"ttest\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  x1 <- reactive(rnorm(input$n1, input$mean1, input$sd1))\n  x2 <- reactive(rnorm(input$n2, input$mean2, input$sd2))\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1(), x2())\n  })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\nCompare simulated data with plot and t-test using reactive expressions\n:::\n\nCompare the code in @lst-03-compare-simulated-data-code1 for this shiny app without reactive expressions\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-compare-simulated-data-shiny2}\n: Case study: Compare simulated data V2\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\n\n\n# source .R file with the two functions didn't work\nfreqpoly <- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) {\n    df <- base::data.frame(\n        x = base::c(x1, x2),\n        g = base::c(base::rep(\"x1\", base::length(x1)),\n                    base::rep(\"x2\", base::length(x2)))\n    )\n\n    ggplot2::ggplot(df, ggplot2::aes(x, colour = g)) +\n        ggplot2::geom_freqpoly(binwidth = binwidth, linewidth = 1) +\n        ggplot2::coord_cartesian(xlim = xlim)\n}\n\nt_test <- function(x1, x2) {\n    test <- stats::t.test(x1, x2)\n\n    # use sprintf() to format t.test() results compactly\n    base::sprintf(\n        \"p value: %0.3f\\n[%0.2f, %0.2f]\",\n        test$p.value, test$conf.int[1], test$conf.int[2]\n    )\n}\n\n# base::source(\n#       base::paste0(here::here(), \"/R/shiny-03-V2.R\"),\n#       local = TRUE,\n#       chdir = TRUE,\n#       encoding = \"utf-8\"\n#     )\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(munsell)\n\nui <- fluidPage(\n  fluidRow(\n    column(4,\n      \"Distribution 1\",\n      numericInput(\"n1\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean1\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd1\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4,\n      \"Distribution 2\",\n      numericInput(\"n2\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean2\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd2\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4,\n      \"Frequency polygon\",\n      numericInput(\"binwidth\", label = \"Bin width\", value = 0.1, step = 0.1),\n      sliderInput(\"range\", label = \"range\", value = c(-3, 3), min = -5, max = 5)\n    )\n  ),\n  fluidRow(\n    column(9, plotOutput(\"hist\")),\n    column(3, verbatimTextOutput(\"ttest\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  x1 <- reactive(rnorm(input$n1, input$mean1, input$sd1))\n  x2 <- reactive(rnorm(input$n2, input$mean2, input$sd2))\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1(), x2())\n  })\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\nCompare the code in @lst-03-compare-simulated-data-code2 for this shiny app.\n\n:::\n\n::::\n:::::\n\nThis transformation yields the substantially simpler graph shown in @fig-03-09. This simpler graph makes it easier to understand the app because you can understand connected components in isolation; the values of the distribution parameters only affect the output via `x1` and `x2.` This rewrite also makes the app much more efficient since it does much less computation. Now, when you change the `binwidth` or `range`, only the plot changes, not the underlying data.\n\n![title](https://mastering-shiny.org/diagrams/basic-reactivity/case-study-2.png){#fig-03-09 \nfig-alt=\"The inputs n1, mean1, sd1 connect to x1 and the inputs n2, mean2, sd2 connect to x2. x1 and x2 connect to ttest and hist. binwidth and range connect to hist.\" fig-align=\"center\" \nwidth=\"40%\"}\n\nTo emphasize this modularity @fig-03-10 draws boxes around the independent components. We’ll come back to this idea in @XXX_19, when we discuss modules. Modules allow you to extract out repeated code for reuse, while guaranteeing that it’s isolated from everything else in the app. Modules are an extremely useful and powerful technique for more complex apps.\n\n![Modules enforce isolation between parts of an app](https://mastering-shiny.org/diagrams/basic-reactivity/case-study-3.png){#fig-03-10 \nfig-alt=\"The inputs n1, mean1, sd1 connect to x1; the inputs n2, mean2, sd2 connect to x2. x1 and x2 connect to ttest and hist; binwidth and range connect to hist. Additionally there are two boxes drawn. One around n1, mean, sd1 and x1, the other one around n2, mean2, sd2 and x2.\" fig-align=\"center\" \nwidth=\"40%\"}\n\nYou might be familiar with the “rule of three” of programming: whenever you copy and paste something three times, you should figure out how to reduce the duplication (typically by writing a function). **In Shiny, however, I think you should consider the rule of one**: whenever you copy and paste something once, you should consider extracting the repeated code out into a reactive expression. The rule is stricter for Shiny because reactive expressions don’t just make it easier for humans to understand the code, they also improve Shiny’s ability to efficiently rerun code.\n\n\n### Why do we need reactive expressions?\n\nWhen you first start working with reactive code, you might wonder why we need reactive expressions. Why can’t you use your existing tools for reducing duplication in code: creating new variables and writing functions? Unfortunately neither of these techniques work in a reactive environment.\n\n- **If you try to use a variable to reduce duplication**, you’ll get an error because you’re attempting to access input values outside of a reactive context. Even if you didn’t get that error, you’d still have a problem: `x1` and `x2` would only be computed once, when the session begins, not every time one of the inputs was updated.\n- **If you try to use a function to reduce duplication** it has the same problem as the original code: any input will cause all outputs to be recomputed, and the t-test and the frequency polygon will be run on separate samples. Reactive expressions automatically cache their results, and only update when their inputs change.\n\n\n## Controlling timing of evaluation {#sec-03-control-timing}\n\nNow that you’re familiar with the basic ideas of reactivity, we’ll discuss two more advanced techniques that allow you to either increase or decrease how often a reactive expression is executed. Here I’ll show how to use the basic techniques; in @XXX_15, we’ll come back to their underlying implementations.\n\nTo explore the basic ideas, I’m going to simplify my simulation app. I’ll use a distribution with only one parameter, and force both samples to share the same `n`. I’ll also remove the plot controls. This yields a smaller UI object and server function.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-03-compare-simulated-data3}\n: Case study: Compare simulated data V3\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-compare-simulated-data-code3}\n: Case study: Compare simulated data V3\n::::::\n:::\n::::{.my-r-code-container}\n::: {#lst-03-compare-simulated-data-code3}\n\n::: {.cell}\n\n```{.r .cell-code}\n## source .R file with the two functions didn't work\nbase::source(\n      base::paste0(here::here(), \"/R/shiny-03-V2.R\"),\n      local = TRUE,\n      chdir = TRUE,\n      encoding = \"utf-8\"\n    )\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(munsell)\n\nui <- fluidPage(\n  fluidRow(\n    column(3,\n      numericInput(\"lambda1\", label = \"lambda1\", value = 3),\n      numericInput(\"lambda2\", label = \"lambda2\", value = 5),\n      numericInput(\"n\", label = \"n\", value = 1e4, min = 0)\n    ),\n    column(9, plotOutput(\"hist\"))\n  )\n)\nserver <- function(input, output, session) {\n  x1 <- reactive(rpois(input$n, input$lambda1))\n  x2 <- reactive(rpois(input$n, input$lambda2))\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\nA simpler app that displays a frequency polygon of random numbers drawn from two Poisson distributions.\n:::\n\nCompare the code with original app @lst-03-compare-simulated-data-code1 (without reactive expression) and @lst-03-compare-simulated-data-code2 (with reactive expressions) with this more simpler app that draws from two Poisson distributions.\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-compare-simulated-data-shiny3}\n: Case study: Compare simulated data V3\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\n# source .R file with the two functions didn't work\nfreqpoly <- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) {\n    df <- base::data.frame(\n        x = base::c(x1, x2),\n        g = base::c(base::rep(\"x1\", base::length(x1)),\n                    base::rep(\"x2\", base::length(x2)))\n    )\n\n    ggplot2::ggplot(df, ggplot2::aes(x, colour = g)) +\n        ggplot2::geom_freqpoly(binwidth = binwidth, linewidth = 1) +\n        ggplot2::coord_cartesian(xlim = xlim)\n}\n\nt_test <- function(x1, x2) {\n    test <- stats::t.test(x1, x2)\n\n    # use sprintf() to format t.test() results compactly\n    base::sprintf(\n        \"p value: %0.3f\\n[%0.2f, %0.2f]\",\n        test$p.value, test$conf.int[1], test$conf.int[2]\n    )\n}\n\n# base::source(\n#       base::paste0(here::here(), \"/R/shiny-03-V2.R\"),\n#       local = TRUE,\n#       chdir = TRUE,\n#       encoding = \"utf-8\"\n#     )\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(munsell)\n\nui <- fluidPage(\n  fluidRow(\n    column(3,\n      numericInput(\"lambda1\", label = \"lambda1\", value = 3),\n      numericInput(\"lambda2\", label = \"lambda2\", value = 5),\n      numericInput(\"n\", label = \"n\", value = 1e4, min = 0)\n    ),\n    column(9, plotOutput(\"hist\"))\n  )\n)\nserver <- function(input, output, session) {\n  x1 <- reactive(rpois(input$n, input$lambda1))\n  x2 <- reactive(rpois(input$n, input$lambda2))\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\nCompare the code in @lst-03-compare-simulated-data-code3 for this shiny app.\n\n:::\n\nTo play around with this app use the live version at <https://hadley.shinyapps.io/ms-simulation-2>.\n\n::::\n:::::\n\n![The reactive graph of a simpler app that displays a frequency polygon of random numbers drawn from two Poisson distributions.](https://mastering-shiny.org/diagrams/basic-reactivity/timing.png){#fig-03-11 \nfig-alt=\"lambda1 and n connect to x1, lambda2 and n connect to x2. x1 and x2 connect to the hist output.\" fig-align=\"center\" \nwidth=\"40%\"}\n\n### Timed invalidation\n\nImagine you wanted to reinforce the fact that this is for simulated data by constantly resimulating the data, so that you see an animation rather than a static plot. We can increase the frequency of updates with a new function: `shiny::reactiveTimer()`.\n\n`shiny::reactiveTimer()` is a reactive expression that has a dependency on a hidden input: the current time. You can use a `reactiveTimer()` when you want a reactive expression to invalidate itself more often than it otherwise would. For example, the following code uses an interval of 500 ms so that the plot will update twice a second. This is fast enough to remind you that you’re looking at a simulation, without dizzying you with rapid changes.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-03-compare-simulated-data4}\n: Case study: Compare simulated data V4\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-compare-simulated-data-code4}\n: Case study: Compare simulated data V4\n::::::\n:::\n::::{.my-r-code-container}\n::: {#lst-03-compare-simulated-data-code4}\n\n::: {.cell}\n\n```{.r .cell-code}\n# source .R file with the two functions didn't work\nbase::source(\n      base::paste0(here::here(), \"/R/shiny-03-V2.R\"),\n      local = TRUE,\n      chdir = TRUE,\n      encoding = \"utf-8\"\n    )\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(munsell)\n\nui <- fluidPage(\n  fluidRow(\n    column(3,\n      numericInput(\"lambda1\", label = \"lambda1\", value = 3),\n      numericInput(\"lambda2\", label = \"lambda2\", value = 5),\n      numericInput(\"n\", label = \"n\", value = 1e4, min = 0)\n    ),\n    column(9, plotOutput(\"hist\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  timer <- reactiveTimer(500)\n\n  x1 <- reactive({\n    timer()\n    rpois(input$n, input$lambda1)\n  })\n  x2 <- reactive({\n    timer()\n    rpois(input$n, input$lambda2)\n  })\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\nAnimation of a frequency polygon of random numbers drawn from two Poisson distributions.\n:::\n\nNote how we use `timer()` in the reactive expressions that compute `x1()` and `x2()`: we call it, but don’t use the value. This lets `x1` and `x2` take a reactive dependency on timer, without worrying about exactly what value it returns.\n\nCompare the code with static app @lst-03-compare-simulated-data-code3 with this animation.\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-compare-simulated-data-shiny4}\n: Case study: Compare simulated data V4\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\n# source .R file with the two functions didn't work\nfreqpoly <- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) {\n    df <- base::data.frame(\n        x = base::c(x1, x2),\n        g = base::c(base::rep(\"x1\", base::length(x1)),\n                    base::rep(\"x2\", base::length(x2)))\n    )\n\n    ggplot2::ggplot(df, ggplot2::aes(x, colour = g)) +\n        ggplot2::geom_freqpoly(binwidth = binwidth, linewidth = 1) +\n        ggplot2::coord_cartesian(xlim = xlim)\n}\n\nt_test <- function(x1, x2) {\n    test <- stats::t.test(x1, x2)\n\n    # use sprintf() to format t.test() results compactly\n    base::sprintf(\n        \"p value: %0.3f\\n[%0.2f, %0.2f]\",\n        test$p.value, test$conf.int[1], test$conf.int[2]\n    )\n}\n\n# source(\n#       paste0(here::here(), \"/R/shiny-03-V2.R\"),\n#       local = TRUE,\n#       chdir = TRUE,\n#       encoding = \"utf-8\"\n#     )\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(munsell)\n\nui <- fluidPage(\n  fluidRow(\n    column(3,\n      numericInput(\"lambda1\", label = \"lambda1\", value = 3),\n      numericInput(\"lambda2\", label = \"lambda2\", value = 5),\n      numericInput(\"n\", label = \"n\", value = 1e4, min = 0)\n    ),\n    column(9, plotOutput(\"hist\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  timer <- reactiveTimer(500)\n\n  x1 <- reactive({\n    timer()\n    rpois(input$n, input$lambda1)\n  })\n  x2 <- reactive({\n    timer()\n    rpois(input$n, input$lambda2)\n  })\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\nCompare the code in @lst-03-compare-simulated-data-code3 for this shiny app.\n\n:::\n\n\n::::\n:::::\n\n![title](https://mastering-shiny.org/diagrams/basic-reactivity/timing-timer.png){#fig-03-12 \nfig-alt=\"lambda1 and n connect to x1, lambda2 and n connect to x2. x1 and x2 connect to the hist output. Additionally there is a (hidden) timer input that connects to x1 and x2.\" fig-align=\"center\" \nwidth=\"50%\"}\n\n### On click\n\nIn the above scenario, think about what would happen if the simulation code took 1 second to run. We perform the simulation every 0.5s, so Shiny would have more and more to do, and would never be able to catch up. The same problem can happen if someone is rapidly clicking buttons in your app and the computation you are doing is relatively expensive. It’s possible to create a big backlog of work for Shiny, and while it’s working on the backlog, it can’t respond to any new events. This leads to a poor user experience.\n\nIf this situation arises in your app, you might want to require the user to opt-in to performing the expensive calculation by requiring them to click a button. This is a great use case for an `shiny::actionButton()`.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-03-compare-simulated-data5-action-button}\n: Case study: Compare simulated data V5 (action button V1)\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-compare-simulated-data-code5-action-button1}\n: Case study: Compare simulated data V5 (action button V1)\n::::::\n:::\n::::{.my-r-code-container}\n::: {#lst-03-compare-simulated-data-code5-action-button1}\n\n::: {.cell}\n\n```{.r .cell-code}\n# source .R file with the two functions didn't work\nbase::source(\n      base::paste0(here::here(), \"/R/shiny-03-V2.R\"),\n      local = TRUE,\n      chdir = TRUE,\n      encoding = \"utf-8\"\n    )\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(munsell)\n\nui <- fluidPage(\n  fluidRow(\n    column(3,\n      numericInput(\"lambda1\", label = \"lambda1\", value = 3),\n      numericInput(\"lambda2\", label = \"lambda2\", value = 5),\n      numericInput(\"n\", label = \"n\", value = 1e4, min = 0),\n      actionButton(\"simulate\", \"Simulate!\")\n    ),\n    column(9, plotOutput(\"hist\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  x1 <- reactive({\n    input$simulate\n    rpois(input$n, input$lambda1)\n  })\n  x2 <- reactive({\n    input$simulate\n    rpois(input$n, input$lambda2)\n  })\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\nAction button to compare a frequency polygon of random numbers drawn from two Poisson distributions (Version 1).\n:::\n\n\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-compare-simulated-data-shiny5-action-button1}\n: Case study: Compare simulated data V5 (action button V1)\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\n# source .R file with the two functions didn't work\nfreqpoly <- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) {\n    df <- base::data.frame(\n        x = base::c(x1, x2),\n        g = base::c(base::rep(\"x1\", base::length(x1)),\n                    base::rep(\"x2\", base::length(x2)))\n    )\n\n    ggplot2::ggplot(df, ggplot2::aes(x, colour = g)) +\n        ggplot2::geom_freqpoly(binwidth = binwidth, linewidth = 1) +\n        ggplot2::coord_cartesian(xlim = xlim)\n}\n\nt_test <- function(x1, x2) {\n    test <- stats::t.test(x1, x2)\n\n    # use sprintf() to format t.test() results compactly\n    base::sprintf(\n        \"p value: %0.3f\\n[%0.2f, %0.2f]\",\n        test$p.value, test$conf.int[1], test$conf.int[2]\n    )\n}\n\n# source(\n#       paste0(here::here(), \"/R/shiny-03-V2.R\"),\n#       local = TRUE,\n#       chdir = TRUE,\n#       encoding = \"utf-8\"\n#     )\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(munsell)\n\nui <- fluidPage(\n  fluidRow(\n    column(3,\n      numericInput(\"lambda1\", label = \"lambda1\", value = 3),\n      numericInput(\"lambda2\", label = \"lambda2\", value = 5),\n      numericInput(\"n\", label = \"n\", value = 1e4, min = 0),\n      actionButton(\"simulate\", \"Simulate!\")\n    ),\n    column(9, plotOutput(\"hist\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  x1 <- reactive({\n    input$simulate\n    rpois(input$n, input$lambda1)\n  })\n  x2 <- reactive({\n    input$simulate\n    rpois(input$n, input$lambda2)\n  })\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\nPress the \"Simulate\" button to compare another step of the two Poison distribution. But observe that changes in the input field also start the calculation and redrawing of the graph. This code doesn’t accomplish our goal; we’ve added another dependency instead of replacing the existing dependencies.\n\nCompare the code in @lst-03-compare-simulated-data-code5-action-button1 for this shiny app.\n\n:::\n\n\n::::\n:::::\n\n\n![This reactive graph doesn’t accomplish our goal; we’ve added a dependency instead of replacing the existing dependencies.](https://mastering-shiny.org/diagrams/basic-reactivity/timing-button.png){#fig-03-13 \nfig-alt=\"lambda1 and n connect to x1, lambda2 and n connect to x2. x1 and x2 connect to the hist output. Additionally there is another input from the action button that connects also to x1 and x2.\" fig-align=\"center\" \nwidth=\"70%\"}\n\n\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-03-compare-simulated-data6-action-button2}\n: Case study: Compare simulated data V6 (action button V2)\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-compare-simulated-data-code6-action-button2}\n: Case study: Compare simulated data V6 (action button V2)\n::::::\n:::\n::::{.my-r-code-container}\n::: {#lst-03-compare-simulated-data-code6-action-button2}\n\n::: {.cell}\n\n```{.r .cell-code}\n# source .R file with the two functions didn't work\nbase::source(\n      base::paste0(here::here(), \"/R/shiny-03-V2.R\"),\n      local = TRUE,\n      chdir = TRUE,\n      encoding = \"utf-8\"\n    )\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(munsell)\n\nui <- fluidPage(\n  fluidRow(\n    column(3,\n      numericInput(\"lambda1\", label = \"lambda1\", value = 3),\n      numericInput(\"lambda2\", label = \"lambda2\", value = 5),\n      numericInput(\"n\", label = \"n\", value = 1e4, min = 0),\n      actionButton(\"simulate\", \"Simulate!\")\n    ),\n    column(9, plotOutput(\"hist\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  x1 <- eventReactive(input$simulate, {\n    rpois(input$n, input$lambda1)\n  })\n  x2 <- eventReactive(input$simulate, {\n    rpois(input$n, input$lambda2)\n  })\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\nAction button to compare a frequency polygon of random numbers drawn from two Poisson distributions (Version 2).\n:::\n\nCompare this code with the wrong V1 version in @lst-03-compare-simulated-data-code5-action-button1.\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-compare-simulated-data-shiny6-action-button2}\n: Case study: Compare simulated data V6 (action button V2)\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\n# source .R file with the two functions didn't work\nfreqpoly <- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) {\n    df <- base::data.frame(\n        x = base::c(x1, x2),\n        g = base::c(base::rep(\"x1\", base::length(x1)),\n                    base::rep(\"x2\", base::length(x2)))\n    )\n\n    ggplot2::ggplot(df, ggplot2::aes(x, colour = g)) +\n        ggplot2::geom_freqpoly(binwidth = binwidth, linewidth = 1) +\n        ggplot2::coord_cartesian(xlim = xlim)\n}\n\nt_test <- function(x1, x2) {\n    test <- stats::t.test(x1, x2)\n\n    # use sprintf() to format t.test() results compactly\n    base::sprintf(\n        \"p value: %0.3f\\n[%0.2f, %0.2f]\",\n        test$p.value, test$conf.int[1], test$conf.int[2]\n    )\n}\n\n# source(\n#       paste0(here::here(), \"/R/shiny-03-V2.R\"),\n#       local = TRUE,\n#       chdir = TRUE,\n#       encoding = \"utf-8\"\n#     )\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(munsell)\n\nui <- fluidPage(\n  fluidRow(\n    column(3,\n      numericInput(\"lambda1\", label = \"lambda1\", value = 3),\n      numericInput(\"lambda2\", label = \"lambda2\", value = 5),\n      numericInput(\"n\", label = \"n\", value = 1e4, min = 0),\n      actionButton(\"simulate\", \"Simulate!\")\n    ),\n    column(9, plotOutput(\"hist\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  x1 <- eventReactive(input$simulate, {\n    rpois(input$n, input$lambda1)\n  })\n  x2 <- eventReactive(input$simulate, {\n    rpois(input$n, input$lambda2)\n  })\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}\n\nshinyApp(ui, server)\n```\n\n::::\n:::::\n\nPress the \"Simulate\" button to compare another step of the two Poison distribution. Observe that changes in the input field does not start the calculation and redrawing of the graph.\n\nCompare the code in @lst-03-compare-simulated-data-code6-action-button2 for this shiny app.\n\n:::\n\n\n::::\n:::::\n\n![`shiny::eventReactive()` makes it possible to separate the dependencies (black arrows) from the values used to compute the result (pale gray arrows).](https://mastering-shiny.org/diagrams/basic-reactivity/timing-button-2.png){#fig-03-14 \nfig-alt=\"x1 and x2 no longer have a reactive dependency on (are connected to) lambda1, lambda2, and n. There arrows in pale grey that show the connection of lambda1 and n to x1 as well the connection of lambda2 and n to x2. These pale grey arrows will remind you that x1 and x2 continue to use the values, but no longer take a reactive dependency on them.\" fig-align=\"center\" width=\"50%\"}\n\n\n## Observers {#sec-03-observers}\n\nSo far, we’ve focused on what’s happening inside the app. But sometimes you need to reach outside of the app and cause side-effects to happen elsewhere in the world. This might be saving a file to a shared network drive, sending data to a web API, updating a database, or (most commonly) printing a debugging message to the console. These actions don’t affect how your app looks, so you shouldn’t use an output and a render function. Instead you need to use an <a class='glossary' title='In R Shiny, an observer is a function that can read reactive values and call reactive expressions, and it will automatically re-execute when those dependencies change. Unlike reactive expressions, observers do not yield a result and cannot be used as an input to other reactive expressions. Instead, they are useful for their side effects, such as performing I/O operations.'>observer</a>.\n\nThere are multiple ways to create an observer, and we’ll come back to them later in  @XXX_15.3. For now, I wanted to show you how to use `shiny::observeEvent()`, because it gives you an important debugging tool when you’re first learning Shiny.\n\n`shiny::observeEvent()` is very similar to `shiny::eventReactive()`. It has two important arguments: `eventExpr` and `handlerExpr`. \n\n- `eventExpr` is the input or expression to take a dependency on.\n- `handlerExpr` is the code that will be run. \n\n\nFor example, the following modification to `shiny::server()` means that every time that name is updated, a message will be sent to the console.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-03-message-when-input-updated}\n: Message whenever the input is updated\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Code\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-message-when-input-updated-code}\n: Message whenever the input is updated\n::::::\n:::\n::::{.my-r-code-container}\n::: {#lst-03-message-when-input-updated-code}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  string <- reactive(paste0(\"Hello \", input$name, \"!\"))\n\n  output$greeting <- renderText(string())\n  observeEvent(input$name, {\n    message(\"Greeting performed\")\n  })\n}\n\n\nshinyApp(ui, server)\n```\n:::\n\n\nExample of using `shiny::observeEvent`\n:::\n::::\n:::::\n\n\n###### Shiny\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-message-when-input-updated-shiny}\n: Message whenever the input is updated\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n\nlibrary(shiny)\n\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  string <- reactive(paste0(\"Hello \", input$name, \"!\"))\n\n  output$greeting <- renderText(string())\n  observeEvent(input$name, {\n    message(\"Greeting performed\")\n  })\n}\n\n\n\nshinyApp(ui, server)\n```\n\n***\n\nLook at @lst-03-message-when-input-updated-code the code for this app.\n\n::: {.callout-warning}\n`shiny::observeEvent()` does work as a separate app, but does not work with {**shinylive**}, e.g. it does not send a message neither to the console nor to the HTML web page. I assume it has again to do with variable scoping rules or with the {**shinylive**} configuration.\n:::\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\nThere are two important differences between `shiny::observeEvent()` and `shiny::eventReactive()`:\n\n- You don’t assign the result of `observeEvent()` to a variable, so\n- You can’t refer to it from other reactive consumers.\n\nObservers and outputs are closely related. You can think of outputs as having a special side-effect: updating the HTML in the user’s browser. To emphasize this closeness, we’ll draw them the same way in the reactive graph. This yields the following reactive graph shown in @fig-03-15.\n\n![In the reactive graph, an observer looks the same as an output](https://mastering-shiny.org/diagrams/basic-reactivity/graph-3.png){#fig-03-15 \nfig-alt=\"The input 'name' is connected to 'string' and to the output 'message'. The 'string' element is connected to the output 'greeting'.\" fig-align=\"center\" \nwidth=\"40%\"}\n\n## Summary\n\n::: {.callout-note}\nThis is already my third reading of this chapter. Each reading lies about one year apart.\n\nThe first and second time I thought that each example is easy to understand and that the chapter  as a whole is straightforward. But it turned out that I was wrong!\n\nAs a summary I will I will again read the text. But this time I will pay attention to each line of code and write down every tiny example. Additionally I will create my own example and / or invoke the debugger to experiment with the code to understand exactly what is happening inside the server part.\n:::\n\n### Minimal example\n\nA minimal example consists of four lines of code:\n\n::: {.column-body-outset}\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-summary-minimal-example}\n: Minimal example\n::::::\n:::\n::::{.my-r-code-container}\n\n:::{#lst-03-summary-minimal-example}\n```{shinylive-r}\n#| standalone: true\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\nui <- fluidPage()\n\nserver <- function(input, output, session) {}\n\nshinyApp(ui, server)\n```\n\nMinimal example\n:::\n\n::::\n:::::\n\n:::\n\nThere is no error if you run this code. But there is no output as well! The result is an empty white pane.\n\n### Printing messages from ui and server part\n\nThe problem in my understanding became obvious, when I tried to display just one text message inside the `ui()` and the other one from inside the `server()` function. To make my difficulties explicit I will separate the task in several steps.\n\n::: {.column-body-outset}\n\n\n:::::{.my-experiment}\n:::{.my-experiment-header}\n:::::: {#def-03-summary-print-ui-server-messages}\n: Printing messages from ui and server part\n::::::\n:::\n::::{.my-experiment-container}\n\n::: {.panel-tabset}\n\n###### comments\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-summary-comments}\n: Minimal example with comments in the code\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\nui <- fluidPage(\n    # front end interface\n)\n\nserver <- function(input, output, session) {\n    # back end logic\n}\n\nshinyApp(ui, server)\n```\n\n\n\n::::\n:::::\n\n\n###### print statements\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-summary-print-statements}\n: Minimal example with print statements in UI and server function\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {#lst-03-summary-print-statements}\n\n```{shinylive-r}\n#| standalone: true\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\nui <- fluidPage(\n    print(\"front end interface\")\n)\n\nserver <- function(input, output, session) {\n    print(\"back end logic\")\n}\n\nshinyApp(ui, server)\n```\n\nTrying to print statements from inside UI and server\n\n:::\n\n***\n\nAs you can see only the print statement from the UI is visible. The app does not produce an error and it even produces an output from the server function to the console. But the server print statement does not appear inside the app.\n::::\n:::::\n\nCompare this failed experiment wit the correct solution in @lst-03-summary-reactive-context. \n\n###### reactive context\n\n::: {#lst-03-summary-reactive-context}\n\n```{shinylive-r}\n#| standalone: true\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\nui <- fluidPage(\n    print(\"front end interface\"),\n    textOutput(\"my_msg\")\n)\n\nserver <- function(input, output, session) {\n    output$my_msg <-  renderText(\n        \"back end logic\"\n    )\n}\n\nshinyApp(ui, server)\n\n```\n\nTo print statements that appear inside the app you need to provide a <a class='glossary' title='In Shiny, reactive contexts are essential for handling user inputs and updating outputs automatically. Reactive values can only be accessed within a reactive context, meaning they must be used inside functions like reactive(), observer(), or any render*() functions.'>reactive context</a>.\n:::\n\n:::\n\n::::\n:::::\n\n:::\n\n\n### Failed approaches\n\nI will now list several approaches that will fail with their error messages. I hope that this would be helpful to understand better the effect of the reactive context.\n\nBut I have to fake the error messages as with the `shinylive` extension Shiny will either only produce an empty white pane or display a different error message. I create therefore external Shiny apps, run them with the wrong code snippets and copy the generated error message in this Quarto document.\n\n\n::: {.column-body-outset}\n\n\n:::::{.my-experiment}\n:::{.my-experiment-header}\n:::::: {#def-03-summary-failed-approaches}\n: Why several other approaches will fail?\n::::::\n:::\n::::{.my-experiment-container}\n\n::: {.panel-tabset}\n\n###### input error 1\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-summary-input-error}\n: Assigning values to input objects inside the server function is not allowed\n::::::\n:::\n::::{.my-r-code-container}\n::: {#lst-03-summary-input-error-1}\n\n\n```{shinylive-r}\n#| standalone: true\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\nui <- fluidPage(\n  textInput(\"msg\", \n            \"front end interface\"\n            )\n)\n\n\nserver <- function(input, output, server) {\n    input$msg <- \"back end logic\"\n}\n\nshinyApp(ui, server)\n```\n\n  \n`input` objects are read-only.\n:::\n\n***\n\n> Error in `$<-`(`*tmp*`, msg, value = \"back end logic\") :      \n> Can't modify read-only reactive value 'msg'\n\n::::\n:::::\n\n\n\n\nThe `input` argument is a list-like object, but unlike a typical list, `input` objects are read-only. If you attempt to modify an input inside the server function, you’ll get the above error.\n\n::: {.callout-note}\nThis error occurs because input reflects what’s happening in the browser, and the browser is Shiny’s “single source of truth”. If you could modify the value in R, you could introduce inconsistencies, where the input text said one thing in the browser, and `input$msg` said something different in R. That would make programming challenging! Later, in @XXX_8, you’ll learn how to use functions like `updateTextInput()` to modify the value in the browser, and then `input$msg` will update accordingly.\n:::\n\n\n###### input error 2\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-summary-input-error-2}\n: Reading from `input` needs a reactive context\n::::::\n:::\n::::{.my-r-code-container}\n::: {#lst-03-summary-input-error-2}  \n\n```{shinylive-r}\n#| standalone: true\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\nui <- fluidPage(\n    textInput(\"msg\",\n              \"back end logic\"\n    )\n)\n\n\nserver <- function(input, output, server) {\n    message(\"This is the \", input$msg)\n}\n\nshinyApp(ui, server)\n\n```\n\n\nTo read from an input, you must be in a reactive context.\n:::\n\n***\n> Error in input$msg :      \n> Can't access reactive value 'msg' outside of reactive consumer.       \n> ℹ Do you need to wrap inside reactive() or observe()?\n\n::::\n:::::\n\n`input` is selective about who is allowed to read it. To read from an input, you must be in a reactive context created by a function like `renderText()` or `reactive()`. This is an important constraint that allows outputs to automatically update when an input changes.\n\n###### output error 1\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-summary-output-error-1}\n: `output` needs a render function\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {#lst-03-summary-output-error-1}\n\n\n```{shinylive-r}\n#| standalone: true\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\nui <- fluidPage(\n    textOutput(\"msg\")\n)\n\nserver <- function(input, output, server) {\n    output$msg <-  \"back end logic\"\n}\n\nshinyApp(ui, server)\n\n```\n\n`output` needs a reactive context, it has to be inside a render function.\n:::\n\n***\n\n> Error in `.subset2(x, \"impl\")$defineOutput(name, value, label)` :       \n> Unexpected character object for output$msg         \n> ℹ Did you forget to use a render function?\n\n::::\n:::::\n\nForgetting to put the `output` inside a render function results in the above error.\n\n###### output error 2\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-summary-output-error-2}\n: `output` needs a render function\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {#lst-03-summary-output-error-2}\n\n\n```{shinylive-r}\n#| standalone: true\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\nui <- fluidPage(\n    textOutput(\"msg\")\n)\n\n\nserver <- function(input, output, server) {\n    message(\"This is the \", output$msg)\n}\n\nshinyApp(ui, server)\n\n```\n\nYou can't read from `output` outside a reactive context.\n:::\n\n***\n> Error in `output$msg` : Can't read output 'msg'\n\n::::\n:::::\n\nReading from the `output` is not allowed\n\n\n:::\n\n\n\n::::\n:::::\n\n:::\n\n### Reactivity template\n\nThe most elemental shiny app has just one <a class='glossary' title='In Shiny, reactive contexts are essential for handling user inputs and updating outputs automatically. Reactive values can only be accessed within a reactive context, meaning they must be used inside functions like reactive(), observer(), or any render*() functions.'>reactive context</a>. It consists of one `output` that is automatically updated whenever its only `input` changes.\n\nThe next example implements this minimal reactivity in Shiny. \n\n\n::: {.column-body-outset}\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-summary-reactivity-template}\n: Five parts of a reactive context\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {#lst-summary-reactivity-template}\n\n```{shinylive-r}\n#| standalone: true\n#| components: [editor, viewer]\n\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  output$greeting <- renderText({\n    paste0(\"Hello \", input$name, \"!\")\n  })\n}\n\nshinyApp(ui, server)\n```\n\nFive parts of a reactive context \n:::\n::::\n:::::\n\n:::\n\nThe above code works for me as a kind of mental device that helps me to remember the five parts of a reactive context:\n\n1. **Input in the UI function**, so that user can provide whatever input they want (but restricted to the list of Shiny input categories.)\n2. **Output in the UI function**, so that the provided input can be transferred to the server logic.\n3. **Input in the server function** with the fixed pattern `input$<inputID>` where `inputID` works as a reference to the front end.\n4. **Output in the server function** with the pattern `output$<outputID>` where `outputID` is a reference to the front end type of output.\n5. **Reactive function** appropriate for the output type which assigns /connect the `input$<inputID>` to the `output$<outputID>`. \n\nor in a more general form:\n\n1. `<type>Input` with `<type>InputID` (UI)\n2. `<type>Output` with `<type>OutputID` (UI)\n3. `input$<inputID>` (server)\n4. `output$<outputID>` (server)\n5. reactive function\n\n### Reactive expressions\n\n#### Basic principle\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-summary-reactive-expression}\n: Reactive Expression\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\nui <- fluidPage(\n    textInput(\"name\", \"What's your name?\"),\n    textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n    string <- reactive(paste0(\"Hello \", input$name, \"!\"))\n    output$greeting <- renderText(string())\n}\n\nshinyApp(ui, server)\n```\n\n***\n\nCompare the code with @lst-summary-reactivity-template.\n::::\n:::::\n\n\nThe important point of <a class='glossary' title='Reactive expressions are a key component of reactive programming in Shiny. They are R expressions that use widget input and return a value, updating this value whenever the original widget changes. Reactive expressions cache their values and know when their values have become outdated, which helps in preventing unnecessary re-computation and makes the app faster.'>reactive expressions</a> is that they mediate between `input` and `output`. `string` works as an mediator between `input$name` and `output$greeting`. \n\nWe can think of reactive expressions as tools to reduces duplication in the reactive code by introducing additional nodes into the <a class='glossary' title='In Shiny, the reactive graph is a powerful tool for understanding how your app works. It shows how inputs and outputs are connected, allowing you to visualize the dependencies and execution order of your reactive expressions and render functions. This graph is particularly useful as your app becomes more complex, helping you to manage and debug the interdependencies between different components of your app. To visualize the reactive graph, you can use the reactlog package, which provides an interactive browser-based tool for visualizing reactive dependencies and execution in your application.'>reactive graph</a>. Te reactive expression can be used like a function and like a function it is called with `()` at the end of its name. But it never has arguments between its parenthesis. \n\n\n#### Practical example\n\nIn the case above we didn't use the additional node, to simplify the code. In order to understand why we need <a class='glossary' title=''>reactivce epxressions</a> we need a more complex example. Hadley offers in the book the comparison of two simulated datasets with a plot and a hypothesis test. \n\nI am planning to generate a simpler example. STILL TO DO -> @XXX_practical-example\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}