{
  "hash": "96160c99dfa7a0ecddd301669791ea88",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n  cache: true\n---\n\n# Workflow {#sec-chap05}\n\n\n\nIf you’re going to be writing a lot of Shiny apps (and since you’re\nreading this book I hope you will be!), it’s worth investing some time\nin your basic workflow. Improving workflow is a good place to invest\ntime because it tends to pay great dividends in the long run. It doesn’t\njust increase the proportion of your time spent writing R code, but\nbecause you see the results more quickly, it makes the process of\nwriting Shiny apps more enjoyable, and helps your skills improve more\nquickly.\n\n:::::: {#obj-chap05}\n::::: my-objectives\n::: my-objectives-header\nObjectives of chapter on Workflow\n:::\n\n::: my-objectives-container\nThe goal of this chapter is to help you improve three important Shiny\nworkflows:\n\n-   The basic development cycle of creating apps, making changes, and\n    experimenting with the results.\n-   Debugging, the workflow where you figure out what’s gone wrong with\n    your code and then brainstorm solutions to fix it.\n-   Writing <a class='glossary' title='Reprex is an REPRoducable EXample. A reprex makes a conversation about code more efficient and pleasant for all. This comes up whenever you ask someone for help, report a bug in software, or propose a new feature. The habit of making little, rigorous, self-contained examples also has the great side effect of making you think more clearly about your programming problems. In R the reprex package (https://reprex.tidyverse.org) makes it especially easy to prepare R code as a reprex, in order to share it on GitHub, StackOverflow etc.'>reprexes</a>, self-contained chunks of\n    code that illustrate a problem. Reprexes are a powerful debugging\n    technique, and they are essential if you want to get help from\n    someone else.\n:::\n:::::\n::::::\n\n## Development workflow\n\nThere are two main workflows to optimize here:\n\n-   creating an app for the first time, and\n-   speeding up the iterative cycle of tweaking code and trying out the\n    results.\n\n### Creating the app\n\n#### Code snippets\n\nEvery app starts with the same six lines of R code. (The repetitive\nusage of code is not only for Shiny important. I have developed a huge\namount of code snippets for R and even more for Markdown). For instance\nall the (code) boxes (e.g., @lem-05-code-snippets) you see in my notes\nare created by inserting templates via code snippets. In the next\nparagraph I will type at the beginning of the line `num-resources` and\nwith SHIFT-TAB my template for a numbered resource box is created. I\njust have to add IDs for generating internal links and the content.\n\n``` markdown\n:::::{.my-resource}\n:::{.my-resource-header}\n:::::: {#lem-resource-text}\n: Numbered Resource Title\n::::::\n:::\n::::{.my-resource-container}\nHere include text for the resource\n::::\n:::::\n```\n\n:::::: my-resource\n:::: my-resource-header\n::: {#lem-05-code-snippets}\n: Code snippets\n:::\n::::\n\n::: my-resource-container\n-   [RStudio code\n    snippets](https://support.rstudio.com/hc/en-us/articles/204463668-Code-Snippets)\n-   [Shiny specific\n    snippets](https://github.com/ThinkR-open/shinysnippets) put together\n    by [ThinkR](https://github.com/ThinkR-open).\n-   [{**shinysnippets**}](https://thinkr-open.github.io/shinysnippets/)\n    package [@shinysnippets]\n:::\n::::::\n\n#### New Shiny project\n\nIf you want to start a new project, go to the File menu, select “New\nProject” then select “Shiny Web Application”.\n\n#### New Shiny app in existing project\n\nHere I am using my \"learning-shiny\" book project to develop several\nshiny apps. Go to the File menu, select \"New File\"-\\>\"Shiny Web App…\".\nThis opens up a window to name a folder where the `app.R` file for the\nShiny app is created. The name of the folder is essential as all Shiny\napps have the same file name (`app.R`) if you choose (as I do) a single\nfile app.\n\n![Window for creating a new shiny app inside a\nproject](img/new-shiny-app-min.png){#fig-05-01\nfig-alt=\"alt-text\" fig-align=\"center\" width=\"70%\"}\n\n#### New shinylive code chunk\n\nHere in this book I am predominantly using the {**shinylive**} package.\nTherefore I have prepared another markdown snippet.\n\n```` markdown\n:::{.column-page}\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-ID-text}\n: Numbered R Code Title\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 300\n#| components: [editor, viewer]\n#| layout: vertical\n\nlibrary(shiny)\n\nstart coding here\n```\n::::\n:::::\n\n:::\n````\n\n### Seeing the changes\n\nI knew about the shortcut `CMD-SHIFT-ENTER` for running the current code\nchunk. I didn't know that the same shortcut could be used for the shiny\napp. But it is a sensible generalization. What else is a shiny app as\none (big) code chunk?\n\nI didn't know nothing about background jobs except that it is invoked by\nrendering the Quarto file. Actually I don't know if it is still\nnecessary to invoke the procedure described in [Shiny apps in background\njobs](https://github.com/sol-eng/background-jobs/tree/main/shiny-job).\nThe reason is that Shiny will run in the background if I enter the\nshortcut CMD-SHIFT-ENTER inside the Shiny app script.\n\nThere is some small change about the workflow as described in the\nsection \"Seeing your changes\" in chapter 5 of the [website of the\nMastering Shiny book](https://mastering-shiny.org/action-workflow.html).\nInstead of \"Write some code and press Cmd/Ctrl + S to save the file.\" it\nworks for me with \"Write some code and press Cmd/Ctrl-Shift-Enter to\nsave and run the reloaded changed file.\"\n\n:::::: my-procedure\n:::: my-procedure-header\n::: {#prp-05-shiny-background-job}\n: Shiny background job\n:::\n::::\n\n::: my-procedure-container\n1.  Write some code and press Cmd/Ctrl-Shift-Enter.\n2.  Interactively experiment.\n3.  Go to 1.\n:::\n::::::\n\nThe chief disadvantage of this technique is that it’s considerably\nharder to debug because the app is running in a separate process.\n\nBut the general procedure to start background jobs inside the RStudio\nenvironment is very valuable for me. I could use background workflows\nwith lengthy rendering procedures of my Quarto note books.\n\n:::::: my-resource\n:::: my-resource-header\n::: {#lem-05-background-jobs}\n: Background jobs in the RStudio <a class='glossary' title='An Integrated Development Environment (IDE) is a software application that helps programmers develop software code efficiently. It typically includes features such as a source code editor, build automation tools, and a debugger.'>IDE</a>\n:::\n::::\n\n::: my-resource-container\n-   [Local Job Environment\n    Options](https://github.com/sol-eng/background-jobs/tree/main/shiny-job)\n-   [RStudio Background Jobs](https://posit.co/blog/rstudio-1-2-jobs/)\n:::\n::::::\n\n::: callout-important\nTo call the procedure in @prp-05-shiny-background-job you have to tick\nthe option \"In Background Job\" in the \"Run App\"-button (see @fig-05-02).\n(You see this window only in inside the script of the Shiny app.)\n:::\n\n### Controlling the view\n\nThere are three options (see @fig-05-02):\n\n1.  **Run in Window** open the app in a pop-out RStudio window. This has\n    the interesting side effect, that it always open an new tab if the\n    Shiny app is run again. This is nice for comparing different\n    version. If you have a second screen you can move the window out of\n    the code view and display both app code and app result at the same\n    time.\n2.  **Run in Viewer Pane** opens the app in the RStudio viewer pane\n    (usually located on the right hand (bottom) side of the\n    <a class='glossary' title='An Integrated Development Environment (IDE) is a software application that helps programmers develop software code efficiently. It typically includes features such as a source code editor, build automation tools, and a debugger.'>IDE</a>. It’s useful for smaller apps because\n    you can see it at the same time as you run your app code.\n3.  **Run External**\" opens the app in your usual web browser. It’s\n    useful for larger apps and when you want to see what your app looks\n    like in the context that most users will experience it. Again you\n    can look at both (Code and running app)at the same time with a\n    second display. (But I prefer the large main screen changing between\n    RStudio and browser with shortcuts.)\n\n![The run app button allows you to choose if the app runs in the console\nor as background job and how the running app will be\nshown](img/run-app-window-min.png){#fig-05-02\nfig-alt=\"alt-text\" fig-align=\"center\" width=\"30%\"}\n\nWith an external browser window there are is one observation I made: If\nyou shut down the background job or restart R then the browser window is\ninvalidated and running the app again will open a new tab in your\nbrowser. This is contrast to rendering a Quarto document showing in an\nexternal browser window. Closing this window will not show the new\nresults in a new browser window. You have to restart R, then RStudio\nwill open a new browser window after the rendering process is finished.\n\n## Debugging\n\nThere are three main cases of problems which we’ll discuss below:\n\n1.  **Unexpected error**: This is the easiest case, because you’ll get a\n    traceback which allows you to figure out exactly where the error\n    occurred. Once you’ve identified the problem, you’ll need to\n    systematically test your assumptions until you find a difference\n    between your expectations and reality. The interactive debugger is a\n    powerful assistant for this process.\n2.  **Incorrect value**: You don’t get any errors, but some value is\n    incorrect. Here, you’ll need to use the interactive debugger, along\n    with your investigative skills to track down the root cause.\n3.  **Shiny does not update correctly**: All the values are correct, but\n    they’re not updated when you expect. This is the most challenging\n    problem because it’s unique to Shiny, so you can’t take advantage of\n    your existing R debugging skills.\n\n### Talk by Jenny Brian {#sec-05-talk-jeyy-brian}\n\nI am relatively unexperienced with R debugging. So I started with the\nJenny Bryan's talk. What follows is short summary of the talk:\n\n:::::: my-procedure\n:::: my-procedure-header\n::: {#prp-04-debugging}\n: General debugging procedures following the Jenny Brian video lecture\n:::\n::::\n\n::: my-procedure-container\nThere are three general procedures:\n\n1.  **Restart R** very often and if it stuck restart RStudio. As a last\n    resort you could also start your computer. This cleans all hanging\n    cached variables or hanging processes. (This process I have already\n    standard behavior for me.)\n2.  **Reprex**: Learn how to communicate for help with *minimal*\n    <a class='glossary' title='Reprex is an REPRoducable EXample. A reprex makes a conversation about code more efficient and pleasant for all. This comes up whenever you ask someone for help, report a bug in software, or propose a new feature. The habit of making little, rigorous, self-contained examples also has the great side effect of making you think more clearly about your programming problems. In R the reprex package (https://reprex.tidyverse.org) makes it especially easy to prepare R code as a reprex, in order to share it on GitHub, StackOverflow etc.'>reprexes.</a> I am already used reprexes. It\n    is a challenge but very useful, sometimes I have solved the problem\n    on my own during the process of creating a minmal reprex.\n3.  **Debugging**: There are three different general aspects:\n    1.  `back::traceback()`, `last_trace::rlang()` is like reading a\n        death certificate. `back::traceback()` is to be read from bottom\n        to top; `last_trace::rlang()` is easier to read from top to\n        bottom and has a nested view.\n    2.  `base::options(error = utils::recover)`: This is like a\n        post-mortem autopsy. This function allows the user to browse\n        directly on any of the currently active function calls, and is\n        suitable as an error option. When called, recover prints the\n        list of current calls, and prompts the user to select one of\n        them. The standard R browser is then invoked from the\n        corresponding environment; the user can type ordinary R language\n        expressions to be evaluated in that environment such as:\n        `utils::ls.str()`.\n    3.  `base::browser()` statement (or in RStudio a break point)\n        written into the appropriate place of the code, general at the\n        start of a function. This is like a reanimation. Stopping\n        debugging with `Q` (Alternatives are `base::debug()` with\n        `base::undebug()`, `base::debugonce()` or in RStudio choose\n        `Stop Debugging` from the Debug menu or type the shortcut\n        `Shift-F8`).\n:::\n::::::\n\nRStudio has a very handy starting debugging feature where you choose to\nhide the traceback or to rerun it with debug.\n\n![RStudio debugging feature: Slide from Jenny Brian's video\ntalk](img/jenny-brian-rstudio-debugging-min.png){#fig-05-03\nfig-alt=\"alt-text\" fig-align=\"center\" width=\"100%\"}\n\n::: {#tip-05-debugging-jenny-brian .callout-tip}\n###### Deter next error\n\nAs debugging is intimidating Jenny Bryan recommends at the end of her\ntalk three debugging learning strategies:\n\n1.  Reserve a time box for debugging (e.g. 10-15 min) for the next error\n    I can't find immediately. If you haven't resolved the issue return\n    back to your used procedures. (This is easy to apply and I will try\n    it the next time.)\n2.  Prepare for the unexpected future by using the {**testthat**}\n    package. It supports a testing framework for R that integrates with\n    your existing 'workflow'.\n3.  Automate your check with `R CMD` check and `testthat::test_check()`\n4.  Use Github continuous integration\n:::\n\nOnly the first tip is at the moment for me easy to apply. Of the other\nthree strategies I have already heard, but they are at the moment in my\ndaily work behavior with R difficult to include. I will try them out\nwhen I return to develop an R package for general use.\n\n### Tracebacks in Shiny\n\nYou can’t use traceback() in Shiny because you can’t run code while an\napp is running. Instead, Shiny will automatically print the traceback\nfor you.\n\n::::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-05-shiny-traceback}\n: Example: Traceback in {**shiny**}\n:::\n::::\n\n:::: my-r-code-container\n::: {#lst-05-shiny-traceback}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nf <- function(x) g(x)\ng <- function(x) h(x)\nh <- function(x) x * 2\n\nui <- fluidPage(\n  selectInput(\"n\", \"N\", 1:10),\n  plotOutput(\"plot\")\n)\nserver <- function(input, output, session) {\n  output$plot <- renderPlot({\n    n <- f(input$n)\n    plot(head(cars, n))\n  }, res = 96)\n}\nshinyApp(ui, server)\n```\n:::\n\n\nAn example of Shiny traceback\n:::\n\nThe following error message is faked (copied from a live shiny app),\nbecause it does not work with {**shinylive**}. {**shinylive**} produces\njust the same message as inside the app:\n\n`Error: non-numeric argument to binary operator`\n\n``` markdown\nWarning: Error in *: non-numeric argument to binary operator\n  178: g […/app.R#4]\n  177: f […/app.R#3]\n  176: renderPlot […/app.R#13]\n  174: func\n  134: drawPlot\n  120: <reactive:plotObj>\n  100: drawReactive\n   87: renderFunc\n   86: output$plot\n    1: shiny::runApp\n```\n\nI have the first three line edited so that they do not reveal my\ninternal directory organisation.\n::::\n:::::::\n\nTo understand what’s going on we again start by flipping it upside down,\nso you can see the sequence of calls in the order they appear:\n\n``` markdown\n    1: shiny::runApp\n   86: output$plot\n   87: renderFunc\n  100: drawReactive\n  120: <reactive:plotObj>\n  134: drawPlot\n  174: func\n  176: renderPlot […/app.R#13]\n  177: f […/app.R#3]\n  178: g […/app.R#4]\n```\n\nThere are three basic parts to the call stack:\n\n1.  **Starting the app**: The first few calls start the app. In this\n    case, you just see `shiny::runApp()`, but depending on how you start\n    the app, you might see something more complicated. For example, if\n    you called `base::source()` to run the app, you might see this:\n\n``` markdown\n1: source\n3: print.shiny.appobj\n5: runApp\n```\n\nIn general, you can ignore anything before the first `runApp()`; this is\njust the setup code to get the app running.\n\n2.  **Reactive expression**: Next, you’ll see some internal Shiny code\n    in charge of calling the reactive expression:\n\n``` markdown\n   86: output$plot\n   87: renderFunc\n  100: drawReactive\n  120: <reactive:plotObj>\n  134: drawPlot\n  174: func\n```\n\nHere, spotting `output$plot` is really important — that tells which of\nyour reactives (plot) is causing the error. The next few functions are\ninternal, and you can ignore them.\n\n3.  **Actual code**: Finally, at the very bottom, you’ll see the code\n    that you have written:\n\n``` markdown\n  176: renderPlot […/app.R#13]\n  177: f […/app.R#3]\n  178: g […/app.R#4]\n```\n\nThis is the code called inside of `renderPlot()`. You can tell you\nshould pay attention here because of the file path and line number; this\nlets you know that it’s your code.\n\n::: callout-warning\nIf you get an error in your app but don’t see a traceback then make sure\nthat you’re running the app using `Cmd/Ctrl + Shift + Enter` (or if not\nin RStudio, calling `runApp()`), and that you’ve saved the file that\nyou’re running it from. Other ways of running the app don’t always\ncapture the information necessary to make a traceback.\n:::\n\n### The interactive debugger\n\nOnce you’ve located the source of the error and want to figure out\nwhat’s causing it, the most powerful tool you have at your disposal is\nthe interactive debugger. The debugger pauses execution and gives you an\ninteractive R console where you can run any code to figure out what’s\ngone wrong. There are two ways to launch the debugger:\n\n1.  **browser() function call**: Add a call to `base::browser()` in your\n    source code. This is the standard R way of launching the interactive\n    debugger, and will work however you’re running Shiny. The advantage\n    of `browser()` is that because it’s R code, you can make it\n    conditional by combining it with an `if` statement. This allows you\n    to launch the debugger only for problematic inputs.\n\n``` markdown\nif (input$value == \"a\") {\n  browser()\n}\n# Or maybe\nif (my_reactive() < 0) {\n  browser()\n}\n```\n\n2.  **RStudio breakpoint**: Add an RStudio breakpoint by clicking to the\n    left of the line number. You can remove the breakpoint by clicking\n    on the red circle. The advantage of breakpoints is that they’re not\n    code, so you never have to worry about accidentally checking them\n    into your version control system.\n\n![Setting a breakpoint in\nRStudio](img/breakpoint-debugger-min.png){#fig-05-04\nfig-alt=\"alt-text\" fig-align=\"center\" width=\"70%\"}\n\nIf you’re using RStudio, the toolbar in @fig-05-05 will appear at the\ntop of the console when you’re in the debugger. The toolbar is an easy\nway to remember the debugging commands that are now available to you.\nThey’re also available outside of RStudio; you’ll just need to remember\nthe one letter command to activate them. The three most useful commands\nare:\n\n-   **Next (press n)**: executes the next step in the function. Note\n    that if you have a variable named `n`, you’ll need to use `print(n)`\n    to display its value.\n-   **Continue (press c)**: leaves interactive debugging and continues\n    regular execution of the function. This is useful if you’ve fixed\n    the bad state and want to check that the function proceeds\n    correctly.\n-   **Stop (press Q)**: stops debugging, terminates the function, and\n    returns to the global workspace. Use this once you’ve figured out\n    where the problem is, and you’re ready to fix it and reload the\n    code.\n\n![RStudio's debugging scenario: Waiting at the breakpoint, involing the\ndebugger](img/invoke-debugger-min.png){#fig-05-05\nfig-alt=\"alt-text\" fig-align=\"center\" width=\"70%\"}\n\nAs well as stepping through the code line-by-line using these tools,\nyou’ll also write and run a bunch of interactive code to track down\nwhat’s going wrong. Debugging is the process of systematically comparing\nyour expectations to reality until you find the mismatch. If you’re new\nto debugging in R, you might want to read the [Debugging chapter of\n“Advanced R”](https://adv-r.hadley.nz/debugging.html) to learn some\ngeneral techniques.\n\n:::::: my-resource\n:::: my-resource-header\n::: {#lem-05-debugging}\n: Debugging\n:::\n::::\n\n::: my-resource-container\nI have collected some resources for interactive debugging in R.\n\n-   Jenny Bryan video keynote at the rstudio::conf(2020): “[Object of\n    type ‘closure’ is not\n    subsettable](https://posit.co/resources/videos/object-of-type-closure-is-not-subsettable/)”.[^05-workflow-1]\n-   Jenny Bryan [Additional material and links from the above\n    talk](https://github.com/jennybc/debugging#readme) to introduce R\n    debugging.\n-   Jonathan McPherson (posit): [Debugging with the RStudio\n    IDE](https://support.posit.co/hc/en-us/articles/205612627-Debugging-with-the-RStudio-IDE)\n-   [RStudio User Guide on\n    Debugging](https://docs.posit.co/ide/user/ide/guide/code/debugging.html)\n-   Hadley Wickham: General advise and problem-solving strategies in\n    [Debugging](https://adv-r.hadley.nz/debugging.html) (Chapter 22 in\n    the second edition of the [Advanced R\n    book](https://adv-r.hadley.nz/index.html)).\n-   The {**rlang**} package is a [collection of frameworks and APIs for\n    programming with R](https://rlang.r-lib.org/). (I've already learned\n    about this package, but it seems that it is — at least at the\n    moment, June 2025 — a resource for more experienced programmers than\n    me.)\n:::\n::::::\n\n[^05-workflow-1]: This is for me an incomprehensibe error message that I\n    have already experienced several times. It helps very much to\n    replace 'closure' with 'function'.\n\n### Case study\n\nI skip over the interesting and illuminating case study because\nreproducing the reported strategies is not educationally valuable. I\nwould need my own problem to debug.\n\n::: callout-important\nIn the case study there are two important learnings for me:\n\n1.  Assuming some line of code is the trouble maker try to reproduce the\n    problem in the console outside the debugger!\n2.  Inside the debugger try the interactive console to verify if you are\n    in problematic line of code!\n:::\n\nBy the way: I ran over a similar problem as reported in the case study.\nInstead of confusing \"NA\" for North America with `NA` I had the [ISO\n3166](https://www.iso.org/iso-3166-country-codes.html) two letter\ncountry code (alpha2) with \"NA\". (See filteredc [dataset to \"Namibia\" in\nopendatasoft](https://public.opendatasoft.com/explore/dataset/countries-codes/table/?flg=en-us&q=namibia))\n\n### Debugging reactivity\n\nThe hardest type of problem to debug is when your reactives fire in an\nunexpected order. At this point in the book, we have relatively few\ntools to recommend to help you debug this issue. In the next section,\nyou’ll learn how to create a minimal <a class='glossary' title='Reprex is an REPRoducable EXample. A reprex makes a conversation about code more efficient and pleasant for all. This comes up whenever you ask someone for help, report a bug in software, or propose a new feature. The habit of making little, rigorous, self-contained examples also has the great side effect of making you think more clearly about your programming problems. In R the reprex package (https://reprex.tidyverse.org) makes it especially easy to prepare R code as a reprex, in order to share it on GitHub, StackOverflow etc.'>reprex</a> which is\ncrucial for this type of problem, and later in the book, you’ll learn\nmore about the underlying theory, and about tools like the [reactivity\nvisualizer](https://github.com/rstudio/reactlog) {**reactlog**}\n[@reactlog]. But for now, we’ll focus on a classic technique that’s\nuseful here: “print” debugging.\n\nThe basic idea of print debugging is to call `print()` whenever you need\nto understand when a part of your code is evaluated, and to show the\nvalues of important variables. We call this “print” debugging (because\nin most languages you’d use a print function), but In R it makes more\nsense to use `message()`:\n\n-   `base::print()` is designed for displaying vectors of data so it\n    puts quotes around strings and starts the first line with \"\\[1\\]\".\n-   `base::message()` sends its result to “standard error”, rather than\n    “standard output”. These are technical terms describing output\n    streams, which you don’t normally notice because they’re both\n    displayed in the same way when running interactively. But if your\n    app is hosted elsewhere, then output sent to “standard error” will\n    be recorded in the logs.\n\nI also recommend coupling `message()` with the `glue()` function from\nthe {**glue**} package, which makes it easy to interleave text and\nvalues in a message.[^05-workflow-2]\n\n[^05-workflow-2]: As I am already comfortable to use `glue()` I skip the\n    demonstration how to use the {**glue**} package.\n\nA final useful tool is `utils::str()`, which prints the detailed\nstructure of any object. This is particularly useful if you need to\ndouble check you have the type of object that you expect.\n\nSummarized there are three tools for print debugging at this state of\nthe notes:\n\n-   `base::message()`\n-   `glue::glue()`\n-   `utils::str()`\n\nHere’s a toy app that shows off some of the basic ideas. Note how I use\nmessage() inside a reactive(): I have to perform the computation, send\nthe message, and then return the previously computed value.\n\n:::::::::::::::: my-code-collection\n::::: my-code-collection-header\n::: my-code-collection-icon\n:::\n\n::: {#exm-05-print-debugging}\n: Toy example with print debugging\n:::\n:::::\n\n:::::::::::: my-code-collection-container\n::::::::::: panel-tabset\n###### Version 1 (Hadley)\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-05-print-debugging-hadley}\n: Toy example from the book\n:::\n::::\n\n::: my-r-code-container\n```{shinylive-r}\n#| standalone: true\n#| components: [editor, viewer]\n\nlibrary(shiny)\nlibrary(glue)\n\nui <- fluidPage(\n  sliderInput(\"x\", \"x\", value = 1, min = 0, max = 10),\n  sliderInput(\"y\", \"y\", value = 2, min = 0, max = 10),\n  sliderInput(\"z\", \"z\", value = 3, min = 0, max = 10),\n  textOutput(\"total\")\n)\nserver <- function(input, output, session) {\n  observeEvent(input$x, {\n    message(glue(\"Updating y from {input$y} to {input$x * 2}\"))\n    updateSliderInput(session, \"y\", value = input$x * 2)\n  })\n\n  total <- reactive({\n    total <- input$x + input$y + input$z\n    message(glue(\"New total is {total}\"))\n    total\n  })\n\n  output$total <- renderText({\n    total()\n  })\n}\n\nshinyApp(ui, server)\n```\n\n***\n\nI can't demonstrate printing the output inside a reactive code snippet with {**shinylive**} here. Only the output in the not reactive `output$total` will appear.  So I faked the output with copy and paste from the online book:\n\n```markdown\n\nUpdating y from 2 to 2\nNew total is 6\n\n```\n\nAnd if I drag the x slider to 3 I see\n\n```markdown\n\nUpdating y from 2 to 6\nNew total is 8\nNew total is 12\n\n```\n\nDon’t worry if you find the results a little surprising. \n\n::: {.callout-note}\nYes, in fact, this *is* surprising for me, as I get the new total twice! I’ll will wait to learn more about what’s going on in @XXX_8 with the help of the reactive graph diagrams mentioned in @sec-03-reactive-graph.\n\nIn the meanwhile I have in the next tab changed text and place of the messages in this toy example.\n:::\n\n\n:::\n::::::\n\n###### Version 2 (my own example)\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-05-print-debugging-my-own}\n: Toy example with my own print debugging messages\n:::\n::::\n\n::: my-r-code-container\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(glue)\n\nui <- fluidPage(\n    sliderInput(\"x\", \"x\", value = 1, min = 0, max = 10),\n    sliderInput(\"y\", \"y\", value = 2, min = 0, max = 10),\n    sliderInput(\"z\", \"z\", value = 3, min = 0, max = 10),\n    textOutput(\"total\")\n)\nserver <- function(input, output, session) {\n    observeEvent(input$x, {\n        updateSliderInput(session, \"y\", value = input$x * 2)\n    })\n\n    total <- reactive({\n        total <- input$x + input$y + input$z\n        message(glue(\"New total is x+y+z = {input$x} + {input$y} + {input$z} = {total}\"))\n        total\n    })\n\n    output$total <- renderText({\n        total()\n    })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n***\n\nThe printing command in the `total` reactive is easier to understand for me. But I think the places for the `message()` command in the book example are on those other places to show an specific behavior of the reactivity behavior of this Shiny toy example.\n\n```markdown\n\n> shiny::runApp('apps-05/print-debugging')\nLoading required package: shiny\n\nListening on http://127.0.0.1:7653\n\n# After started the app\nNew total is x+y+z = 1 + 2 + 3 = 6\n\n# After dragging the x slider to 3\nNew total is x+y+z = 3 + 2 + 3 = 8\nNew total is x+y+z = 3 + 6 + 3 = 12\n\n```\n\n:::\n::::::\n\n:::::::::::\n\n\n::::::::::::\n::::::::::::::::\n\n## Getting help\n\nI will shorten this section as I have already some experiences with <a class='glossary' title='Reprex is an REPRoducable EXample. A reprex makes a conversation about code more efficient and pleasant for all. This comes up whenever you ask someone for help, report a bug in software, or propose a new feature. The habit of making little, rigorous, self-contained examples also has the great side effect of making you think more clearly about your programming problems. In R the reprex package (https://reprex.tidyverse.org) makes it especially easy to prepare R code as a reprex, in order to share it on GitHub, StackOverflow etc.'>reprexes</a>. I will focus on those points that are not so obvious for me.\n\n### Reprex basics {#sec-05-reprex-basics}\n\n**{reprex} package**: In the book the usage of the [{reprex} package](https://reprex.tidyverse.org/) is not mentioned. It is a very useful tool and simplifies the technical process of catching the code. I am using the {**reprex**} package [@reprex] with [RStudio addins](https://rstudio.github.io/rstudioaddins/), because that makes it much comfortable to use.\n\n### Making a reprex\n\nThis section does not mention the technical process  but focuses on conceptional issues.\n\nTypically, the most challenging part of making your app work on someone else’s computer is eliminating the use of data that’s only stored on your computer. There are four useful patterns:\n\n#### Built-in datset\n\nOften the data you’re using is not directly related to the problem, and you can instead use a built-in dataset like mtcars or iris.\n\n#### R Code dataset\n\nOther times, you might be able to write a little R code that creates a dataset that illustrates the problem:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmydata <- data.frame(x = 1:5, y = c(\"a\", \"b\", \"c\", \"d\", \"e\"))\nmydata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   x y\n#> 1 1 a\n#> 2 2 b\n#> 3 3 c\n#> 4 4 d\n#> 5 5 e\n```\n\n\n:::\n:::\n\n\n\n#### `dput()` dataset\n\nIf both of those techniques fail, you can turn your data into code with base::dput(). For example, `dput(mydata)` generates the code that will recreate `mydata```:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndput(mydata)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> structure(list(x = 1:5, y = c(\"a\", \"b\", \"c\", \"d\", \"e\")), class = \"data.frame\", row.names = c(NA, \n#> -5L))\n```\n\n\n:::\n:::\n\n\n\n\nOnce you have that code, you can put this in your reprex to generate `mydata`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmydata <- structure(list(x = 1:5, y = structure(1:5, .Label = c(\"a\", \"b\",\n\"c\", \"d\", \"e\"), class = \"factor\")), class = \"data.frame\", row.names = c(NA,\n-5L))\nmydata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   x y\n#> 1 1 a\n#> 2 2 b\n#> 3 3 c\n#> 4 4 d\n#> 5 5 e\n```\n\n\n:::\n:::\n\n\n\nOften, running `dput()` on your original data will generate a huge amount of code, so find a subset of your data that illustrates the problem. The smaller the dataset that you supply, the easier it will be for others to help you with your problem.\n\n#### Complete project\n\nIf reading data from disk seems to be an irreducible part of the problem, a strategy of last resort is to provide a complete project containing both an app.R and the needed data files. The best way to provide this is as a **RStudio project hosted on GitHub**, but failing that, you can carefully make a **zip file that can be run locally**. \n\nMake sure that you use relative paths (i.e. `read.csv(\"my-data.csv\")` not `read.csv(\"c:\\\\my-user-name\\\\files\\\\my-data.csv\"))` so that your code still works when run on a different computer.\n\nYou should also consider the reader and spend some time formatting your code so that it’s easy to read. If you adopt the tidyverse style guide, you can automatically reformat your code using the {**styler**} package; that quickly gets your code to a place that’s easier to read.\n\n### Making a minimal reprex\n\nCreating the smallest possible reprex is particularly important for Shiny apps, which are often complicated. But — as Jenny Bryan mentioned in her talk (see @sec-05-talk-jeyy-brian) — creating a minimal reprex is both a science and an art.\n\n::: {.callout-tip #tip-05-making-minimal-reprex}\n###### Debugging strategy but also a way to make a minimal reprex\n\n- If you don’t know what part of your code is triggering the problem, a good way to find it is to remove sections of code from your application, piece by piece, until the problem goes away. \n- Alternatively, sometimes it’s simpler to start with a fresh, empty, app and progressively build it up until you find the problem once more.\n\n:::\n\n::: {.my-checklist}\n\n::::{.my-checklist-header} \n::::: {.my-checklist-icon}\n:::::\n::::::  {#tdo-05-reprex}\n:::::: \n: Take a final pass through your Reprex\n::::\n\n:::: {.my-checklist-body} \n- Is every input and output in UI related to the problem?\n- Does your app have a complex layout that you can simplify to help focus on the problem at hand? Have you removed all UI customisation that makes your app look good, but isn’t related to the problem?\n- Are there any reactives in `server()` that you can now remove?\n- If you’ve tried multiple ways to solve the problem, have you removed all the vestiges of the attempts that didn’t work?\n- Is every package that you load needed to illustrate the problem? Can you eliminate packages by replacing functions with dummy code?\n::::\n\n:::\n\n### Case Study\n\nAgain I will skip the case study, especially as I can't demonstrate it with a {**shinylive*} chunk. But I have provided the shiny apps in the \"app05\" folder.\n\nAnother remark: I got slightly different error messages. For instance instead of \"“Type mismatch for min, max, and value. Each must be Date, POSIXt, or number” in the first case study example I got \"Error in min: invalid 'type' (list) of argument\" with my experiment in the console.\n\n## Summary\n\nThis chapter has given you some useful workflows for developing apps, debugging problems, and getting help. These workflows might seem a little abstract and easy to dismiss because they’re not concretely improving an individual app. But I think of workflow as one of my “secret” powers: one of the reasons that I’ve been able to accomplish so much is that I devote time to analysing and improving my workflow. I highly encourage you to do the same!\n\nThe next chapter on layouts and themes is the first of a grab bag of useful techniques. There’s no need to read in sequence; feel free to skip ahead to a chapter that you need for a current app.\n\n::: {.callout-note #nte-next-chapter}\nI will follow the advice and continue with #sec-chap09 because I need the upload of a dataset for the work on my first real Shiny app.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}