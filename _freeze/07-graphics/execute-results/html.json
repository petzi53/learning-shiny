{
  "hash": "9992243892bfe1ff08ac226cbd9d97c1",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n  cache: true\n---\n\n# Graphics {#sec-chap07}\n\n\n\n## Introduction\n\n::::: {#obj-chap07}\n:::: {.my-objectives}\n::: {.my-objectives-header}\nChapter section list\n:::\n\n::: {.my-objectives-container}\n\n1. Using `renderPlot()` to create interactive plots, plots that respond to mouse events.\n2. Couple of other useful techniques, including \n    - making plots with dynamic width and height and \n    - displaying images with `renderImage()`.\n\n\n:::\n::::\n:::::\n\n\n## Introduction\n\nOne of the coolest things about `plotOutput()` is that as well as being an output that displays plots, it can also be an input that responds to pointer events. That allows you to create interactive graphics where the user interacts directly with the data on the plot.\n\n### Basics\n\nA plot can respond to four different mouse events: \n\n1. `click`, \n2. `dblclick`: double click, \n3. `hover`: the mouse stays in the same place for a little while, and \n4. `brush`: a rectangular selection tool\n\nTo turn these events into Shiny inputs, you supply a string to the corresponding `plotOutput()` argument, e.g. `plotOutput(\"plot\", click = \"plot_click\")`. This creates an `input$plot_click` that you can use to handle mouse clicks on the plot.\n\n::: {.column-body-outset}\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-07-plot-click-basics}\n: Click inside the image to get mouse coordinates\n::::::\n:::\n::::{.my-r-code-container}\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 500\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\nui <- fluidPage(\n  plotOutput(\"plot\", click = \"plot_click\"),\n  verbatimTextOutput(\"info\")\n)\n\nserver <- function(input, output) {\n  output$plot <- renderPlot({\n    plot(mtcars$wt, mtcars$mpg)\n  }, res = 96)\n\n  output$info <- renderPrint({\n    req(input$plot_click)\n    x <- round(input$plot_click$x, 2)\n    y <- round(input$plot_click$y, 2)\n    cat(\"[\", x, \", \", y, \"]\", sep = \"\")\n  })\n}\n\nshinyApp(ui, server)\n```\n\n\n::::\n:::::\n\n\n:::\n\nNote the use of `req()`, to make sure the app doesn’t do anything before the first click, and that the coordinates are in terms of the underlying `wt` and `mpg` variables.\n\n:::::{.my-procedure}\n:::{.my-procedure-header}\nStructure of the following sections\n:::\n::::{.my-procedure-container}\nThe following sections describe the events in more details. \n\n- `click` events \n- other point events (`dblclick`, `hover`)\n- `brush` event (defining a rectangular area: `xmin`, `xmax`, `ymin`, and `ymax`)\n- examples of plot updating events\n- limitation of interactive graphics in Shiny\n\n::::\n:::::\n\n\n\n\n\n### Clicking {#sec-07-clicking}\n\nThe point events return a relatively rich list containing a lot of information. The most important components are `x` and `y`, which give the location of the event in data coordinates. \n\nI’m not going to talk about this data structure, since you’ll only need it in relatively rare situations.\n\n:::::{.my-resource}\n:::{.my-resource-header}\n:::::: {#lem-07-list-point-events}\n: List of point events\n::::::\n:::\n::::{.my-resource-container}\n\nLearn about the complex details for point events using an [app in the Shiny gallery](https://gallery.shinyapps.io/095-plot-interaction-advanced/).\n\nIf you want to see just the returned values for the input click in @cnj-07-plot-click-basics  replace the last line with the `cat()`arguments to `input$plot_click`.\n\n\n::::\n:::::\n\n\n\nInstead of explaining all the details, we’ll use the `nearPoints()` helper, which returns a data frame containing rows near the click, taking care of a bunch of fiddly details. You have to click near a point otherwise the function would do nothing because it's name is `nearPoints()` and **not** `nearestPoint()`.\n\nAnother way to use `nearPoints()` is with `allRows = TRUE` and `addDist = TRUE`. That will return the original data frame with two new columns:\n\n- `dist_` gives the distance between the row and the event (in pixels).\n- `selected_` says whether or not it’s near the click event (i.e. whether or not its a row that would be returned when `allRows = FALSE`).\n\n\n::: {.column-page-inset}\n\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-07-plot-click}\n: Using nearPoints()\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### `plot()`\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-07-near-points-plot}\n: `nearPoints()` example with `base::plot()`\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 650\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\nui <- fluidPage(\n  plotOutput(\"plot\", click = \"plot_click\"),\n  tableOutput(\"data\")\n)\nserver <- function(input, output, session) {\n  output$plot <- renderPlot({\n    plot(mtcars$wt, mtcars$mpg)\n  }, res = 96)\n  \n  output$data <- renderTable({\n     nearPoints(mtcars, input$plot_click, \n                xvar = \"wt\", yvar = \"mpg\")\n  })\n}\n\nshinyApp(ui, server)\n```\n\n\n::::\n:::::\n\n\n###### `ggplot()`\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-07-near-points-ggplot}\n: `nearPoints()` example with `ggplot2::ggplot()`\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 650\n#| components: [editor, viewer]\n\nlibrary(shiny)\nlibrary(ggplot2)\nggplot2::theme_set(ggplot2::theme_bw())\n\nui <- fluidPage(\n  plotOutput(\"plot\", click = \"plot_click\"),\n  tableOutput(\"data\")\n)\nserver <- function(input, output, session) {\n  output$plot <- renderPlot({\n    ggplot(mtcars, aes(wt, mpg)) + geom_point()\n  }, res = 96)\n  \n  output$data <- renderTable({\n    req(input$plot_click)\n    nearPoints(mtcars, input$plot_click)\n  })\n}\n\nshinyApp(ui, server)\n```\n\n\n::::\n:::::\n\n###### `ggplot()` with `allRows = TRUE` and `addDist = TRUE`\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-07-near-points-ggplot}\n: `nearPoints()` example as a `ggplot2::ggplot()` with `allRows = TRUE` and `addDist = TRUE`\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 1600\n#| components: [editor, viewer]\n\nlibrary(shiny)\nlibrary(ggplot2)\nggplot2::theme_set(ggplot2::theme_bw())\n\nui <- fluidPage(\n  plotOutput(\"plot\", click = \"plot_click\"),\n  tableOutput(\"data\")\n)\nserver <- function(input, output, session) {\n  output$plot <- renderPlot({\n    ggplot(mtcars, aes(wt, mpg)) + geom_point()\n  }, res = 96)\n  \n  output$data <- renderTable({\n    req(input$plot_click)\n    nearPoints(mtcars, input$plot_click,\n               allRows = TRUE,\n               addDist = TRUE)\n  })\n}\n\nshinyApp(ui, server)\n```\n\n\n***\n\n***\n\nYou may experiment and try a different (combination of) arguments, for instance changing the `threshold` and / or `maxpoints`, turning `addDist` and / or `allRows` on or off.\n\n::::\n:::::\n\n\n:::\n\n::::\n:::::\n\n:::\n\n\n\nYou might wonder exactly what `nearPoints()` returns. This is a good place to use `base::browser()`, which was discussed in @sec-05-interactive-debugger.\n\n1. Replace the `outputoutput$data <- renderTable()` function with:\n\n````markdown\n\n  output$data <- renderTable({\n    req(input$plot_click)\n    browser()\n    nearPoints(mtcars, input$plot_click)\n  })\n````\n2. Restart the app.\n3. Click inside the plot in the resulted web page.\n4. Then you will see in the console the following text:\n  \n```console\n> runApp('apps-07/click-browser')\nListening on http://127.0.0.1:5962\nCalled from: eval(expr, p)\nBrowse[1]> n\ndebug at /Users/petzi/Documents/Meine-Repos/learning-shiny/apps-07/click-browser/app.R#16: nearPoints(mtcars, input$plot_click)\nBrowse[1]>\n```\n\n5. Continue in the second `Browse[1]>` line, where the  cursor stops, with\n\n```console\nBrowse[1]> nearPoints(mtcars, input$plot_click)\n               mpg cyl  disp hp drat    wt  qsec vs am gear carb\nToyota Corona 21.5   4 120.1 97  3.7 2.465 20.01  1  0    3    1\n```\n\n6. The last line will differ depending where the mouse click occurred.\n\n::: {.callout-important}\n![Debugging works only in the Shiny app (not in `shinylive`) and must run in console mode (not in a background job).](img/run-app-window-chap07-min.png){#fig-07-01\nfig-alt=\"alt-text\" fig-align=\"center\" \nwidth=\"30%\"}\n\n:::\n\n\n### Other point events\n\nThe same approach works equally well with `click`, `dblclick`, and `hover`: just change the name of the argument. If needed, you can get additional control over the events by supplying `clickOpts()`, `dblclickOpts()`, or `hoverOpts()` instead of a string giving the input id. These are rarely needed, so I won’t discuss them here; see the documentation for details.\n\nYou can use multiple interactions types on one plot. Just make sure to explain to the user what they can do: one downside of using mouse events to interact with an app is that they’re not immediately discoverable.\n\n### Brushing\n\nAnother way of selecting points on a plot is to use a brush, a rectangular selection defined by four edges. In Shiny, using a brush is straightforward once you’ve mastered `click` and `nearPoints()`: you just switch to `brush` argument and the `brushedPoints()` helper.\n\n::: {.column-page-inset}\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-07-brush-examples}\n: Brush examples\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Basic brush\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-07-basic-brush}\n: Draggable ‘brush’ to draw a box around a rectangular area\n::::::\n:::\n::::{.my-r-code-container}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n#| components: [editor, viewer]\n\nlibrary(shiny)\nlibrary(ggplot2)\nggplot2::theme_set(ggplot2::theme_bw())\n\nui <- fluidPage(\n  plotOutput(\"plot\", brush = \"plot_brush\"),\n  tableOutput(\"data\")\n)\nserver <- function(input, output, session) {\n  output$plot <- renderPlot({\n    ggplot(mtcars, aes(wt, mpg)) + geom_point()\n  }, res = 96)\n  \n  output$data <- renderTable({\n    brushedPoints(mtcars, input$plot_brush)\n  })\n}\n\nshinyApp(ui, server)\n```\n\n***\n\nPlay around with this app. Use for instance `brushOpts()` to control the color (fill and stroke). You will find an example solution in the next tab. Or restrict brushing to a single dimension with direction = \"x\" or \"y\" (useful, e.g., for brushing time series). \n::::\n:::::\n\n\n\n###### header2\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-code-name-b}\n: Numbered R Code Title (Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n:::\n\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\n\n\n\n\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}