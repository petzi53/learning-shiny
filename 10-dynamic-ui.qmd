# Dynamic UI {#sec-chap10}


```{r}
#| label: setup
#| results: hold
#| include: false

base::source(file = "R/helper.R")

library(glossary)
glossary::glossary_path("../glossary-pb/glossary.yml")

```

## Table of content for chapter 10 {.unnumbered}

::::: {#obj-chap03}
:::: {.my-objectives}
::: {.my-objectives-header}
Chapter section list
:::

::: {.my-objectives-container}


:::
::::
:::::

There are three key techniques for creating dynamic user interfaces:

- Using the update family of functions to modify parameters of input controls.
- Using `tabsetPanel()` to conditionally show and hide parts of the user interface.
- Using `uiOutput()` and `renderUI()` to generate selected parts of the user interface with code.


## Updating inputs

We’ll begin with a simple technique that allows you to modify an input after it has been created: the update family of functions. [Every input control]{.mark}, e.g. `textInput()`, [is paired with an **update function**]{.mark}, e.g. `updateTextInput()`, that allows you to modify the control after it has been created.

The key idea to modify an input is to use `observeEvent()` to trigger the corresponding update<whatever> function whenever the input changes. (For the `observeEvent()` function see @sec-03-observers and @XXX15.3.)

::: {.column-page-inset}

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-10-updating-inputs-intro}
: Updating the slider whenever the the minimum or maximum input changes
::::::
:::
::::{.my-r-code-container}

```{shinylive-r}
#| standalone: true
#| viewerHeight: 400
#| components: [editor, viewer]

## file: app.R
{{< include apps_10/01-updating-inputs-intro/app.R >}}
```



::::
:::::

::: 

### Simple uses

#### Reset button


The simplest uses of the update functions are to provide small conveniences for the user. For example, maybe you want to make it easy to reset parameters back to their initial value.

::: {.column-page-inset}

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-10-updating-with-reset-button}
: Updating controls with reset button
::::::
:::
::::{.my-r-code-container}
```{shinylive-r}
#| standalone: true
#| viewerHeight: 400
#| components: [editor, viewer]

## file: app.R
{{< include apps_10/02-updating-with-reset-button/app.R >}}
```
::::
:::::

::: 


### Button changed functionality

A similar application is to tweak the text of an action button so you know exactly what it’s going to do.


::: {.column-page-inset}

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-10-updating-vutton-text}
: Updating button text if it has changed functionality
::::::
:::
::::{.my-r-code-container}
```{shinylive-r}
#| standalone: true
#| viewerHeight: 400
#| components: [editor, viewer]

## file: app.R
{{< include apps_10/03-updating-button-text/app.R >}}
```
::::
:::::

::: 

### Hierarchical select boxes {#sec-10-hierarchical-selct-boxes}

A more complicated, but particularly useful, application of the update functions is to allow interactive drill down across multiple categories. I’ll illustrate their usage with some imaginary data for a sales dashboard.

:::::{.my-resource}
:::{.my-resource-header}
:::::: {#lem-10-kaggle}
: Kaggle --- An online community platform for data scientists and machine learning enthusiasts
::::::
:::
::::{.my-resource-container}
This section uses [Sample Sales Data](https://www.kaggle.com/datasets/kyanyoga/sample-sales-data), a well-documented imaginary dataset provided by `r glossary("Kaggle")` for education, training and research. To download the dataset from Kaggle you have to register. But you can also download the Sample Sales Data as `r glossary("CSV", ".csv")` file from the [GitHub repo of Mastering Shiny](https://github.com/hadley/mastering-shiny/raw/refs/heads/main/sales-dashboard/sales_data_sample.csv) or alternatively my own version of the dataset.

***

[Kaggle](https://www.kaggle.com/) is one of the largest hosting platforms used by data scientists and machine learning enthusiasts globally. It allows users to collaborate with other users, find and publish datasets, use GPU integrated notebooks, and compete with other data scientists to solve data science challenges.  

Founded in 2010 by [Anthony Goldbloom](https://en.wikipedia.org/wiki/Anthony_Goldbloom) and [Jeremy Howard](https://en.wikipedia.org/wiki/Jeremy_Howard_(entrepreneur)), Kaggle was acquired by Google in 2017. 
::::
:::::

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-10-load-sales-dataset}
: Load and display sales dataset
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: code-chunk-name

sales <- vroom::vroom("data/sales_data_sample.csv", col_types = list(), na = "")
sales  |> 
  dplyr::select(TERRITORY, CUSTOMERNAME, ORDERNUMBER, dplyr::everything()) |> 
  dplyr::arrange(ORDERNUMBER)
```

::::
:::::

For this demo, I’m going to focus on a natural hierarchy in the data:

- Each territory contains customers.
- Each customer has multiple orders.
- Each order contains rows.

I want to create a user interface where you can:

- Select a territory to see all customers.
- Select a customer to see all orders.
- Select an order to see the underlying rows.

The essence of the UI is simple: I’ll create three select boxes and one output table. The choices for the `customername` and `ordernumber` select boxes will be dynamically generated, so I set `choices = NULL`.

In the server function, there is th following top-down procedure to follow:

:::::{.my-procedure}
:::{.my-procedure-header}
:::::: {#prp-10-replicate-hierarchical-data-structure}
: Replicating the hierarchical data structure in the server function
::::::
:::
::::{.my-procedure-container}

1. Create a reactive, `territory()`, that contains the rows from sales that match the selected territory.
2. Whenever `territory()` changes, update the list of choices in the `input$customername` select box.
3. Create another reactive, `customer()`, that contains the rows from `territory()` that match the selected customer.
4. Whenever `customer()` changes, update the list of choices in the `input$ordernumber` select box.
5. Display the selected orders in `output$data`.

::::
:::::

:::{.column-page-inset}

:::::{.my-example}
:::{.my-example-header}
:::::: {#exm-10-updating-nested}
: Hierarchical select boxes
::::::
:::
::::{.my-example-container}

::: {.panel-tabset}

###### First take

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-10-updating-nested1}
: Hierarchical select boxes: Small demo
::::::
:::
::::{.my-r-code-container}
::: {#lst-10-updating-nested1}

```{shinylive-r}
#| standalone: true
#| viewerHeight: 550
#| components: [editor, viewer]

## file: app.R
{{< include apps_10/04-updating-nested1/app.R >}}
```

Small demo of hierarchical select boxes
:::

::::
:::::


###### Improved demo

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-10-updating-nested2}
: Hierarchical select boxes: More fleshed out
::::::
:::
::::{.my-r-code-container}
::: {#lst-10-updating-nested2}


```{shinylive-r}
#| standalone: true
#| viewerHeight: 550
#| components: [editor, viewer]


## file: app.R
{{< include apps_10/04-updating-nested2/app.R >}}

```

Hierarchical select boxes: more fleshed out demo
:::

::::
:::::

:::

::::
:::::

:::

::: {.callout-warning #wrn-10-upating-nested}
###### Couldn't load data without user input

To get a version that works with Shiny and shinylive-r at the same time, I had to provide `fileInput()`. This is suboptimal as the user has to find and select the file to get the intended data for playing around.

It was easy to find a solution for Shiny: Just load the data before the ui/server part into an R object and then reference it from the `server()` function. I couldn’t manage the same result for `shinylive-r`. Local references, relative URL and non-HTTPS URL generate error. The only possible way seems to doanload the data via HTTPS. I tried but didn’t succeed. I asked for help via the [Posit Community](https://forum.posit.co/t/shinylive-in-quarto-document-with-reactive-data-source/204237) and are currently waiting for answers.

A workaround was to provide a file upload control. But even to create a workable demo took me hours. It was a bitter experience to learn that I still didn't understand quite well how reactives work. As the debugger `browser()` did not work, it was finally for me quite helpful to install `print()` outputs in **every** reactive function to see what happens. In the end I solved this problem with three important changes:

1. Creating a reactive value with `sales <- reactiveVal()`.
2. Adding an `observeEvent()` function which fulfilled several tasks:
    - Loading the data after `fileInput()` was active.  
    - Assigning the file to the reactive value `sales`.
    - Updating with the data the choice of the territory `selectInput()` function. (Previously I had to set the UI choices for territory to NULL to prevent an error because the data was not available at start up.)
3. The reference to the previous `sales` object had to be changed to the reactive function `sales()`. Additional had I to add `req(input$upload)` to prevent that the reactive territory function is called immediately after start up without available data.


:::


## Glossary Entries {#unnumbered}

```{r}
#| label: glossary-table
#| echo: false

glossary_table()
```

------------------------------------------------------------------------

## Session Info {.unnumbered}

::: my-r-code
::: my-r-code-header
Session Info
:::

::: my-r-code-container
```{r}
#| label: session-info

sessioninfo::session_info()
```
:::
:::

